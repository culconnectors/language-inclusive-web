
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Organizer
 * 
 */
export type Organizer = $Result.DefaultSelection<Prisma.$OrganizerPayload>
/**
 * Model Logo
 * 
 */
export type Logo = $Result.DefaultSelection<Prisma.$LogoPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Website
 * 
 */
export type Website = $Result.DefaultSelection<Prisma.$WebsitePayload>
/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Lga
 * 
 */
export type Lga = $Result.DefaultSelection<Prisma.$LgaPayload>
/**
 * Model Nationality
 * 
 */
export type Nationality = $Result.DefaultSelection<Prisma.$NationalityPayload>
/**
 * Model LgaNationality
 * 
 */
export type LgaNationality = $Result.DefaultSelection<Prisma.$LgaNationalityPayload>
/**
 * Model CouncilInfo
 * 
 */
export type CouncilInfo = $Result.DefaultSelection<Prisma.$CouncilInfoPayload>
/**
 * Model Postcode
 * 
 */
export type Postcode = $Result.DefaultSelection<Prisma.$PostcodePayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model LgaLanguageProficiency
 * 
 */
export type LgaLanguageProficiency = $Result.DefaultSelection<Prisma.$LgaLanguageProficiencyPayload>
/**
 * Model LgaStatistics
 * 
 */
export type LgaStatistics = $Result.DefaultSelection<Prisma.$LgaStatisticsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Venues
 * const venues = await prisma.venue.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Venues
   * const venues = await prisma.venue.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizer`: Exposes CRUD operations for the **Organizer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizers
    * const organizers = await prisma.organizer.findMany()
    * ```
    */
  get organizer(): Prisma.OrganizerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logo`: Exposes CRUD operations for the **Logo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logos
    * const logos = await prisma.logo.findMany()
    * ```
    */
  get logo(): Prisma.LogoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.website`: Exposes CRUD operations for the **Website** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Websites
    * const websites = await prisma.website.findMany()
    * ```
    */
  get website(): Prisma.WebsiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lga`: Exposes CRUD operations for the **Lga** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lgas
    * const lgas = await prisma.lga.findMany()
    * ```
    */
  get lga(): Prisma.LgaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nationality`: Exposes CRUD operations for the **Nationality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nationalities
    * const nationalities = await prisma.nationality.findMany()
    * ```
    */
  get nationality(): Prisma.NationalityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lgaNationality`: Exposes CRUD operations for the **LgaNationality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LgaNationalities
    * const lgaNationalities = await prisma.lgaNationality.findMany()
    * ```
    */
  get lgaNationality(): Prisma.LgaNationalityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.councilInfo`: Exposes CRUD operations for the **CouncilInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CouncilInfos
    * const councilInfos = await prisma.councilInfo.findMany()
    * ```
    */
  get councilInfo(): Prisma.CouncilInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postcode`: Exposes CRUD operations for the **Postcode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Postcodes
    * const postcodes = await prisma.postcode.findMany()
    * ```
    */
  get postcode(): Prisma.PostcodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lgaLanguageProficiency`: Exposes CRUD operations for the **LgaLanguageProficiency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LgaLanguageProficiencies
    * const lgaLanguageProficiencies = await prisma.lgaLanguageProficiency.findMany()
    * ```
    */
  get lgaLanguageProficiency(): Prisma.LgaLanguageProficiencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lgaStatistics`: Exposes CRUD operations for the **LgaStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LgaStatistics
    * const lgaStatistics = await prisma.lgaStatistics.findMany()
    * ```
    */
  get lgaStatistics(): Prisma.LgaStatisticsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Venue: 'Venue',
    Category: 'Category',
    Organizer: 'Organizer',
    Logo: 'Logo',
    Event: 'Event',
    Website: 'Website',
    Provider: 'Provider',
    Location: 'Location',
    Course: 'Course',
    Lga: 'Lga',
    Nationality: 'Nationality',
    LgaNationality: 'LgaNationality',
    CouncilInfo: 'CouncilInfo',
    Postcode: 'Postcode',
    Language: 'Language',
    LgaLanguageProficiency: 'LgaLanguageProficiency',
    LgaStatistics: 'LgaStatistics'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "venue" | "category" | "organizer" | "logo" | "event" | "website" | "provider" | "location" | "course" | "lga" | "nationality" | "lgaNationality" | "councilInfo" | "postcode" | "language" | "lgaLanguageProficiency" | "lgaStatistics"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Organizer: {
        payload: Prisma.$OrganizerPayload<ExtArgs>
        fields: Prisma.OrganizerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>
          }
          findFirst: {
            args: Prisma.OrganizerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>
          }
          findMany: {
            args: Prisma.OrganizerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>[]
          }
          create: {
            args: Prisma.OrganizerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>
          }
          createMany: {
            args: Prisma.OrganizerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>[]
          }
          delete: {
            args: Prisma.OrganizerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>
          }
          update: {
            args: Prisma.OrganizerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>
          }
          deleteMany: {
            args: Prisma.OrganizerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>[]
          }
          upsert: {
            args: Prisma.OrganizerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizerPayload>
          }
          aggregate: {
            args: Prisma.OrganizerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizer>
          }
          groupBy: {
            args: Prisma.OrganizerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizerCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizerCountAggregateOutputType> | number
          }
        }
      }
      Logo: {
        payload: Prisma.$LogoPayload<ExtArgs>
        fields: Prisma.LogoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>
          }
          findFirst: {
            args: Prisma.LogoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>
          }
          findMany: {
            args: Prisma.LogoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>[]
          }
          create: {
            args: Prisma.LogoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>
          }
          createMany: {
            args: Prisma.LogoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>[]
          }
          delete: {
            args: Prisma.LogoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>
          }
          update: {
            args: Prisma.LogoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>
          }
          deleteMany: {
            args: Prisma.LogoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>[]
          }
          upsert: {
            args: Prisma.LogoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogoPayload>
          }
          aggregate: {
            args: Prisma.LogoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogo>
          }
          groupBy: {
            args: Prisma.LogoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogoCountArgs<ExtArgs>
            result: $Utils.Optional<LogoCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Website: {
        payload: Prisma.$WebsitePayload<ExtArgs>
        fields: Prisma.WebsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          findFirst: {
            args: Prisma.WebsiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          findMany: {
            args: Prisma.WebsiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>[]
          }
          create: {
            args: Prisma.WebsiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          createMany: {
            args: Prisma.WebsiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebsiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>[]
          }
          delete: {
            args: Prisma.WebsiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          update: {
            args: Prisma.WebsiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          deleteMany: {
            args: Prisma.WebsiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebsiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>[]
          }
          upsert: {
            args: Prisma.WebsiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsitePayload>
          }
          aggregate: {
            args: Prisma.WebsiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsite>
          }
          groupBy: {
            args: Prisma.WebsiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsiteCountArgs<ExtArgs>
            result: $Utils.Optional<WebsiteCountAggregateOutputType> | number
          }
        }
      }
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Lga: {
        payload: Prisma.$LgaPayload<ExtArgs>
        fields: Prisma.LgaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LgaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LgaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>
          }
          findFirst: {
            args: Prisma.LgaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LgaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>
          }
          findMany: {
            args: Prisma.LgaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>[]
          }
          create: {
            args: Prisma.LgaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>
          }
          createMany: {
            args: Prisma.LgaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LgaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>[]
          }
          delete: {
            args: Prisma.LgaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>
          }
          update: {
            args: Prisma.LgaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>
          }
          deleteMany: {
            args: Prisma.LgaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LgaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LgaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>[]
          }
          upsert: {
            args: Prisma.LgaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaPayload>
          }
          aggregate: {
            args: Prisma.LgaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLga>
          }
          groupBy: {
            args: Prisma.LgaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LgaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LgaCountArgs<ExtArgs>
            result: $Utils.Optional<LgaCountAggregateOutputType> | number
          }
        }
      }
      Nationality: {
        payload: Prisma.$NationalityPayload<ExtArgs>
        fields: Prisma.NationalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NationalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NationalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>
          }
          findFirst: {
            args: Prisma.NationalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NationalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>
          }
          findMany: {
            args: Prisma.NationalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>[]
          }
          create: {
            args: Prisma.NationalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>
          }
          createMany: {
            args: Prisma.NationalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NationalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>[]
          }
          delete: {
            args: Prisma.NationalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>
          }
          update: {
            args: Prisma.NationalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>
          }
          deleteMany: {
            args: Prisma.NationalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NationalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NationalityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>[]
          }
          upsert: {
            args: Prisma.NationalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NationalityPayload>
          }
          aggregate: {
            args: Prisma.NationalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNationality>
          }
          groupBy: {
            args: Prisma.NationalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<NationalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.NationalityCountArgs<ExtArgs>
            result: $Utils.Optional<NationalityCountAggregateOutputType> | number
          }
        }
      }
      LgaNationality: {
        payload: Prisma.$LgaNationalityPayload<ExtArgs>
        fields: Prisma.LgaNationalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LgaNationalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LgaNationalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>
          }
          findFirst: {
            args: Prisma.LgaNationalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LgaNationalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>
          }
          findMany: {
            args: Prisma.LgaNationalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>[]
          }
          create: {
            args: Prisma.LgaNationalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>
          }
          createMany: {
            args: Prisma.LgaNationalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LgaNationalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>[]
          }
          delete: {
            args: Prisma.LgaNationalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>
          }
          update: {
            args: Prisma.LgaNationalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>
          }
          deleteMany: {
            args: Prisma.LgaNationalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LgaNationalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LgaNationalityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>[]
          }
          upsert: {
            args: Prisma.LgaNationalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaNationalityPayload>
          }
          aggregate: {
            args: Prisma.LgaNationalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLgaNationality>
          }
          groupBy: {
            args: Prisma.LgaNationalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<LgaNationalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.LgaNationalityCountArgs<ExtArgs>
            result: $Utils.Optional<LgaNationalityCountAggregateOutputType> | number
          }
        }
      }
      CouncilInfo: {
        payload: Prisma.$CouncilInfoPayload<ExtArgs>
        fields: Prisma.CouncilInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouncilInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouncilInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>
          }
          findFirst: {
            args: Prisma.CouncilInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouncilInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>
          }
          findMany: {
            args: Prisma.CouncilInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>[]
          }
          create: {
            args: Prisma.CouncilInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>
          }
          createMany: {
            args: Prisma.CouncilInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouncilInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>[]
          }
          delete: {
            args: Prisma.CouncilInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>
          }
          update: {
            args: Prisma.CouncilInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>
          }
          deleteMany: {
            args: Prisma.CouncilInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouncilInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouncilInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>[]
          }
          upsert: {
            args: Prisma.CouncilInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouncilInfoPayload>
          }
          aggregate: {
            args: Prisma.CouncilInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCouncilInfo>
          }
          groupBy: {
            args: Prisma.CouncilInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouncilInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouncilInfoCountArgs<ExtArgs>
            result: $Utils.Optional<CouncilInfoCountAggregateOutputType> | number
          }
        }
      }
      Postcode: {
        payload: Prisma.$PostcodePayload<ExtArgs>
        fields: Prisma.PostcodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostcodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostcodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>
          }
          findFirst: {
            args: Prisma.PostcodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostcodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>
          }
          findMany: {
            args: Prisma.PostcodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>[]
          }
          create: {
            args: Prisma.PostcodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>
          }
          createMany: {
            args: Prisma.PostcodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostcodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>[]
          }
          delete: {
            args: Prisma.PostcodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>
          }
          update: {
            args: Prisma.PostcodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>
          }
          deleteMany: {
            args: Prisma.PostcodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostcodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostcodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>[]
          }
          upsert: {
            args: Prisma.PostcodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostcodePayload>
          }
          aggregate: {
            args: Prisma.PostcodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostcode>
          }
          groupBy: {
            args: Prisma.PostcodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostcodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostcodeCountArgs<ExtArgs>
            result: $Utils.Optional<PostcodeCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      LgaLanguageProficiency: {
        payload: Prisma.$LgaLanguageProficiencyPayload<ExtArgs>
        fields: Prisma.LgaLanguageProficiencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LgaLanguageProficiencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LgaLanguageProficiencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>
          }
          findFirst: {
            args: Prisma.LgaLanguageProficiencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LgaLanguageProficiencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>
          }
          findMany: {
            args: Prisma.LgaLanguageProficiencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>[]
          }
          create: {
            args: Prisma.LgaLanguageProficiencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>
          }
          createMany: {
            args: Prisma.LgaLanguageProficiencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LgaLanguageProficiencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>[]
          }
          delete: {
            args: Prisma.LgaLanguageProficiencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>
          }
          update: {
            args: Prisma.LgaLanguageProficiencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>
          }
          deleteMany: {
            args: Prisma.LgaLanguageProficiencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LgaLanguageProficiencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LgaLanguageProficiencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>[]
          }
          upsert: {
            args: Prisma.LgaLanguageProficiencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaLanguageProficiencyPayload>
          }
          aggregate: {
            args: Prisma.LgaLanguageProficiencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLgaLanguageProficiency>
          }
          groupBy: {
            args: Prisma.LgaLanguageProficiencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<LgaLanguageProficiencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.LgaLanguageProficiencyCountArgs<ExtArgs>
            result: $Utils.Optional<LgaLanguageProficiencyCountAggregateOutputType> | number
          }
        }
      }
      LgaStatistics: {
        payload: Prisma.$LgaStatisticsPayload<ExtArgs>
        fields: Prisma.LgaStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LgaStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LgaStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>
          }
          findFirst: {
            args: Prisma.LgaStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LgaStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>
          }
          findMany: {
            args: Prisma.LgaStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>[]
          }
          create: {
            args: Prisma.LgaStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>
          }
          createMany: {
            args: Prisma.LgaStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LgaStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>[]
          }
          delete: {
            args: Prisma.LgaStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>
          }
          update: {
            args: Prisma.LgaStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.LgaStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LgaStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LgaStatisticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>[]
          }
          upsert: {
            args: Prisma.LgaStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LgaStatisticsPayload>
          }
          aggregate: {
            args: Prisma.LgaStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLgaStatistics>
          }
          groupBy: {
            args: Prisma.LgaStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LgaStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LgaStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<LgaStatisticsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    venue?: VenueOmit
    category?: CategoryOmit
    organizer?: OrganizerOmit
    logo?: LogoOmit
    event?: EventOmit
    website?: WebsiteOmit
    provider?: ProviderOmit
    location?: LocationOmit
    course?: CourseOmit
    lga?: LgaOmit
    nationality?: NationalityOmit
    lgaNationality?: LgaNationalityOmit
    councilInfo?: CouncilInfoOmit
    postcode?: PostcodeOmit
    language?: LanguageOmit
    lgaLanguageProficiency?: LgaLanguageProficiencyOmit
    lgaStatistics?: LgaStatisticsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    events: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | VenueCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    events: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | CategoryCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type OrganizerCountOutputType
   */

  export type OrganizerCountOutputType = {
    events: number
  }

  export type OrganizerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | OrganizerCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * OrganizerCountOutputType without action
   */
  export type OrganizerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizerCountOutputType
     */
    select?: OrganizerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizerCountOutputType without action
   */
  export type OrganizerCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type LogoCountOutputType
   */

  export type LogoCountOutputType = {
    events: number
  }

  export type LogoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | LogoCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * LogoCountOutputType without action
   */
  export type LogoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogoCountOutputType
     */
    select?: LogoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LogoCountOutputType without action
   */
  export type LogoCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    websites: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    websites?: boolean | EventCountOutputTypeCountWebsitesArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountWebsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteWhereInput
  }


  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    courses: number
    locations: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | ProviderCountOutputTypeCountCoursesArgs
    locations?: boolean | ProviderCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }


  /**
   * Count Type LgaCountOutputType
   */

  export type LgaCountOutputType = {
    language_proficiencies: number
    lga_nationalities: number
    postcodes: number
  }

  export type LgaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language_proficiencies?: boolean | LgaCountOutputTypeCountLanguage_proficienciesArgs
    lga_nationalities?: boolean | LgaCountOutputTypeCountLga_nationalitiesArgs
    postcodes?: boolean | LgaCountOutputTypeCountPostcodesArgs
  }

  // Custom InputTypes
  /**
   * LgaCountOutputType without action
   */
  export type LgaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaCountOutputType
     */
    select?: LgaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LgaCountOutputType without action
   */
  export type LgaCountOutputTypeCountLanguage_proficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaLanguageProficiencyWhereInput
  }

  /**
   * LgaCountOutputType without action
   */
  export type LgaCountOutputTypeCountLga_nationalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaNationalityWhereInput
  }

  /**
   * LgaCountOutputType without action
   */
  export type LgaCountOutputTypeCountPostcodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostcodeWhereInput
  }


  /**
   * Count Type NationalityCountOutputType
   */

  export type NationalityCountOutputType = {
    lga_nationalities: number
  }

  export type NationalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga_nationalities?: boolean | NationalityCountOutputTypeCountLga_nationalitiesArgs
  }

  // Custom InputTypes
  /**
   * NationalityCountOutputType without action
   */
  export type NationalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NationalityCountOutputType
     */
    select?: NationalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NationalityCountOutputType without action
   */
  export type NationalityCountOutputTypeCountLga_nationalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaNationalityWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    proficiencies: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proficiencies?: boolean | LanguageCountOutputTypeCountProficienciesArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountProficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaLanguageProficiencyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    venue_latitude: number | null
    venue_longitude: number | null
    venue_postcode: number | null
  }

  export type VenueSumAggregateOutputType = {
    venue_latitude: number | null
    venue_longitude: number | null
    venue_postcode: number | null
  }

  export type VenueMinAggregateOutputType = {
    venue_id: string | null
    venue_name: string | null
    venue_address: string | null
    venue_city: string | null
    venue_latitude: number | null
    venue_longitude: number | null
    venue_postcode: number | null
  }

  export type VenueMaxAggregateOutputType = {
    venue_id: string | null
    venue_name: string | null
    venue_address: string | null
    venue_city: string | null
    venue_latitude: number | null
    venue_longitude: number | null
    venue_postcode: number | null
  }

  export type VenueCountAggregateOutputType = {
    venue_id: number
    venue_name: number
    venue_address: number
    venue_city: number
    venue_latitude: number
    venue_longitude: number
    venue_postcode: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    venue_latitude?: true
    venue_longitude?: true
    venue_postcode?: true
  }

  export type VenueSumAggregateInputType = {
    venue_latitude?: true
    venue_longitude?: true
    venue_postcode?: true
  }

  export type VenueMinAggregateInputType = {
    venue_id?: true
    venue_name?: true
    venue_address?: true
    venue_city?: true
    venue_latitude?: true
    venue_longitude?: true
    venue_postcode?: true
  }

  export type VenueMaxAggregateInputType = {
    venue_id?: true
    venue_name?: true
    venue_address?: true
    venue_city?: true
    venue_latitude?: true
    venue_longitude?: true
    venue_postcode?: true
  }

  export type VenueCountAggregateInputType = {
    venue_id?: true
    venue_name?: true
    venue_address?: true
    venue_city?: true
    venue_latitude?: true
    venue_longitude?: true
    venue_postcode?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    venue_id: string
    venue_name: string
    venue_address: string
    venue_city: string
    venue_latitude: number
    venue_longitude: number
    venue_postcode: number
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    venue_id?: boolean
    venue_name?: boolean
    venue_address?: boolean
    venue_city?: boolean
    venue_latitude?: boolean
    venue_longitude?: boolean
    venue_postcode?: boolean
    events?: boolean | Venue$eventsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    venue_id?: boolean
    venue_name?: boolean
    venue_address?: boolean
    venue_city?: boolean
    venue_latitude?: boolean
    venue_longitude?: boolean
    venue_postcode?: boolean
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    venue_id?: boolean
    venue_name?: boolean
    venue_address?: boolean
    venue_city?: boolean
    venue_latitude?: boolean
    venue_longitude?: boolean
    venue_postcode?: boolean
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectScalar = {
    venue_id?: boolean
    venue_name?: boolean
    venue_address?: boolean
    venue_city?: boolean
    venue_latitude?: boolean
    venue_longitude?: boolean
    venue_postcode?: boolean
  }

  export type VenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"venue_id" | "venue_name" | "venue_address" | "venue_city" | "venue_latitude" | "venue_longitude" | "venue_postcode", ExtArgs["result"]["venue"]>
  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | Venue$eventsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      venue_id: string
      venue_name: string
      venue_address: string
      venue_city: string
      venue_latitude: number
      venue_longitude: number
      venue_postcode: number
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `venue_id`
     * const venueWithVenue_idOnly = await prisma.venue.findMany({ select: { venue_id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Venues and returns the data saved in the database.
     * @param {VenueCreateManyAndReturnArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Venues and only return the `venue_id`
     * const venueWithVenue_idOnly = await prisma.venue.createManyAndReturn({
     *   select: { venue_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues and returns the data updated in the database.
     * @param {VenueUpdateManyAndReturnArgs} args - Arguments to update many Venues.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Venues and only return the `venue_id`
     * const venueWithVenue_idOnly = await prisma.venue.updateManyAndReturn({
     *   select: { venue_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VenueUpdateManyAndReturnArgs>(args: SelectSubset<T, VenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends Venue$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */
  interface VenueFieldRefs {
    readonly venue_id: FieldRef<"Venue", 'String'>
    readonly venue_name: FieldRef<"Venue", 'String'>
    readonly venue_address: FieldRef<"Venue", 'String'>
    readonly venue_city: FieldRef<"Venue", 'String'>
    readonly venue_latitude: FieldRef<"Venue", 'Float'>
    readonly venue_longitude: FieldRef<"Venue", 'Float'>
    readonly venue_postcode: FieldRef<"Venue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue createManyAndReturn
   */
  export type VenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
  }

  /**
   * Venue updateManyAndReturn
   */
  export type VenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to delete.
     */
    limit?: number
  }

  /**
   * Venue.events
   */
  export type Venue$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    category_id: string | null
    category_name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    category_id: string | null
    category_name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    category_id: number
    category_name: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    category_id?: true
    category_name?: true
  }

  export type CategoryMaxAggregateInputType = {
    category_id?: true
    category_name?: true
  }

  export type CategoryCountAggregateInputType = {
    category_id?: true
    category_name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    category_id: string
    category_name: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
    events?: boolean | Category$eventsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    category_id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    category_id?: boolean
    category_name?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"category_id" | "category_name", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | Category$eventsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      category_id: string
      category_name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `category_id`
     * const categoryWithCategory_idOnly = await prisma.category.findMany({ select: { category_id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `category_id`
     * const categoryWithCategory_idOnly = await prisma.category.createManyAndReturn({
     *   select: { category_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `category_id`
     * const categoryWithCategory_idOnly = await prisma.category.updateManyAndReturn({
     *   select: { category_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends Category$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Category$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly category_id: FieldRef<"Category", 'String'>
    readonly category_name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.events
   */
  export type Category$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Organizer
   */

  export type AggregateOrganizer = {
    _count: OrganizerCountAggregateOutputType | null
    _min: OrganizerMinAggregateOutputType | null
    _max: OrganizerMaxAggregateOutputType | null
  }

  export type OrganizerMinAggregateOutputType = {
    organizer_id: string | null
    organizer_name: string | null
    organizer_url: string | null
  }

  export type OrganizerMaxAggregateOutputType = {
    organizer_id: string | null
    organizer_name: string | null
    organizer_url: string | null
  }

  export type OrganizerCountAggregateOutputType = {
    organizer_id: number
    organizer_name: number
    organizer_url: number
    _all: number
  }


  export type OrganizerMinAggregateInputType = {
    organizer_id?: true
    organizer_name?: true
    organizer_url?: true
  }

  export type OrganizerMaxAggregateInputType = {
    organizer_id?: true
    organizer_name?: true
    organizer_url?: true
  }

  export type OrganizerCountAggregateInputType = {
    organizer_id?: true
    organizer_name?: true
    organizer_url?: true
    _all?: true
  }

  export type OrganizerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizer to aggregate.
     */
    where?: OrganizerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizers to fetch.
     */
    orderBy?: OrganizerOrderByWithRelationInput | OrganizerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizers
    **/
    _count?: true | OrganizerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizerMaxAggregateInputType
  }

  export type GetOrganizerAggregateType<T extends OrganizerAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizer[P]>
      : GetScalarType<T[P], AggregateOrganizer[P]>
  }




  export type OrganizerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizerWhereInput
    orderBy?: OrganizerOrderByWithAggregationInput | OrganizerOrderByWithAggregationInput[]
    by: OrganizerScalarFieldEnum[] | OrganizerScalarFieldEnum
    having?: OrganizerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizerCountAggregateInputType | true
    _min?: OrganizerMinAggregateInputType
    _max?: OrganizerMaxAggregateInputType
  }

  export type OrganizerGroupByOutputType = {
    organizer_id: string
    organizer_name: string
    organizer_url: string
    _count: OrganizerCountAggregateOutputType | null
    _min: OrganizerMinAggregateOutputType | null
    _max: OrganizerMaxAggregateOutputType | null
  }

  type GetOrganizerGroupByPayload<T extends OrganizerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizerGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizerGroupByOutputType[P]>
        }
      >
    >


  export type OrganizerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organizer_id?: boolean
    organizer_name?: boolean
    organizer_url?: boolean
    events?: boolean | Organizer$eventsArgs<ExtArgs>
    _count?: boolean | OrganizerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizer"]>

  export type OrganizerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organizer_id?: boolean
    organizer_name?: boolean
    organizer_url?: boolean
  }, ExtArgs["result"]["organizer"]>

  export type OrganizerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organizer_id?: boolean
    organizer_name?: boolean
    organizer_url?: boolean
  }, ExtArgs["result"]["organizer"]>

  export type OrganizerSelectScalar = {
    organizer_id?: boolean
    organizer_name?: boolean
    organizer_url?: boolean
  }

  export type OrganizerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"organizer_id" | "organizer_name" | "organizer_url", ExtArgs["result"]["organizer"]>
  export type OrganizerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | Organizer$eventsArgs<ExtArgs>
    _count?: boolean | OrganizerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organizer"
    objects: {
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      organizer_id: string
      organizer_name: string
      organizer_url: string
    }, ExtArgs["result"]["organizer"]>
    composites: {}
  }

  type OrganizerGetPayload<S extends boolean | null | undefined | OrganizerDefaultArgs> = $Result.GetResult<Prisma.$OrganizerPayload, S>

  type OrganizerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizerCountAggregateInputType | true
    }

  export interface OrganizerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organizer'], meta: { name: 'Organizer' } }
    /**
     * Find zero or one Organizer that matches the filter.
     * @param {OrganizerFindUniqueArgs} args - Arguments to find a Organizer
     * @example
     * // Get one Organizer
     * const organizer = await prisma.organizer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizerFindUniqueArgs>(args: SelectSubset<T, OrganizerFindUniqueArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organizer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizerFindUniqueOrThrowArgs} args - Arguments to find a Organizer
     * @example
     * // Get one Organizer
     * const organizer = await prisma.organizer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizerFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organizer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizerFindFirstArgs} args - Arguments to find a Organizer
     * @example
     * // Get one Organizer
     * const organizer = await prisma.organizer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizerFindFirstArgs>(args?: SelectSubset<T, OrganizerFindFirstArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organizer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizerFindFirstOrThrowArgs} args - Arguments to find a Organizer
     * @example
     * // Get one Organizer
     * const organizer = await prisma.organizer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizerFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizers
     * const organizers = await prisma.organizer.findMany()
     * 
     * // Get first 10 Organizers
     * const organizers = await prisma.organizer.findMany({ take: 10 })
     * 
     * // Only select the `organizer_id`
     * const organizerWithOrganizer_idOnly = await prisma.organizer.findMany({ select: { organizer_id: true } })
     * 
     */
    findMany<T extends OrganizerFindManyArgs>(args?: SelectSubset<T, OrganizerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organizer.
     * @param {OrganizerCreateArgs} args - Arguments to create a Organizer.
     * @example
     * // Create one Organizer
     * const Organizer = await prisma.organizer.create({
     *   data: {
     *     // ... data to create a Organizer
     *   }
     * })
     * 
     */
    create<T extends OrganizerCreateArgs>(args: SelectSubset<T, OrganizerCreateArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizers.
     * @param {OrganizerCreateManyArgs} args - Arguments to create many Organizers.
     * @example
     * // Create many Organizers
     * const organizer = await prisma.organizer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizerCreateManyArgs>(args?: SelectSubset<T, OrganizerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizers and returns the data saved in the database.
     * @param {OrganizerCreateManyAndReturnArgs} args - Arguments to create many Organizers.
     * @example
     * // Create many Organizers
     * const organizer = await prisma.organizer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizers and only return the `organizer_id`
     * const organizerWithOrganizer_idOnly = await prisma.organizer.createManyAndReturn({
     *   select: { organizer_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizerCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organizer.
     * @param {OrganizerDeleteArgs} args - Arguments to delete one Organizer.
     * @example
     * // Delete one Organizer
     * const Organizer = await prisma.organizer.delete({
     *   where: {
     *     // ... filter to delete one Organizer
     *   }
     * })
     * 
     */
    delete<T extends OrganizerDeleteArgs>(args: SelectSubset<T, OrganizerDeleteArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organizer.
     * @param {OrganizerUpdateArgs} args - Arguments to update one Organizer.
     * @example
     * // Update one Organizer
     * const organizer = await prisma.organizer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizerUpdateArgs>(args: SelectSubset<T, OrganizerUpdateArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizers.
     * @param {OrganizerDeleteManyArgs} args - Arguments to filter Organizers to delete.
     * @example
     * // Delete a few Organizers
     * const { count } = await prisma.organizer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizerDeleteManyArgs>(args?: SelectSubset<T, OrganizerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizers
     * const organizer = await prisma.organizer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizerUpdateManyArgs>(args: SelectSubset<T, OrganizerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizers and returns the data updated in the database.
     * @param {OrganizerUpdateManyAndReturnArgs} args - Arguments to update many Organizers.
     * @example
     * // Update many Organizers
     * const organizer = await prisma.organizer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizers and only return the `organizer_id`
     * const organizerWithOrganizer_idOnly = await prisma.organizer.updateManyAndReturn({
     *   select: { organizer_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizerUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organizer.
     * @param {OrganizerUpsertArgs} args - Arguments to update or create a Organizer.
     * @example
     * // Update or create a Organizer
     * const organizer = await prisma.organizer.upsert({
     *   create: {
     *     // ... data to create a Organizer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organizer we want to update
     *   }
     * })
     */
    upsert<T extends OrganizerUpsertArgs>(args: SelectSubset<T, OrganizerUpsertArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizerCountArgs} args - Arguments to filter Organizers to count.
     * @example
     * // Count the number of Organizers
     * const count = await prisma.organizer.count({
     *   where: {
     *     // ... the filter for the Organizers we want to count
     *   }
     * })
    **/
    count<T extends OrganizerCountArgs>(
      args?: Subset<T, OrganizerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organizer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizerAggregateArgs>(args: Subset<T, OrganizerAggregateArgs>): Prisma.PrismaPromise<GetOrganizerAggregateType<T>>

    /**
     * Group by Organizer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizerGroupByArgs['orderBy'] }
        : { orderBy?: OrganizerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organizer model
   */
  readonly fields: OrganizerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organizer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends Organizer$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Organizer$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organizer model
   */
  interface OrganizerFieldRefs {
    readonly organizer_id: FieldRef<"Organizer", 'String'>
    readonly organizer_name: FieldRef<"Organizer", 'String'>
    readonly organizer_url: FieldRef<"Organizer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organizer findUnique
   */
  export type OrganizerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * Filter, which Organizer to fetch.
     */
    where: OrganizerWhereUniqueInput
  }

  /**
   * Organizer findUniqueOrThrow
   */
  export type OrganizerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * Filter, which Organizer to fetch.
     */
    where: OrganizerWhereUniqueInput
  }

  /**
   * Organizer findFirst
   */
  export type OrganizerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * Filter, which Organizer to fetch.
     */
    where?: OrganizerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizers to fetch.
     */
    orderBy?: OrganizerOrderByWithRelationInput | OrganizerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizers.
     */
    cursor?: OrganizerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizers.
     */
    distinct?: OrganizerScalarFieldEnum | OrganizerScalarFieldEnum[]
  }

  /**
   * Organizer findFirstOrThrow
   */
  export type OrganizerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * Filter, which Organizer to fetch.
     */
    where?: OrganizerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizers to fetch.
     */
    orderBy?: OrganizerOrderByWithRelationInput | OrganizerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizers.
     */
    cursor?: OrganizerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizers.
     */
    distinct?: OrganizerScalarFieldEnum | OrganizerScalarFieldEnum[]
  }

  /**
   * Organizer findMany
   */
  export type OrganizerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * Filter, which Organizers to fetch.
     */
    where?: OrganizerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizers to fetch.
     */
    orderBy?: OrganizerOrderByWithRelationInput | OrganizerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizers.
     */
    cursor?: OrganizerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizers.
     */
    skip?: number
    distinct?: OrganizerScalarFieldEnum | OrganizerScalarFieldEnum[]
  }

  /**
   * Organizer create
   */
  export type OrganizerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * The data needed to create a Organizer.
     */
    data: XOR<OrganizerCreateInput, OrganizerUncheckedCreateInput>
  }

  /**
   * Organizer createMany
   */
  export type OrganizerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizers.
     */
    data: OrganizerCreateManyInput | OrganizerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organizer createManyAndReturn
   */
  export type OrganizerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * The data used to create many Organizers.
     */
    data: OrganizerCreateManyInput | OrganizerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organizer update
   */
  export type OrganizerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * The data needed to update a Organizer.
     */
    data: XOR<OrganizerUpdateInput, OrganizerUncheckedUpdateInput>
    /**
     * Choose, which Organizer to update.
     */
    where: OrganizerWhereUniqueInput
  }

  /**
   * Organizer updateMany
   */
  export type OrganizerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizers.
     */
    data: XOR<OrganizerUpdateManyMutationInput, OrganizerUncheckedUpdateManyInput>
    /**
     * Filter which Organizers to update
     */
    where?: OrganizerWhereInput
    /**
     * Limit how many Organizers to update.
     */
    limit?: number
  }

  /**
   * Organizer updateManyAndReturn
   */
  export type OrganizerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * The data used to update Organizers.
     */
    data: XOR<OrganizerUpdateManyMutationInput, OrganizerUncheckedUpdateManyInput>
    /**
     * Filter which Organizers to update
     */
    where?: OrganizerWhereInput
    /**
     * Limit how many Organizers to update.
     */
    limit?: number
  }

  /**
   * Organizer upsert
   */
  export type OrganizerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * The filter to search for the Organizer to update in case it exists.
     */
    where: OrganizerWhereUniqueInput
    /**
     * In case the Organizer found by the `where` argument doesn't exist, create a new Organizer with this data.
     */
    create: XOR<OrganizerCreateInput, OrganizerUncheckedCreateInput>
    /**
     * In case the Organizer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizerUpdateInput, OrganizerUncheckedUpdateInput>
  }

  /**
   * Organizer delete
   */
  export type OrganizerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    /**
     * Filter which Organizer to delete.
     */
    where: OrganizerWhereUniqueInput
  }

  /**
   * Organizer deleteMany
   */
  export type OrganizerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizers to delete
     */
    where?: OrganizerWhereInput
    /**
     * Limit how many Organizers to delete.
     */
    limit?: number
  }

  /**
   * Organizer.events
   */
  export type Organizer$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Organizer without action
   */
  export type OrganizerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
  }


  /**
   * Model Logo
   */

  export type AggregateLogo = {
    _count: LogoCountAggregateOutputType | null
    _avg: LogoAvgAggregateOutputType | null
    _sum: LogoSumAggregateOutputType | null
    _min: LogoMinAggregateOutputType | null
    _max: LogoMaxAggregateOutputType | null
  }

  export type LogoAvgAggregateOutputType = {
    logo_id: number | null
    logo_width: number | null
    logo_height: number | null
    logo_aspect_ratio: number | null
  }

  export type LogoSumAggregateOutputType = {
    logo_id: bigint | null
    logo_width: number | null
    logo_height: number | null
    logo_aspect_ratio: number | null
  }

  export type LogoMinAggregateOutputType = {
    logo_id: bigint | null
    logo_url: string | null
    logo_width: number | null
    logo_height: number | null
    logo_aspect_ratio: number | null
  }

  export type LogoMaxAggregateOutputType = {
    logo_id: bigint | null
    logo_url: string | null
    logo_width: number | null
    logo_height: number | null
    logo_aspect_ratio: number | null
  }

  export type LogoCountAggregateOutputType = {
    logo_id: number
    logo_url: number
    logo_width: number
    logo_height: number
    logo_aspect_ratio: number
    _all: number
  }


  export type LogoAvgAggregateInputType = {
    logo_id?: true
    logo_width?: true
    logo_height?: true
    logo_aspect_ratio?: true
  }

  export type LogoSumAggregateInputType = {
    logo_id?: true
    logo_width?: true
    logo_height?: true
    logo_aspect_ratio?: true
  }

  export type LogoMinAggregateInputType = {
    logo_id?: true
    logo_url?: true
    logo_width?: true
    logo_height?: true
    logo_aspect_ratio?: true
  }

  export type LogoMaxAggregateInputType = {
    logo_id?: true
    logo_url?: true
    logo_width?: true
    logo_height?: true
    logo_aspect_ratio?: true
  }

  export type LogoCountAggregateInputType = {
    logo_id?: true
    logo_url?: true
    logo_width?: true
    logo_height?: true
    logo_aspect_ratio?: true
    _all?: true
  }

  export type LogoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logo to aggregate.
     */
    where?: LogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogoOrderByWithRelationInput | LogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logos
    **/
    _count?: true | LogoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogoMaxAggregateInputType
  }

  export type GetLogoAggregateType<T extends LogoAggregateArgs> = {
        [P in keyof T & keyof AggregateLogo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogo[P]>
      : GetScalarType<T[P], AggregateLogo[P]>
  }




  export type LogoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogoWhereInput
    orderBy?: LogoOrderByWithAggregationInput | LogoOrderByWithAggregationInput[]
    by: LogoScalarFieldEnum[] | LogoScalarFieldEnum
    having?: LogoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogoCountAggregateInputType | true
    _avg?: LogoAvgAggregateInputType
    _sum?: LogoSumAggregateInputType
    _min?: LogoMinAggregateInputType
    _max?: LogoMaxAggregateInputType
  }

  export type LogoGroupByOutputType = {
    logo_id: bigint
    logo_url: string
    logo_width: number
    logo_height: number
    logo_aspect_ratio: number
    _count: LogoCountAggregateOutputType | null
    _avg: LogoAvgAggregateOutputType | null
    _sum: LogoSumAggregateOutputType | null
    _min: LogoMinAggregateOutputType | null
    _max: LogoMaxAggregateOutputType | null
  }

  type GetLogoGroupByPayload<T extends LogoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogoGroupByOutputType[P]>
            : GetScalarType<T[P], LogoGroupByOutputType[P]>
        }
      >
    >


  export type LogoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logo_id?: boolean
    logo_url?: boolean
    logo_width?: boolean
    logo_height?: boolean
    logo_aspect_ratio?: boolean
    events?: boolean | Logo$eventsArgs<ExtArgs>
    _count?: boolean | LogoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logo"]>

  export type LogoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logo_id?: boolean
    logo_url?: boolean
    logo_width?: boolean
    logo_height?: boolean
    logo_aspect_ratio?: boolean
  }, ExtArgs["result"]["logo"]>

  export type LogoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logo_id?: boolean
    logo_url?: boolean
    logo_width?: boolean
    logo_height?: boolean
    logo_aspect_ratio?: boolean
  }, ExtArgs["result"]["logo"]>

  export type LogoSelectScalar = {
    logo_id?: boolean
    logo_url?: boolean
    logo_width?: boolean
    logo_height?: boolean
    logo_aspect_ratio?: boolean
  }

  export type LogoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"logo_id" | "logo_url" | "logo_width" | "logo_height" | "logo_aspect_ratio", ExtArgs["result"]["logo"]>
  export type LogoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | Logo$eventsArgs<ExtArgs>
    _count?: boolean | LogoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LogoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LogoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LogoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logo"
    objects: {
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      logo_id: bigint
      logo_url: string
      logo_width: number
      logo_height: number
      logo_aspect_ratio: number
    }, ExtArgs["result"]["logo"]>
    composites: {}
  }

  type LogoGetPayload<S extends boolean | null | undefined | LogoDefaultArgs> = $Result.GetResult<Prisma.$LogoPayload, S>

  type LogoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogoCountAggregateInputType | true
    }

  export interface LogoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logo'], meta: { name: 'Logo' } }
    /**
     * Find zero or one Logo that matches the filter.
     * @param {LogoFindUniqueArgs} args - Arguments to find a Logo
     * @example
     * // Get one Logo
     * const logo = await prisma.logo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogoFindUniqueArgs>(args: SelectSubset<T, LogoFindUniqueArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogoFindUniqueOrThrowArgs} args - Arguments to find a Logo
     * @example
     * // Get one Logo
     * const logo = await prisma.logo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogoFindUniqueOrThrowArgs>(args: SelectSubset<T, LogoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogoFindFirstArgs} args - Arguments to find a Logo
     * @example
     * // Get one Logo
     * const logo = await prisma.logo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogoFindFirstArgs>(args?: SelectSubset<T, LogoFindFirstArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogoFindFirstOrThrowArgs} args - Arguments to find a Logo
     * @example
     * // Get one Logo
     * const logo = await prisma.logo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogoFindFirstOrThrowArgs>(args?: SelectSubset<T, LogoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logos
     * const logos = await prisma.logo.findMany()
     * 
     * // Get first 10 Logos
     * const logos = await prisma.logo.findMany({ take: 10 })
     * 
     * // Only select the `logo_id`
     * const logoWithLogo_idOnly = await prisma.logo.findMany({ select: { logo_id: true } })
     * 
     */
    findMany<T extends LogoFindManyArgs>(args?: SelectSubset<T, LogoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logo.
     * @param {LogoCreateArgs} args - Arguments to create a Logo.
     * @example
     * // Create one Logo
     * const Logo = await prisma.logo.create({
     *   data: {
     *     // ... data to create a Logo
     *   }
     * })
     * 
     */
    create<T extends LogoCreateArgs>(args: SelectSubset<T, LogoCreateArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logos.
     * @param {LogoCreateManyArgs} args - Arguments to create many Logos.
     * @example
     * // Create many Logos
     * const logo = await prisma.logo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogoCreateManyArgs>(args?: SelectSubset<T, LogoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logos and returns the data saved in the database.
     * @param {LogoCreateManyAndReturnArgs} args - Arguments to create many Logos.
     * @example
     * // Create many Logos
     * const logo = await prisma.logo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logos and only return the `logo_id`
     * const logoWithLogo_idOnly = await prisma.logo.createManyAndReturn({
     *   select: { logo_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogoCreateManyAndReturnArgs>(args?: SelectSubset<T, LogoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Logo.
     * @param {LogoDeleteArgs} args - Arguments to delete one Logo.
     * @example
     * // Delete one Logo
     * const Logo = await prisma.logo.delete({
     *   where: {
     *     // ... filter to delete one Logo
     *   }
     * })
     * 
     */
    delete<T extends LogoDeleteArgs>(args: SelectSubset<T, LogoDeleteArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logo.
     * @param {LogoUpdateArgs} args - Arguments to update one Logo.
     * @example
     * // Update one Logo
     * const logo = await prisma.logo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogoUpdateArgs>(args: SelectSubset<T, LogoUpdateArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logos.
     * @param {LogoDeleteManyArgs} args - Arguments to filter Logos to delete.
     * @example
     * // Delete a few Logos
     * const { count } = await prisma.logo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogoDeleteManyArgs>(args?: SelectSubset<T, LogoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logos
     * const logo = await prisma.logo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogoUpdateManyArgs>(args: SelectSubset<T, LogoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logos and returns the data updated in the database.
     * @param {LogoUpdateManyAndReturnArgs} args - Arguments to update many Logos.
     * @example
     * // Update many Logos
     * const logo = await prisma.logo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logos and only return the `logo_id`
     * const logoWithLogo_idOnly = await prisma.logo.updateManyAndReturn({
     *   select: { logo_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogoUpdateManyAndReturnArgs>(args: SelectSubset<T, LogoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Logo.
     * @param {LogoUpsertArgs} args - Arguments to update or create a Logo.
     * @example
     * // Update or create a Logo
     * const logo = await prisma.logo.upsert({
     *   create: {
     *     // ... data to create a Logo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logo we want to update
     *   }
     * })
     */
    upsert<T extends LogoUpsertArgs>(args: SelectSubset<T, LogoUpsertArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogoCountArgs} args - Arguments to filter Logos to count.
     * @example
     * // Count the number of Logos
     * const count = await prisma.logo.count({
     *   where: {
     *     // ... the filter for the Logos we want to count
     *   }
     * })
    **/
    count<T extends LogoCountArgs>(
      args?: Subset<T, LogoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogoAggregateArgs>(args: Subset<T, LogoAggregateArgs>): Prisma.PrismaPromise<GetLogoAggregateType<T>>

    /**
     * Group by Logo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogoGroupByArgs['orderBy'] }
        : { orderBy?: LogoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logo model
   */
  readonly fields: LogoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends Logo$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Logo$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Logo model
   */
  interface LogoFieldRefs {
    readonly logo_id: FieldRef<"Logo", 'BigInt'>
    readonly logo_url: FieldRef<"Logo", 'String'>
    readonly logo_width: FieldRef<"Logo", 'Int'>
    readonly logo_height: FieldRef<"Logo", 'Int'>
    readonly logo_aspect_ratio: FieldRef<"Logo", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Logo findUnique
   */
  export type LogoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * Filter, which Logo to fetch.
     */
    where: LogoWhereUniqueInput
  }

  /**
   * Logo findUniqueOrThrow
   */
  export type LogoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * Filter, which Logo to fetch.
     */
    where: LogoWhereUniqueInput
  }

  /**
   * Logo findFirst
   */
  export type LogoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * Filter, which Logo to fetch.
     */
    where?: LogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogoOrderByWithRelationInput | LogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logos.
     */
    cursor?: LogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logos.
     */
    distinct?: LogoScalarFieldEnum | LogoScalarFieldEnum[]
  }

  /**
   * Logo findFirstOrThrow
   */
  export type LogoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * Filter, which Logo to fetch.
     */
    where?: LogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogoOrderByWithRelationInput | LogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logos.
     */
    cursor?: LogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logos.
     */
    distinct?: LogoScalarFieldEnum | LogoScalarFieldEnum[]
  }

  /**
   * Logo findMany
   */
  export type LogoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * Filter, which Logos to fetch.
     */
    where?: LogoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logos to fetch.
     */
    orderBy?: LogoOrderByWithRelationInput | LogoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logos.
     */
    cursor?: LogoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logos.
     */
    skip?: number
    distinct?: LogoScalarFieldEnum | LogoScalarFieldEnum[]
  }

  /**
   * Logo create
   */
  export type LogoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * The data needed to create a Logo.
     */
    data: XOR<LogoCreateInput, LogoUncheckedCreateInput>
  }

  /**
   * Logo createMany
   */
  export type LogoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logos.
     */
    data: LogoCreateManyInput | LogoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Logo createManyAndReturn
   */
  export type LogoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * The data used to create many Logos.
     */
    data: LogoCreateManyInput | LogoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Logo update
   */
  export type LogoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * The data needed to update a Logo.
     */
    data: XOR<LogoUpdateInput, LogoUncheckedUpdateInput>
    /**
     * Choose, which Logo to update.
     */
    where: LogoWhereUniqueInput
  }

  /**
   * Logo updateMany
   */
  export type LogoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logos.
     */
    data: XOR<LogoUpdateManyMutationInput, LogoUncheckedUpdateManyInput>
    /**
     * Filter which Logos to update
     */
    where?: LogoWhereInput
    /**
     * Limit how many Logos to update.
     */
    limit?: number
  }

  /**
   * Logo updateManyAndReturn
   */
  export type LogoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * The data used to update Logos.
     */
    data: XOR<LogoUpdateManyMutationInput, LogoUncheckedUpdateManyInput>
    /**
     * Filter which Logos to update
     */
    where?: LogoWhereInput
    /**
     * Limit how many Logos to update.
     */
    limit?: number
  }

  /**
   * Logo upsert
   */
  export type LogoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * The filter to search for the Logo to update in case it exists.
     */
    where: LogoWhereUniqueInput
    /**
     * In case the Logo found by the `where` argument doesn't exist, create a new Logo with this data.
     */
    create: XOR<LogoCreateInput, LogoUncheckedCreateInput>
    /**
     * In case the Logo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogoUpdateInput, LogoUncheckedUpdateInput>
  }

  /**
   * Logo delete
   */
  export type LogoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    /**
     * Filter which Logo to delete.
     */
    where: LogoWhereUniqueInput
  }

  /**
   * Logo deleteMany
   */
  export type LogoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logos to delete
     */
    where?: LogoWhereInput
    /**
     * Limit how many Logos to delete.
     */
    limit?: number
  }

  /**
   * Logo.events
   */
  export type Logo$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Logo without action
   */
  export type LogoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    logo_id: number | null
  }

  export type EventSumAggregateOutputType = {
    logo_id: bigint | null
  }

  export type EventMinAggregateOutputType = {
    event_id: string | null
    event_name: string | null
    event_description: string | null
    start_datetime: Date | null
    end_datetime: Date | null
    event_summary: string | null
    category_id: string | null
    organizer_id: string | null
    venue_id: string | null
    logo_id: bigint | null
    event_status: string | null
    event_url: string | null
    is_free_event: boolean | null
    community_friendly: boolean | null
    predicted_community_friendly: boolean | null
  }

  export type EventMaxAggregateOutputType = {
    event_id: string | null
    event_name: string | null
    event_description: string | null
    start_datetime: Date | null
    end_datetime: Date | null
    event_summary: string | null
    category_id: string | null
    organizer_id: string | null
    venue_id: string | null
    logo_id: bigint | null
    event_status: string | null
    event_url: string | null
    is_free_event: boolean | null
    community_friendly: boolean | null
    predicted_community_friendly: boolean | null
  }

  export type EventCountAggregateOutputType = {
    event_id: number
    event_name: number
    event_description: number
    start_datetime: number
    end_datetime: number
    event_summary: number
    category_id: number
    organizer_id: number
    venue_id: number
    logo_id: number
    event_status: number
    event_url: number
    is_free_event: number
    community_friendly: number
    predicted_community_friendly: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    logo_id?: true
  }

  export type EventSumAggregateInputType = {
    logo_id?: true
  }

  export type EventMinAggregateInputType = {
    event_id?: true
    event_name?: true
    event_description?: true
    start_datetime?: true
    end_datetime?: true
    event_summary?: true
    category_id?: true
    organizer_id?: true
    venue_id?: true
    logo_id?: true
    event_status?: true
    event_url?: true
    is_free_event?: true
    community_friendly?: true
    predicted_community_friendly?: true
  }

  export type EventMaxAggregateInputType = {
    event_id?: true
    event_name?: true
    event_description?: true
    start_datetime?: true
    end_datetime?: true
    event_summary?: true
    category_id?: true
    organizer_id?: true
    venue_id?: true
    logo_id?: true
    event_status?: true
    event_url?: true
    is_free_event?: true
    community_friendly?: true
    predicted_community_friendly?: true
  }

  export type EventCountAggregateInputType = {
    event_id?: true
    event_name?: true
    event_description?: true
    start_datetime?: true
    end_datetime?: true
    event_summary?: true
    category_id?: true
    organizer_id?: true
    venue_id?: true
    logo_id?: true
    event_status?: true
    event_url?: true
    is_free_event?: true
    community_friendly?: true
    predicted_community_friendly?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date
    end_datetime: Date
    event_summary: string
    category_id: string | null
    organizer_id: string | null
    venue_id: string | null
    logo_id: bigint | null
    event_status: string
    event_url: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    event_name?: boolean
    event_description?: boolean
    start_datetime?: boolean
    end_datetime?: boolean
    event_summary?: boolean
    category_id?: boolean
    organizer_id?: boolean
    venue_id?: boolean
    logo_id?: boolean
    event_status?: boolean
    event_url?: boolean
    is_free_event?: boolean
    community_friendly?: boolean
    predicted_community_friendly?: boolean
    category?: boolean | Event$categoryArgs<ExtArgs>
    logo?: boolean | Event$logoArgs<ExtArgs>
    organizer?: boolean | Event$organizerArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
    websites?: boolean | Event$websitesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    event_name?: boolean
    event_description?: boolean
    start_datetime?: boolean
    end_datetime?: boolean
    event_summary?: boolean
    category_id?: boolean
    organizer_id?: boolean
    venue_id?: boolean
    logo_id?: boolean
    event_status?: boolean
    event_url?: boolean
    is_free_event?: boolean
    community_friendly?: boolean
    predicted_community_friendly?: boolean
    category?: boolean | Event$categoryArgs<ExtArgs>
    logo?: boolean | Event$logoArgs<ExtArgs>
    organizer?: boolean | Event$organizerArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_id?: boolean
    event_name?: boolean
    event_description?: boolean
    start_datetime?: boolean
    end_datetime?: boolean
    event_summary?: boolean
    category_id?: boolean
    organizer_id?: boolean
    venue_id?: boolean
    logo_id?: boolean
    event_status?: boolean
    event_url?: boolean
    is_free_event?: boolean
    community_friendly?: boolean
    predicted_community_friendly?: boolean
    category?: boolean | Event$categoryArgs<ExtArgs>
    logo?: boolean | Event$logoArgs<ExtArgs>
    organizer?: boolean | Event$organizerArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    event_id?: boolean
    event_name?: boolean
    event_description?: boolean
    start_datetime?: boolean
    end_datetime?: boolean
    event_summary?: boolean
    category_id?: boolean
    organizer_id?: boolean
    venue_id?: boolean
    logo_id?: boolean
    event_status?: boolean
    event_url?: boolean
    is_free_event?: boolean
    community_friendly?: boolean
    predicted_community_friendly?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"event_id" | "event_name" | "event_description" | "start_datetime" | "end_datetime" | "event_summary" | "category_id" | "organizer_id" | "venue_id" | "logo_id" | "event_status" | "event_url" | "is_free_event" | "community_friendly" | "predicted_community_friendly", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Event$categoryArgs<ExtArgs>
    logo?: boolean | Event$logoArgs<ExtArgs>
    organizer?: boolean | Event$organizerArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
    websites?: boolean | Event$websitesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Event$categoryArgs<ExtArgs>
    logo?: boolean | Event$logoArgs<ExtArgs>
    organizer?: boolean | Event$organizerArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Event$categoryArgs<ExtArgs>
    logo?: boolean | Event$logoArgs<ExtArgs>
    organizer?: boolean | Event$organizerArgs<ExtArgs>
    venue?: boolean | Event$venueArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      logo: Prisma.$LogoPayload<ExtArgs> | null
      organizer: Prisma.$OrganizerPayload<ExtArgs> | null
      venue: Prisma.$VenuePayload<ExtArgs> | null
      websites: Prisma.$WebsitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      event_id: string
      event_name: string
      event_description: string
      start_datetime: Date
      end_datetime: Date
      event_summary: string
      category_id: string | null
      organizer_id: string | null
      venue_id: string | null
      logo_id: bigint | null
      event_status: string
      event_url: string | null
      is_free_event: boolean
      community_friendly: boolean
      predicted_community_friendly: boolean
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `event_id`
     * const eventWithEvent_idOnly = await prisma.event.findMany({ select: { event_id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `event_id`
     * const eventWithEvent_idOnly = await prisma.event.createManyAndReturn({
     *   select: { event_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `event_id`
     * const eventWithEvent_idOnly = await prisma.event.updateManyAndReturn({
     *   select: { event_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Event$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Event$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logo<T extends Event$logoArgs<ExtArgs> = {}>(args?: Subset<T, Event$logoArgs<ExtArgs>>): Prisma__LogoClient<$Result.GetResult<Prisma.$LogoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organizer<T extends Event$organizerArgs<ExtArgs> = {}>(args?: Subset<T, Event$organizerArgs<ExtArgs>>): Prisma__OrganizerClient<$Result.GetResult<Prisma.$OrganizerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    venue<T extends Event$venueArgs<ExtArgs> = {}>(args?: Subset<T, Event$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    websites<T extends Event$websitesArgs<ExtArgs> = {}>(args?: Subset<T, Event$websitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly event_id: FieldRef<"Event", 'String'>
    readonly event_name: FieldRef<"Event", 'String'>
    readonly event_description: FieldRef<"Event", 'String'>
    readonly start_datetime: FieldRef<"Event", 'DateTime'>
    readonly end_datetime: FieldRef<"Event", 'DateTime'>
    readonly event_summary: FieldRef<"Event", 'String'>
    readonly category_id: FieldRef<"Event", 'String'>
    readonly organizer_id: FieldRef<"Event", 'String'>
    readonly venue_id: FieldRef<"Event", 'String'>
    readonly logo_id: FieldRef<"Event", 'BigInt'>
    readonly event_status: FieldRef<"Event", 'String'>
    readonly event_url: FieldRef<"Event", 'String'>
    readonly is_free_event: FieldRef<"Event", 'Boolean'>
    readonly community_friendly: FieldRef<"Event", 'Boolean'>
    readonly predicted_community_friendly: FieldRef<"Event", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.category
   */
  export type Event$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Event.logo
   */
  export type Event$logoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logo
     */
    select?: LogoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logo
     */
    omit?: LogoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogoInclude<ExtArgs> | null
    where?: LogoWhereInput
  }

  /**
   * Event.organizer
   */
  export type Event$organizerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organizer
     */
    select?: OrganizerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organizer
     */
    omit?: OrganizerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizerInclude<ExtArgs> | null
    where?: OrganizerWhereInput
  }

  /**
   * Event.venue
   */
  export type Event$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * Event.websites
   */
  export type Event$websitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    where?: WebsiteWhereInput
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    cursor?: WebsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Website
   */

  export type AggregateWebsite = {
    _count: WebsiteCountAggregateOutputType | null
    _min: WebsiteMinAggregateOutputType | null
    _max: WebsiteMaxAggregateOutputType | null
  }

  export type WebsiteMinAggregateOutputType = {
    event_url: string | null
    event_id: string | null
  }

  export type WebsiteMaxAggregateOutputType = {
    event_url: string | null
    event_id: string | null
  }

  export type WebsiteCountAggregateOutputType = {
    event_url: number
    event_id: number
    _all: number
  }


  export type WebsiteMinAggregateInputType = {
    event_url?: true
    event_id?: true
  }

  export type WebsiteMaxAggregateInputType = {
    event_url?: true
    event_id?: true
  }

  export type WebsiteCountAggregateInputType = {
    event_url?: true
    event_id?: true
    _all?: true
  }

  export type WebsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Website to aggregate.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Websites
    **/
    _count?: true | WebsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsiteMaxAggregateInputType
  }

  export type GetWebsiteAggregateType<T extends WebsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsite[P]>
      : GetScalarType<T[P], AggregateWebsite[P]>
  }




  export type WebsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteWhereInput
    orderBy?: WebsiteOrderByWithAggregationInput | WebsiteOrderByWithAggregationInput[]
    by: WebsiteScalarFieldEnum[] | WebsiteScalarFieldEnum
    having?: WebsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsiteCountAggregateInputType | true
    _min?: WebsiteMinAggregateInputType
    _max?: WebsiteMaxAggregateInputType
  }

  export type WebsiteGroupByOutputType = {
    event_url: string
    event_id: string
    _count: WebsiteCountAggregateOutputType | null
    _min: WebsiteMinAggregateOutputType | null
    _max: WebsiteMaxAggregateOutputType | null
  }

  type GetWebsiteGroupByPayload<T extends WebsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsiteGroupByOutputType[P]>
            : GetScalarType<T[P], WebsiteGroupByOutputType[P]>
        }
      >
    >


  export type WebsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_url?: boolean
    event_id?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["website"]>

  export type WebsiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_url?: boolean
    event_id?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["website"]>

  export type WebsiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    event_url?: boolean
    event_id?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["website"]>

  export type WebsiteSelectScalar = {
    event_url?: boolean
    event_id?: boolean
  }

  export type WebsiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"event_url" | "event_id", ExtArgs["result"]["website"]>
  export type WebsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type WebsiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type WebsiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $WebsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Website"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      event_url: string
      event_id: string
    }, ExtArgs["result"]["website"]>
    composites: {}
  }

  type WebsiteGetPayload<S extends boolean | null | undefined | WebsiteDefaultArgs> = $Result.GetResult<Prisma.$WebsitePayload, S>

  type WebsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebsiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebsiteCountAggregateInputType | true
    }

  export interface WebsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Website'], meta: { name: 'Website' } }
    /**
     * Find zero or one Website that matches the filter.
     * @param {WebsiteFindUniqueArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsiteFindUniqueArgs>(args: SelectSubset<T, WebsiteFindUniqueArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Website that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebsiteFindUniqueOrThrowArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsiteFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Website that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteFindFirstArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsiteFindFirstArgs>(args?: SelectSubset<T, WebsiteFindFirstArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Website that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteFindFirstOrThrowArgs} args - Arguments to find a Website
     * @example
     * // Get one Website
     * const website = await prisma.website.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsiteFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Websites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Websites
     * const websites = await prisma.website.findMany()
     * 
     * // Get first 10 Websites
     * const websites = await prisma.website.findMany({ take: 10 })
     * 
     * // Only select the `event_url`
     * const websiteWithEvent_urlOnly = await prisma.website.findMany({ select: { event_url: true } })
     * 
     */
    findMany<T extends WebsiteFindManyArgs>(args?: SelectSubset<T, WebsiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Website.
     * @param {WebsiteCreateArgs} args - Arguments to create a Website.
     * @example
     * // Create one Website
     * const Website = await prisma.website.create({
     *   data: {
     *     // ... data to create a Website
     *   }
     * })
     * 
     */
    create<T extends WebsiteCreateArgs>(args: SelectSubset<T, WebsiteCreateArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Websites.
     * @param {WebsiteCreateManyArgs} args - Arguments to create many Websites.
     * @example
     * // Create many Websites
     * const website = await prisma.website.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsiteCreateManyArgs>(args?: SelectSubset<T, WebsiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Websites and returns the data saved in the database.
     * @param {WebsiteCreateManyAndReturnArgs} args - Arguments to create many Websites.
     * @example
     * // Create many Websites
     * const website = await prisma.website.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Websites and only return the `event_url`
     * const websiteWithEvent_urlOnly = await prisma.website.createManyAndReturn({
     *   select: { event_url: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebsiteCreateManyAndReturnArgs>(args?: SelectSubset<T, WebsiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Website.
     * @param {WebsiteDeleteArgs} args - Arguments to delete one Website.
     * @example
     * // Delete one Website
     * const Website = await prisma.website.delete({
     *   where: {
     *     // ... filter to delete one Website
     *   }
     * })
     * 
     */
    delete<T extends WebsiteDeleteArgs>(args: SelectSubset<T, WebsiteDeleteArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Website.
     * @param {WebsiteUpdateArgs} args - Arguments to update one Website.
     * @example
     * // Update one Website
     * const website = await prisma.website.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsiteUpdateArgs>(args: SelectSubset<T, WebsiteUpdateArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Websites.
     * @param {WebsiteDeleteManyArgs} args - Arguments to filter Websites to delete.
     * @example
     * // Delete a few Websites
     * const { count } = await prisma.website.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsiteDeleteManyArgs>(args?: SelectSubset<T, WebsiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Websites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Websites
     * const website = await prisma.website.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsiteUpdateManyArgs>(args: SelectSubset<T, WebsiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Websites and returns the data updated in the database.
     * @param {WebsiteUpdateManyAndReturnArgs} args - Arguments to update many Websites.
     * @example
     * // Update many Websites
     * const website = await prisma.website.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Websites and only return the `event_url`
     * const websiteWithEvent_urlOnly = await prisma.website.updateManyAndReturn({
     *   select: { event_url: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebsiteUpdateManyAndReturnArgs>(args: SelectSubset<T, WebsiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Website.
     * @param {WebsiteUpsertArgs} args - Arguments to update or create a Website.
     * @example
     * // Update or create a Website
     * const website = await prisma.website.upsert({
     *   create: {
     *     // ... data to create a Website
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Website we want to update
     *   }
     * })
     */
    upsert<T extends WebsiteUpsertArgs>(args: SelectSubset<T, WebsiteUpsertArgs<ExtArgs>>): Prisma__WebsiteClient<$Result.GetResult<Prisma.$WebsitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Websites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteCountArgs} args - Arguments to filter Websites to count.
     * @example
     * // Count the number of Websites
     * const count = await prisma.website.count({
     *   where: {
     *     // ... the filter for the Websites we want to count
     *   }
     * })
    **/
    count<T extends WebsiteCountArgs>(
      args?: Subset<T, WebsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Website.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsiteAggregateArgs>(args: Subset<T, WebsiteAggregateArgs>): Prisma.PrismaPromise<GetWebsiteAggregateType<T>>

    /**
     * Group by Website.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsiteGroupByArgs['orderBy'] }
        : { orderBy?: WebsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Website model
   */
  readonly fields: WebsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Website.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Website model
   */
  interface WebsiteFieldRefs {
    readonly event_url: FieldRef<"Website", 'String'>
    readonly event_id: FieldRef<"Website", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Website findUnique
   */
  export type WebsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where: WebsiteWhereUniqueInput
  }

  /**
   * Website findUniqueOrThrow
   */
  export type WebsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where: WebsiteWhereUniqueInput
  }

  /**
   * Website findFirst
   */
  export type WebsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Websites.
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Websites.
     */
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }

  /**
   * Website findFirstOrThrow
   */
  export type WebsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Website to fetch.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Websites.
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Websites.
     */
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }

  /**
   * Website findMany
   */
  export type WebsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter, which Websites to fetch.
     */
    where?: WebsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websites to fetch.
     */
    orderBy?: WebsiteOrderByWithRelationInput | WebsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Websites.
     */
    cursor?: WebsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websites.
     */
    skip?: number
    distinct?: WebsiteScalarFieldEnum | WebsiteScalarFieldEnum[]
  }

  /**
   * Website create
   */
  export type WebsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Website.
     */
    data: XOR<WebsiteCreateInput, WebsiteUncheckedCreateInput>
  }

  /**
   * Website createMany
   */
  export type WebsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Websites.
     */
    data: WebsiteCreateManyInput | WebsiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Website createManyAndReturn
   */
  export type WebsiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * The data used to create many Websites.
     */
    data: WebsiteCreateManyInput | WebsiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Website update
   */
  export type WebsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Website.
     */
    data: XOR<WebsiteUpdateInput, WebsiteUncheckedUpdateInput>
    /**
     * Choose, which Website to update.
     */
    where: WebsiteWhereUniqueInput
  }

  /**
   * Website updateMany
   */
  export type WebsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Websites.
     */
    data: XOR<WebsiteUpdateManyMutationInput, WebsiteUncheckedUpdateManyInput>
    /**
     * Filter which Websites to update
     */
    where?: WebsiteWhereInput
    /**
     * Limit how many Websites to update.
     */
    limit?: number
  }

  /**
   * Website updateManyAndReturn
   */
  export type WebsiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * The data used to update Websites.
     */
    data: XOR<WebsiteUpdateManyMutationInput, WebsiteUncheckedUpdateManyInput>
    /**
     * Filter which Websites to update
     */
    where?: WebsiteWhereInput
    /**
     * Limit how many Websites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Website upsert
   */
  export type WebsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Website to update in case it exists.
     */
    where: WebsiteWhereUniqueInput
    /**
     * In case the Website found by the `where` argument doesn't exist, create a new Website with this data.
     */
    create: XOR<WebsiteCreateInput, WebsiteUncheckedCreateInput>
    /**
     * In case the Website was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsiteUpdateInput, WebsiteUncheckedUpdateInput>
  }

  /**
   * Website delete
   */
  export type WebsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
    /**
     * Filter which Website to delete.
     */
    where: WebsiteWhereUniqueInput
  }

  /**
   * Website deleteMany
   */
  export type WebsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Websites to delete
     */
    where?: WebsiteWhereInput
    /**
     * Limit how many Websites to delete.
     */
    limit?: number
  }

  /**
   * Website without action
   */
  export type WebsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Website
     */
    select?: WebsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Website
     */
    omit?: WebsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteInclude<ExtArgs> | null
  }


  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderAvgAggregateOutputType = {
    provider_id: number | null
    asqa_code: number | null
  }

  export type ProviderSumAggregateOutputType = {
    provider_id: number | null
    asqa_code: number | null
  }

  export type ProviderMinAggregateOutputType = {
    provider_id: number | null
    provider_name: string | null
    site_name: string | null
    government_subsidised: string | null
    subsidy_tag: string | null
    asqa_code: number | null
    url: string | null
    email: string | null
  }

  export type ProviderMaxAggregateOutputType = {
    provider_id: number | null
    provider_name: string | null
    site_name: string | null
    government_subsidised: string | null
    subsidy_tag: string | null
    asqa_code: number | null
    url: string | null
    email: string | null
  }

  export type ProviderCountAggregateOutputType = {
    provider_id: number
    provider_name: number
    site_name: number
    government_subsidised: number
    subsidy_tag: number
    asqa_code: number
    url: number
    email: number
    _all: number
  }


  export type ProviderAvgAggregateInputType = {
    provider_id?: true
    asqa_code?: true
  }

  export type ProviderSumAggregateInputType = {
    provider_id?: true
    asqa_code?: true
  }

  export type ProviderMinAggregateInputType = {
    provider_id?: true
    provider_name?: true
    site_name?: true
    government_subsidised?: true
    subsidy_tag?: true
    asqa_code?: true
    url?: true
    email?: true
  }

  export type ProviderMaxAggregateInputType = {
    provider_id?: true
    provider_name?: true
    site_name?: true
    government_subsidised?: true
    subsidy_tag?: true
    asqa_code?: true
    url?: true
    email?: true
  }

  export type ProviderCountAggregateInputType = {
    provider_id?: true
    provider_name?: true
    site_name?: true
    government_subsidised?: true
    subsidy_tag?: true
    asqa_code?: true
    url?: true
    email?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _avg?: ProviderAvgAggregateInputType
    _sum?: ProviderSumAggregateInputType
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag: string | null
    asqa_code: number
    url: string | null
    email: string | null
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    provider_name?: boolean
    site_name?: boolean
    government_subsidised?: boolean
    subsidy_tag?: boolean
    asqa_code?: boolean
    url?: boolean
    email?: boolean
    courses?: boolean | Provider$coursesArgs<ExtArgs>
    locations?: boolean | Provider$locationsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    provider_name?: boolean
    site_name?: boolean
    government_subsidised?: boolean
    subsidy_tag?: boolean
    asqa_code?: boolean
    url?: boolean
    email?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    provider_id?: boolean
    provider_name?: boolean
    site_name?: boolean
    government_subsidised?: boolean
    subsidy_tag?: boolean
    asqa_code?: boolean
    url?: boolean
    email?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    provider_id?: boolean
    provider_name?: boolean
    site_name?: boolean
    government_subsidised?: boolean
    subsidy_tag?: boolean
    asqa_code?: boolean
    url?: boolean
    email?: boolean
  }

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"provider_id" | "provider_name" | "site_name" | "government_subsidised" | "subsidy_tag" | "asqa_code" | "url" | "email", ExtArgs["result"]["provider"]>
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | Provider$coursesArgs<ExtArgs>
    locations?: boolean | Provider$locationsArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      courses: Prisma.$CoursePayload<ExtArgs>[]
      locations: Prisma.$LocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      provider_id: number
      provider_name: string
      site_name: string
      government_subsidised: string
      subsidy_tag: string | null
      asqa_code: number
      url: string | null
      email: string | null
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `provider_id`
     * const providerWithProvider_idOnly = await prisma.provider.findMany({ select: { provider_id: true } })
     * 
     */
    findMany<T extends ProviderFindManyArgs>(args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
     */
    create<T extends ProviderCreateArgs>(args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCreateManyArgs>(args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {ProviderCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `provider_id`
     * const providerWithProvider_idOnly = await prisma.provider.createManyAndReturn({
     *   select: { provider_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
     */
    delete<T extends ProviderDeleteArgs>(args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderUpdateArgs>(args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderDeleteManyArgs>(args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderUpdateManyArgs>(args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {ProviderUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `provider_id`
     * const providerWithProvider_idOnly = await prisma.provider.updateManyAndReturn({
     *   select: { provider_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends Provider$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locations<T extends Provider$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly provider_id: FieldRef<"Provider", 'Int'>
    readonly provider_name: FieldRef<"Provider", 'String'>
    readonly site_name: FieldRef<"Provider", 'String'>
    readonly government_subsidised: FieldRef<"Provider", 'String'>
    readonly subsidy_tag: FieldRef<"Provider", 'String'>
    readonly asqa_code: FieldRef<"Provider", 'Int'>
    readonly url: FieldRef<"Provider", 'String'>
    readonly email: FieldRef<"Provider", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider createManyAndReturn
   */
  export type ProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider updateManyAndReturn
   */
  export type ProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to delete.
     */
    limit?: number
  }

  /**
   * Provider.courses
   */
  export type Provider$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Provider.locations
   */
  export type Provider$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    geographic_id: number | null
    provider_id: number | null
    postcode: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    geographic_id: number | null
    provider_id: number | null
    postcode: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    geographic_id: number | null
    provider_id: number | null
    address_line_1: string | null
    suburb: string | null
    postcode: number | null
    latitude: number | null
    longitude: number | null
    full_address: string | null
    region_name: string | null
    local_government_authority: string | null
  }

  export type LocationMaxAggregateOutputType = {
    geographic_id: number | null
    provider_id: number | null
    address_line_1: string | null
    suburb: string | null
    postcode: number | null
    latitude: number | null
    longitude: number | null
    full_address: string | null
    region_name: string | null
    local_government_authority: string | null
  }

  export type LocationCountAggregateOutputType = {
    geographic_id: number
    provider_id: number
    address_line_1: number
    suburb: number
    postcode: number
    latitude: number
    longitude: number
    full_address: number
    region_name: number
    local_government_authority: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    geographic_id?: true
    provider_id?: true
    postcode?: true
    latitude?: true
    longitude?: true
  }

  export type LocationSumAggregateInputType = {
    geographic_id?: true
    provider_id?: true
    postcode?: true
    latitude?: true
    longitude?: true
  }

  export type LocationMinAggregateInputType = {
    geographic_id?: true
    provider_id?: true
    address_line_1?: true
    suburb?: true
    postcode?: true
    latitude?: true
    longitude?: true
    full_address?: true
    region_name?: true
    local_government_authority?: true
  }

  export type LocationMaxAggregateInputType = {
    geographic_id?: true
    provider_id?: true
    address_line_1?: true
    suburb?: true
    postcode?: true
    latitude?: true
    longitude?: true
    full_address?: true
    region_name?: true
    local_government_authority?: true
  }

  export type LocationCountAggregateInputType = {
    geographic_id?: true
    provider_id?: true
    address_line_1?: true
    suburb?: true
    postcode?: true
    latitude?: true
    longitude?: true
    full_address?: true
    region_name?: true
    local_government_authority?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    geographic_id: number
    provider_id: number
    address_line_1: string
    suburb: string
    postcode: number
    latitude: number
    longitude: number
    full_address: string
    region_name: string
    local_government_authority: string
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    geographic_id?: boolean
    provider_id?: boolean
    address_line_1?: boolean
    suburb?: boolean
    postcode?: boolean
    latitude?: boolean
    longitude?: boolean
    full_address?: boolean
    region_name?: boolean
    local_government_authority?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    geographic_id?: boolean
    provider_id?: boolean
    address_line_1?: boolean
    suburb?: boolean
    postcode?: boolean
    latitude?: boolean
    longitude?: boolean
    full_address?: boolean
    region_name?: boolean
    local_government_authority?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    geographic_id?: boolean
    provider_id?: boolean
    address_line_1?: boolean
    suburb?: boolean
    postcode?: boolean
    latitude?: boolean
    longitude?: boolean
    full_address?: boolean
    region_name?: boolean
    local_government_authority?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    geographic_id?: boolean
    provider_id?: boolean
    address_line_1?: boolean
    suburb?: boolean
    postcode?: boolean
    latitude?: boolean
    longitude?: boolean
    full_address?: boolean
    region_name?: boolean
    local_government_authority?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"geographic_id" | "provider_id" | "address_line_1" | "suburb" | "postcode" | "latitude" | "longitude" | "full_address" | "region_name" | "local_government_authority", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      geographic_id: number
      provider_id: number
      address_line_1: string
      suburb: string
      postcode: number
      latitude: number
      longitude: number
      full_address: string
      region_name: string
      local_government_authority: string
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `geographic_id`
     * const locationWithGeographic_idOnly = await prisma.location.findMany({ select: { geographic_id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `geographic_id`
     * const locationWithGeographic_idOnly = await prisma.location.createManyAndReturn({
     *   select: { geographic_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `geographic_id`
     * const locationWithGeographic_idOnly = await prisma.location.updateManyAndReturn({
     *   select: { geographic_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly geographic_id: FieldRef<"Location", 'Int'>
    readonly provider_id: FieldRef<"Location", 'Int'>
    readonly address_line_1: FieldRef<"Location", 'String'>
    readonly suburb: FieldRef<"Location", 'String'>
    readonly postcode: FieldRef<"Location", 'Int'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly full_address: FieldRef<"Location", 'String'>
    readonly region_name: FieldRef<"Location", 'String'>
    readonly local_government_authority: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    course_id: number | null
    provider_id: number | null
  }

  export type CourseSumAggregateOutputType = {
    course_id: number | null
    provider_id: number | null
  }

  export type CourseMinAggregateOutputType = {
    course_id: number | null
    provider_id: number | null
    course_title: string | null
    course_code: string | null
    qualification_level: string | null
    course_type: string | null
    government_subsidised: boolean | null
    apprenticeship: boolean | null
    traineeship: boolean | null
    entry_requirements: string | null
    description: string | null
    is_english_course: boolean | null
  }

  export type CourseMaxAggregateOutputType = {
    course_id: number | null
    provider_id: number | null
    course_title: string | null
    course_code: string | null
    qualification_level: string | null
    course_type: string | null
    government_subsidised: boolean | null
    apprenticeship: boolean | null
    traineeship: boolean | null
    entry_requirements: string | null
    description: string | null
    is_english_course: boolean | null
  }

  export type CourseCountAggregateOutputType = {
    course_id: number
    provider_id: number
    course_title: number
    course_code: number
    qualification_level: number
    course_type: number
    government_subsidised: number
    apprenticeship: number
    traineeship: number
    entry_requirements: number
    description: number
    is_english_course: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    course_id?: true
    provider_id?: true
  }

  export type CourseSumAggregateInputType = {
    course_id?: true
    provider_id?: true
  }

  export type CourseMinAggregateInputType = {
    course_id?: true
    provider_id?: true
    course_title?: true
    course_code?: true
    qualification_level?: true
    course_type?: true
    government_subsidised?: true
    apprenticeship?: true
    traineeship?: true
    entry_requirements?: true
    description?: true
    is_english_course?: true
  }

  export type CourseMaxAggregateInputType = {
    course_id?: true
    provider_id?: true
    course_title?: true
    course_code?: true
    qualification_level?: true
    course_type?: true
    government_subsidised?: true
    apprenticeship?: true
    traineeship?: true
    entry_requirements?: true
    description?: true
    is_english_course?: true
  }

  export type CourseCountAggregateInputType = {
    course_id?: true
    provider_id?: true
    course_title?: true
    course_code?: true
    qualification_level?: true
    course_type?: true
    government_subsidised?: true
    apprenticeship?: true
    traineeship?: true
    entry_requirements?: true
    description?: true
    is_english_course?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    course_id: number
    provider_id: number
    course_title: string
    course_code: string
    qualification_level: string
    course_type: string
    government_subsidised: boolean
    apprenticeship: boolean
    traineeship: boolean
    entry_requirements: string
    description: string
    is_english_course: boolean
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_id?: boolean
    provider_id?: boolean
    course_title?: boolean
    course_code?: boolean
    qualification_level?: boolean
    course_type?: boolean
    government_subsidised?: boolean
    apprenticeship?: boolean
    traineeship?: boolean
    entry_requirements?: boolean
    description?: boolean
    is_english_course?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_id?: boolean
    provider_id?: boolean
    course_title?: boolean
    course_code?: boolean
    qualification_level?: boolean
    course_type?: boolean
    government_subsidised?: boolean
    apprenticeship?: boolean
    traineeship?: boolean
    entry_requirements?: boolean
    description?: boolean
    is_english_course?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_id?: boolean
    provider_id?: boolean
    course_title?: boolean
    course_code?: boolean
    qualification_level?: boolean
    course_type?: boolean
    government_subsidised?: boolean
    apprenticeship?: boolean
    traineeship?: boolean
    entry_requirements?: boolean
    description?: boolean
    is_english_course?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    course_id?: boolean
    provider_id?: boolean
    course_title?: boolean
    course_code?: boolean
    qualification_level?: boolean
    course_type?: boolean
    government_subsidised?: boolean
    apprenticeship?: boolean
    traineeship?: boolean
    entry_requirements?: boolean
    description?: boolean
    is_english_course?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"course_id" | "provider_id" | "course_title" | "course_code" | "qualification_level" | "course_type" | "government_subsidised" | "apprenticeship" | "traineeship" | "entry_requirements" | "description" | "is_english_course", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      course_id: number
      provider_id: number
      course_title: string
      course_code: string
      qualification_level: string
      course_type: string
      government_subsidised: boolean
      apprenticeship: boolean
      traineeship: boolean
      entry_requirements: string
      description: string
      is_english_course: boolean
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `course_id`
     * const courseWithCourse_idOnly = await prisma.course.findMany({ select: { course_id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `course_id`
     * const courseWithCourse_idOnly = await prisma.course.createManyAndReturn({
     *   select: { course_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `course_id`
     * const courseWithCourse_idOnly = await prisma.course.updateManyAndReturn({
     *   select: { course_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly course_id: FieldRef<"Course", 'Int'>
    readonly provider_id: FieldRef<"Course", 'Int'>
    readonly course_title: FieldRef<"Course", 'String'>
    readonly course_code: FieldRef<"Course", 'String'>
    readonly qualification_level: FieldRef<"Course", 'String'>
    readonly course_type: FieldRef<"Course", 'String'>
    readonly government_subsidised: FieldRef<"Course", 'Boolean'>
    readonly apprenticeship: FieldRef<"Course", 'Boolean'>
    readonly traineeship: FieldRef<"Course", 'Boolean'>
    readonly entry_requirements: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly is_english_course: FieldRef<"Course", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Lga
   */

  export type AggregateLga = {
    _count: LgaCountAggregateOutputType | null
    _avg: LgaAvgAggregateOutputType | null
    _sum: LgaSumAggregateOutputType | null
    _min: LgaMinAggregateOutputType | null
    _max: LgaMaxAggregateOutputType | null
  }

  export type LgaAvgAggregateOutputType = {
    lga_code: number | null
  }

  export type LgaSumAggregateOutputType = {
    lga_code: number | null
  }

  export type LgaMinAggregateOutputType = {
    lga_code: number | null
    lga_name: string | null
  }

  export type LgaMaxAggregateOutputType = {
    lga_code: number | null
    lga_name: string | null
  }

  export type LgaCountAggregateOutputType = {
    lga_code: number
    lga_name: number
    _all: number
  }


  export type LgaAvgAggregateInputType = {
    lga_code?: true
  }

  export type LgaSumAggregateInputType = {
    lga_code?: true
  }

  export type LgaMinAggregateInputType = {
    lga_code?: true
    lga_name?: true
  }

  export type LgaMaxAggregateInputType = {
    lga_code?: true
    lga_name?: true
  }

  export type LgaCountAggregateInputType = {
    lga_code?: true
    lga_name?: true
    _all?: true
  }

  export type LgaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lga to aggregate.
     */
    where?: LgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lgas to fetch.
     */
    orderBy?: LgaOrderByWithRelationInput | LgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lgas
    **/
    _count?: true | LgaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LgaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LgaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LgaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LgaMaxAggregateInputType
  }

  export type GetLgaAggregateType<T extends LgaAggregateArgs> = {
        [P in keyof T & keyof AggregateLga]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLga[P]>
      : GetScalarType<T[P], AggregateLga[P]>
  }




  export type LgaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaWhereInput
    orderBy?: LgaOrderByWithAggregationInput | LgaOrderByWithAggregationInput[]
    by: LgaScalarFieldEnum[] | LgaScalarFieldEnum
    having?: LgaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LgaCountAggregateInputType | true
    _avg?: LgaAvgAggregateInputType
    _sum?: LgaSumAggregateInputType
    _min?: LgaMinAggregateInputType
    _max?: LgaMaxAggregateInputType
  }

  export type LgaGroupByOutputType = {
    lga_code: number
    lga_name: string
    _count: LgaCountAggregateOutputType | null
    _avg: LgaAvgAggregateOutputType | null
    _sum: LgaSumAggregateOutputType | null
    _min: LgaMinAggregateOutputType | null
    _max: LgaMaxAggregateOutputType | null
  }

  type GetLgaGroupByPayload<T extends LgaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LgaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LgaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LgaGroupByOutputType[P]>
            : GetScalarType<T[P], LgaGroupByOutputType[P]>
        }
      >
    >


  export type LgaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    lga_name?: boolean
    council_info?: boolean | Lga$council_infoArgs<ExtArgs>
    language_proficiencies?: boolean | Lga$language_proficienciesArgs<ExtArgs>
    lga_nationalities?: boolean | Lga$lga_nationalitiesArgs<ExtArgs>
    statistics?: boolean | Lga$statisticsArgs<ExtArgs>
    postcodes?: boolean | Lga$postcodesArgs<ExtArgs>
    _count?: boolean | LgaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lga"]>

  export type LgaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    lga_name?: boolean
  }, ExtArgs["result"]["lga"]>

  export type LgaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    lga_name?: boolean
  }, ExtArgs["result"]["lga"]>

  export type LgaSelectScalar = {
    lga_code?: boolean
    lga_name?: boolean
  }

  export type LgaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lga_code" | "lga_name", ExtArgs["result"]["lga"]>
  export type LgaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    council_info?: boolean | Lga$council_infoArgs<ExtArgs>
    language_proficiencies?: boolean | Lga$language_proficienciesArgs<ExtArgs>
    lga_nationalities?: boolean | Lga$lga_nationalitiesArgs<ExtArgs>
    statistics?: boolean | Lga$statisticsArgs<ExtArgs>
    postcodes?: boolean | Lga$postcodesArgs<ExtArgs>
    _count?: boolean | LgaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LgaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LgaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LgaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lga"
    objects: {
      council_info: Prisma.$CouncilInfoPayload<ExtArgs> | null
      language_proficiencies: Prisma.$LgaLanguageProficiencyPayload<ExtArgs>[]
      lga_nationalities: Prisma.$LgaNationalityPayload<ExtArgs>[]
      statistics: Prisma.$LgaStatisticsPayload<ExtArgs> | null
      postcodes: Prisma.$PostcodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      lga_code: number
      lga_name: string
    }, ExtArgs["result"]["lga"]>
    composites: {}
  }

  type LgaGetPayload<S extends boolean | null | undefined | LgaDefaultArgs> = $Result.GetResult<Prisma.$LgaPayload, S>

  type LgaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LgaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LgaCountAggregateInputType | true
    }

  export interface LgaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lga'], meta: { name: 'Lga' } }
    /**
     * Find zero or one Lga that matches the filter.
     * @param {LgaFindUniqueArgs} args - Arguments to find a Lga
     * @example
     * // Get one Lga
     * const lga = await prisma.lga.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LgaFindUniqueArgs>(args: SelectSubset<T, LgaFindUniqueArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lga that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LgaFindUniqueOrThrowArgs} args - Arguments to find a Lga
     * @example
     * // Get one Lga
     * const lga = await prisma.lga.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LgaFindUniqueOrThrowArgs>(args: SelectSubset<T, LgaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lga that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaFindFirstArgs} args - Arguments to find a Lga
     * @example
     * // Get one Lga
     * const lga = await prisma.lga.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LgaFindFirstArgs>(args?: SelectSubset<T, LgaFindFirstArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lga that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaFindFirstOrThrowArgs} args - Arguments to find a Lga
     * @example
     * // Get one Lga
     * const lga = await prisma.lga.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LgaFindFirstOrThrowArgs>(args?: SelectSubset<T, LgaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lgas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lgas
     * const lgas = await prisma.lga.findMany()
     * 
     * // Get first 10 Lgas
     * const lgas = await prisma.lga.findMany({ take: 10 })
     * 
     * // Only select the `lga_code`
     * const lgaWithLga_codeOnly = await prisma.lga.findMany({ select: { lga_code: true } })
     * 
     */
    findMany<T extends LgaFindManyArgs>(args?: SelectSubset<T, LgaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lga.
     * @param {LgaCreateArgs} args - Arguments to create a Lga.
     * @example
     * // Create one Lga
     * const Lga = await prisma.lga.create({
     *   data: {
     *     // ... data to create a Lga
     *   }
     * })
     * 
     */
    create<T extends LgaCreateArgs>(args: SelectSubset<T, LgaCreateArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lgas.
     * @param {LgaCreateManyArgs} args - Arguments to create many Lgas.
     * @example
     * // Create many Lgas
     * const lga = await prisma.lga.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LgaCreateManyArgs>(args?: SelectSubset<T, LgaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lgas and returns the data saved in the database.
     * @param {LgaCreateManyAndReturnArgs} args - Arguments to create many Lgas.
     * @example
     * // Create many Lgas
     * const lga = await prisma.lga.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lgas and only return the `lga_code`
     * const lgaWithLga_codeOnly = await prisma.lga.createManyAndReturn({
     *   select: { lga_code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LgaCreateManyAndReturnArgs>(args?: SelectSubset<T, LgaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lga.
     * @param {LgaDeleteArgs} args - Arguments to delete one Lga.
     * @example
     * // Delete one Lga
     * const Lga = await prisma.lga.delete({
     *   where: {
     *     // ... filter to delete one Lga
     *   }
     * })
     * 
     */
    delete<T extends LgaDeleteArgs>(args: SelectSubset<T, LgaDeleteArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lga.
     * @param {LgaUpdateArgs} args - Arguments to update one Lga.
     * @example
     * // Update one Lga
     * const lga = await prisma.lga.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LgaUpdateArgs>(args: SelectSubset<T, LgaUpdateArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lgas.
     * @param {LgaDeleteManyArgs} args - Arguments to filter Lgas to delete.
     * @example
     * // Delete a few Lgas
     * const { count } = await prisma.lga.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LgaDeleteManyArgs>(args?: SelectSubset<T, LgaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lgas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lgas
     * const lga = await prisma.lga.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LgaUpdateManyArgs>(args: SelectSubset<T, LgaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lgas and returns the data updated in the database.
     * @param {LgaUpdateManyAndReturnArgs} args - Arguments to update many Lgas.
     * @example
     * // Update many Lgas
     * const lga = await prisma.lga.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lgas and only return the `lga_code`
     * const lgaWithLga_codeOnly = await prisma.lga.updateManyAndReturn({
     *   select: { lga_code: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LgaUpdateManyAndReturnArgs>(args: SelectSubset<T, LgaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lga.
     * @param {LgaUpsertArgs} args - Arguments to update or create a Lga.
     * @example
     * // Update or create a Lga
     * const lga = await prisma.lga.upsert({
     *   create: {
     *     // ... data to create a Lga
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lga we want to update
     *   }
     * })
     */
    upsert<T extends LgaUpsertArgs>(args: SelectSubset<T, LgaUpsertArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lgas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaCountArgs} args - Arguments to filter Lgas to count.
     * @example
     * // Count the number of Lgas
     * const count = await prisma.lga.count({
     *   where: {
     *     // ... the filter for the Lgas we want to count
     *   }
     * })
    **/
    count<T extends LgaCountArgs>(
      args?: Subset<T, LgaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LgaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LgaAggregateArgs>(args: Subset<T, LgaAggregateArgs>): Prisma.PrismaPromise<GetLgaAggregateType<T>>

    /**
     * Group by Lga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LgaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LgaGroupByArgs['orderBy'] }
        : { orderBy?: LgaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LgaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLgaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lga model
   */
  readonly fields: LgaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lga.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LgaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    council_info<T extends Lga$council_infoArgs<ExtArgs> = {}>(args?: Subset<T, Lga$council_infoArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    language_proficiencies<T extends Lga$language_proficienciesArgs<ExtArgs> = {}>(args?: Subset<T, Lga$language_proficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lga_nationalities<T extends Lga$lga_nationalitiesArgs<ExtArgs> = {}>(args?: Subset<T, Lga$lga_nationalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statistics<T extends Lga$statisticsArgs<ExtArgs> = {}>(args?: Subset<T, Lga$statisticsArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    postcodes<T extends Lga$postcodesArgs<ExtArgs> = {}>(args?: Subset<T, Lga$postcodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lga model
   */
  interface LgaFieldRefs {
    readonly lga_code: FieldRef<"Lga", 'Int'>
    readonly lga_name: FieldRef<"Lga", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lga findUnique
   */
  export type LgaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * Filter, which Lga to fetch.
     */
    where: LgaWhereUniqueInput
  }

  /**
   * Lga findUniqueOrThrow
   */
  export type LgaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * Filter, which Lga to fetch.
     */
    where: LgaWhereUniqueInput
  }

  /**
   * Lga findFirst
   */
  export type LgaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * Filter, which Lga to fetch.
     */
    where?: LgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lgas to fetch.
     */
    orderBy?: LgaOrderByWithRelationInput | LgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lgas.
     */
    cursor?: LgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lgas.
     */
    distinct?: LgaScalarFieldEnum | LgaScalarFieldEnum[]
  }

  /**
   * Lga findFirstOrThrow
   */
  export type LgaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * Filter, which Lga to fetch.
     */
    where?: LgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lgas to fetch.
     */
    orderBy?: LgaOrderByWithRelationInput | LgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lgas.
     */
    cursor?: LgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lgas.
     */
    distinct?: LgaScalarFieldEnum | LgaScalarFieldEnum[]
  }

  /**
   * Lga findMany
   */
  export type LgaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * Filter, which Lgas to fetch.
     */
    where?: LgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lgas to fetch.
     */
    orderBy?: LgaOrderByWithRelationInput | LgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lgas.
     */
    cursor?: LgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lgas.
     */
    skip?: number
    distinct?: LgaScalarFieldEnum | LgaScalarFieldEnum[]
  }

  /**
   * Lga create
   */
  export type LgaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * The data needed to create a Lga.
     */
    data: XOR<LgaCreateInput, LgaUncheckedCreateInput>
  }

  /**
   * Lga createMany
   */
  export type LgaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lgas.
     */
    data: LgaCreateManyInput | LgaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lga createManyAndReturn
   */
  export type LgaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * The data used to create many Lgas.
     */
    data: LgaCreateManyInput | LgaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lga update
   */
  export type LgaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * The data needed to update a Lga.
     */
    data: XOR<LgaUpdateInput, LgaUncheckedUpdateInput>
    /**
     * Choose, which Lga to update.
     */
    where: LgaWhereUniqueInput
  }

  /**
   * Lga updateMany
   */
  export type LgaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lgas.
     */
    data: XOR<LgaUpdateManyMutationInput, LgaUncheckedUpdateManyInput>
    /**
     * Filter which Lgas to update
     */
    where?: LgaWhereInput
    /**
     * Limit how many Lgas to update.
     */
    limit?: number
  }

  /**
   * Lga updateManyAndReturn
   */
  export type LgaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * The data used to update Lgas.
     */
    data: XOR<LgaUpdateManyMutationInput, LgaUncheckedUpdateManyInput>
    /**
     * Filter which Lgas to update
     */
    where?: LgaWhereInput
    /**
     * Limit how many Lgas to update.
     */
    limit?: number
  }

  /**
   * Lga upsert
   */
  export type LgaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * The filter to search for the Lga to update in case it exists.
     */
    where: LgaWhereUniqueInput
    /**
     * In case the Lga found by the `where` argument doesn't exist, create a new Lga with this data.
     */
    create: XOR<LgaCreateInput, LgaUncheckedCreateInput>
    /**
     * In case the Lga was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LgaUpdateInput, LgaUncheckedUpdateInput>
  }

  /**
   * Lga delete
   */
  export type LgaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
    /**
     * Filter which Lga to delete.
     */
    where: LgaWhereUniqueInput
  }

  /**
   * Lga deleteMany
   */
  export type LgaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lgas to delete
     */
    where?: LgaWhereInput
    /**
     * Limit how many Lgas to delete.
     */
    limit?: number
  }

  /**
   * Lga.council_info
   */
  export type Lga$council_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    where?: CouncilInfoWhereInput
  }

  /**
   * Lga.language_proficiencies
   */
  export type Lga$language_proficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    where?: LgaLanguageProficiencyWhereInput
    orderBy?: LgaLanguageProficiencyOrderByWithRelationInput | LgaLanguageProficiencyOrderByWithRelationInput[]
    cursor?: LgaLanguageProficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LgaLanguageProficiencyScalarFieldEnum | LgaLanguageProficiencyScalarFieldEnum[]
  }

  /**
   * Lga.lga_nationalities
   */
  export type Lga$lga_nationalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    where?: LgaNationalityWhereInput
    orderBy?: LgaNationalityOrderByWithRelationInput | LgaNationalityOrderByWithRelationInput[]
    cursor?: LgaNationalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LgaNationalityScalarFieldEnum | LgaNationalityScalarFieldEnum[]
  }

  /**
   * Lga.statistics
   */
  export type Lga$statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    where?: LgaStatisticsWhereInput
  }

  /**
   * Lga.postcodes
   */
  export type Lga$postcodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    where?: PostcodeWhereInput
    orderBy?: PostcodeOrderByWithRelationInput | PostcodeOrderByWithRelationInput[]
    cursor?: PostcodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostcodeScalarFieldEnum | PostcodeScalarFieldEnum[]
  }

  /**
   * Lga without action
   */
  export type LgaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lga
     */
    select?: LgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lga
     */
    omit?: LgaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaInclude<ExtArgs> | null
  }


  /**
   * Model Nationality
   */

  export type AggregateNationality = {
    _count: NationalityCountAggregateOutputType | null
    _avg: NationalityAvgAggregateOutputType | null
    _sum: NationalitySumAggregateOutputType | null
    _min: NationalityMinAggregateOutputType | null
    _max: NationalityMaxAggregateOutputType | null
  }

  export type NationalityAvgAggregateOutputType = {
    nationality_id: number | null
  }

  export type NationalitySumAggregateOutputType = {
    nationality_id: number | null
  }

  export type NationalityMinAggregateOutputType = {
    nationality_id: number | null
    nationality: string | null
  }

  export type NationalityMaxAggregateOutputType = {
    nationality_id: number | null
    nationality: string | null
  }

  export type NationalityCountAggregateOutputType = {
    nationality_id: number
    nationality: number
    _all: number
  }


  export type NationalityAvgAggregateInputType = {
    nationality_id?: true
  }

  export type NationalitySumAggregateInputType = {
    nationality_id?: true
  }

  export type NationalityMinAggregateInputType = {
    nationality_id?: true
    nationality?: true
  }

  export type NationalityMaxAggregateInputType = {
    nationality_id?: true
    nationality?: true
  }

  export type NationalityCountAggregateInputType = {
    nationality_id?: true
    nationality?: true
    _all?: true
  }

  export type NationalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nationality to aggregate.
     */
    where?: NationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nationalities to fetch.
     */
    orderBy?: NationalityOrderByWithRelationInput | NationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nationalities
    **/
    _count?: true | NationalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NationalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NationalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NationalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NationalityMaxAggregateInputType
  }

  export type GetNationalityAggregateType<T extends NationalityAggregateArgs> = {
        [P in keyof T & keyof AggregateNationality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNationality[P]>
      : GetScalarType<T[P], AggregateNationality[P]>
  }




  export type NationalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NationalityWhereInput
    orderBy?: NationalityOrderByWithAggregationInput | NationalityOrderByWithAggregationInput[]
    by: NationalityScalarFieldEnum[] | NationalityScalarFieldEnum
    having?: NationalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NationalityCountAggregateInputType | true
    _avg?: NationalityAvgAggregateInputType
    _sum?: NationalitySumAggregateInputType
    _min?: NationalityMinAggregateInputType
    _max?: NationalityMaxAggregateInputType
  }

  export type NationalityGroupByOutputType = {
    nationality_id: number
    nationality: string
    _count: NationalityCountAggregateOutputType | null
    _avg: NationalityAvgAggregateOutputType | null
    _sum: NationalitySumAggregateOutputType | null
    _min: NationalityMinAggregateOutputType | null
    _max: NationalityMaxAggregateOutputType | null
  }

  type GetNationalityGroupByPayload<T extends NationalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NationalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NationalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NationalityGroupByOutputType[P]>
            : GetScalarType<T[P], NationalityGroupByOutputType[P]>
        }
      >
    >


  export type NationalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nationality_id?: boolean
    nationality?: boolean
    lga_nationalities?: boolean | Nationality$lga_nationalitiesArgs<ExtArgs>
    _count?: boolean | NationalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nationality"]>

  export type NationalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nationality_id?: boolean
    nationality?: boolean
  }, ExtArgs["result"]["nationality"]>

  export type NationalitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nationality_id?: boolean
    nationality?: boolean
  }, ExtArgs["result"]["nationality"]>

  export type NationalitySelectScalar = {
    nationality_id?: boolean
    nationality?: boolean
  }

  export type NationalityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nationality_id" | "nationality", ExtArgs["result"]["nationality"]>
  export type NationalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga_nationalities?: boolean | Nationality$lga_nationalitiesArgs<ExtArgs>
    _count?: boolean | NationalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NationalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NationalityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NationalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nationality"
    objects: {
      lga_nationalities: Prisma.$LgaNationalityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      nationality_id: number
      nationality: string
    }, ExtArgs["result"]["nationality"]>
    composites: {}
  }

  type NationalityGetPayload<S extends boolean | null | undefined | NationalityDefaultArgs> = $Result.GetResult<Prisma.$NationalityPayload, S>

  type NationalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NationalityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NationalityCountAggregateInputType | true
    }

  export interface NationalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nationality'], meta: { name: 'Nationality' } }
    /**
     * Find zero or one Nationality that matches the filter.
     * @param {NationalityFindUniqueArgs} args - Arguments to find a Nationality
     * @example
     * // Get one Nationality
     * const nationality = await prisma.nationality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NationalityFindUniqueArgs>(args: SelectSubset<T, NationalityFindUniqueArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nationality that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NationalityFindUniqueOrThrowArgs} args - Arguments to find a Nationality
     * @example
     * // Get one Nationality
     * const nationality = await prisma.nationality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NationalityFindUniqueOrThrowArgs>(args: SelectSubset<T, NationalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nationality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityFindFirstArgs} args - Arguments to find a Nationality
     * @example
     * // Get one Nationality
     * const nationality = await prisma.nationality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NationalityFindFirstArgs>(args?: SelectSubset<T, NationalityFindFirstArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nationality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityFindFirstOrThrowArgs} args - Arguments to find a Nationality
     * @example
     * // Get one Nationality
     * const nationality = await prisma.nationality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NationalityFindFirstOrThrowArgs>(args?: SelectSubset<T, NationalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nationalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nationalities
     * const nationalities = await prisma.nationality.findMany()
     * 
     * // Get first 10 Nationalities
     * const nationalities = await prisma.nationality.findMany({ take: 10 })
     * 
     * // Only select the `nationality_id`
     * const nationalityWithNationality_idOnly = await prisma.nationality.findMany({ select: { nationality_id: true } })
     * 
     */
    findMany<T extends NationalityFindManyArgs>(args?: SelectSubset<T, NationalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nationality.
     * @param {NationalityCreateArgs} args - Arguments to create a Nationality.
     * @example
     * // Create one Nationality
     * const Nationality = await prisma.nationality.create({
     *   data: {
     *     // ... data to create a Nationality
     *   }
     * })
     * 
     */
    create<T extends NationalityCreateArgs>(args: SelectSubset<T, NationalityCreateArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nationalities.
     * @param {NationalityCreateManyArgs} args - Arguments to create many Nationalities.
     * @example
     * // Create many Nationalities
     * const nationality = await prisma.nationality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NationalityCreateManyArgs>(args?: SelectSubset<T, NationalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nationalities and returns the data saved in the database.
     * @param {NationalityCreateManyAndReturnArgs} args - Arguments to create many Nationalities.
     * @example
     * // Create many Nationalities
     * const nationality = await prisma.nationality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nationalities and only return the `nationality_id`
     * const nationalityWithNationality_idOnly = await prisma.nationality.createManyAndReturn({
     *   select: { nationality_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NationalityCreateManyAndReturnArgs>(args?: SelectSubset<T, NationalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nationality.
     * @param {NationalityDeleteArgs} args - Arguments to delete one Nationality.
     * @example
     * // Delete one Nationality
     * const Nationality = await prisma.nationality.delete({
     *   where: {
     *     // ... filter to delete one Nationality
     *   }
     * })
     * 
     */
    delete<T extends NationalityDeleteArgs>(args: SelectSubset<T, NationalityDeleteArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nationality.
     * @param {NationalityUpdateArgs} args - Arguments to update one Nationality.
     * @example
     * // Update one Nationality
     * const nationality = await prisma.nationality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NationalityUpdateArgs>(args: SelectSubset<T, NationalityUpdateArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nationalities.
     * @param {NationalityDeleteManyArgs} args - Arguments to filter Nationalities to delete.
     * @example
     * // Delete a few Nationalities
     * const { count } = await prisma.nationality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NationalityDeleteManyArgs>(args?: SelectSubset<T, NationalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nationalities
     * const nationality = await prisma.nationality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NationalityUpdateManyArgs>(args: SelectSubset<T, NationalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nationalities and returns the data updated in the database.
     * @param {NationalityUpdateManyAndReturnArgs} args - Arguments to update many Nationalities.
     * @example
     * // Update many Nationalities
     * const nationality = await prisma.nationality.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nationalities and only return the `nationality_id`
     * const nationalityWithNationality_idOnly = await prisma.nationality.updateManyAndReturn({
     *   select: { nationality_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NationalityUpdateManyAndReturnArgs>(args: SelectSubset<T, NationalityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nationality.
     * @param {NationalityUpsertArgs} args - Arguments to update or create a Nationality.
     * @example
     * // Update or create a Nationality
     * const nationality = await prisma.nationality.upsert({
     *   create: {
     *     // ... data to create a Nationality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nationality we want to update
     *   }
     * })
     */
    upsert<T extends NationalityUpsertArgs>(args: SelectSubset<T, NationalityUpsertArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityCountArgs} args - Arguments to filter Nationalities to count.
     * @example
     * // Count the number of Nationalities
     * const count = await prisma.nationality.count({
     *   where: {
     *     // ... the filter for the Nationalities we want to count
     *   }
     * })
    **/
    count<T extends NationalityCountArgs>(
      args?: Subset<T, NationalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NationalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nationality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NationalityAggregateArgs>(args: Subset<T, NationalityAggregateArgs>): Prisma.PrismaPromise<GetNationalityAggregateType<T>>

    /**
     * Group by Nationality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NationalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NationalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NationalityGroupByArgs['orderBy'] }
        : { orderBy?: NationalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NationalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNationalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nationality model
   */
  readonly fields: NationalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nationality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NationalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lga_nationalities<T extends Nationality$lga_nationalitiesArgs<ExtArgs> = {}>(args?: Subset<T, Nationality$lga_nationalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nationality model
   */
  interface NationalityFieldRefs {
    readonly nationality_id: FieldRef<"Nationality", 'Int'>
    readonly nationality: FieldRef<"Nationality", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Nationality findUnique
   */
  export type NationalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * Filter, which Nationality to fetch.
     */
    where: NationalityWhereUniqueInput
  }

  /**
   * Nationality findUniqueOrThrow
   */
  export type NationalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * Filter, which Nationality to fetch.
     */
    where: NationalityWhereUniqueInput
  }

  /**
   * Nationality findFirst
   */
  export type NationalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * Filter, which Nationality to fetch.
     */
    where?: NationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nationalities to fetch.
     */
    orderBy?: NationalityOrderByWithRelationInput | NationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nationalities.
     */
    cursor?: NationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nationalities.
     */
    distinct?: NationalityScalarFieldEnum | NationalityScalarFieldEnum[]
  }

  /**
   * Nationality findFirstOrThrow
   */
  export type NationalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * Filter, which Nationality to fetch.
     */
    where?: NationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nationalities to fetch.
     */
    orderBy?: NationalityOrderByWithRelationInput | NationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nationalities.
     */
    cursor?: NationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nationalities.
     */
    distinct?: NationalityScalarFieldEnum | NationalityScalarFieldEnum[]
  }

  /**
   * Nationality findMany
   */
  export type NationalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * Filter, which Nationalities to fetch.
     */
    where?: NationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nationalities to fetch.
     */
    orderBy?: NationalityOrderByWithRelationInput | NationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nationalities.
     */
    cursor?: NationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nationalities.
     */
    skip?: number
    distinct?: NationalityScalarFieldEnum | NationalityScalarFieldEnum[]
  }

  /**
   * Nationality create
   */
  export type NationalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Nationality.
     */
    data: XOR<NationalityCreateInput, NationalityUncheckedCreateInput>
  }

  /**
   * Nationality createMany
   */
  export type NationalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nationalities.
     */
    data: NationalityCreateManyInput | NationalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nationality createManyAndReturn
   */
  export type NationalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * The data used to create many Nationalities.
     */
    data: NationalityCreateManyInput | NationalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nationality update
   */
  export type NationalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Nationality.
     */
    data: XOR<NationalityUpdateInput, NationalityUncheckedUpdateInput>
    /**
     * Choose, which Nationality to update.
     */
    where: NationalityWhereUniqueInput
  }

  /**
   * Nationality updateMany
   */
  export type NationalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nationalities.
     */
    data: XOR<NationalityUpdateManyMutationInput, NationalityUncheckedUpdateManyInput>
    /**
     * Filter which Nationalities to update
     */
    where?: NationalityWhereInput
    /**
     * Limit how many Nationalities to update.
     */
    limit?: number
  }

  /**
   * Nationality updateManyAndReturn
   */
  export type NationalityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * The data used to update Nationalities.
     */
    data: XOR<NationalityUpdateManyMutationInput, NationalityUncheckedUpdateManyInput>
    /**
     * Filter which Nationalities to update
     */
    where?: NationalityWhereInput
    /**
     * Limit how many Nationalities to update.
     */
    limit?: number
  }

  /**
   * Nationality upsert
   */
  export type NationalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Nationality to update in case it exists.
     */
    where: NationalityWhereUniqueInput
    /**
     * In case the Nationality found by the `where` argument doesn't exist, create a new Nationality with this data.
     */
    create: XOR<NationalityCreateInput, NationalityUncheckedCreateInput>
    /**
     * In case the Nationality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NationalityUpdateInput, NationalityUncheckedUpdateInput>
  }

  /**
   * Nationality delete
   */
  export type NationalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
    /**
     * Filter which Nationality to delete.
     */
    where: NationalityWhereUniqueInput
  }

  /**
   * Nationality deleteMany
   */
  export type NationalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nationalities to delete
     */
    where?: NationalityWhereInput
    /**
     * Limit how many Nationalities to delete.
     */
    limit?: number
  }

  /**
   * Nationality.lga_nationalities
   */
  export type Nationality$lga_nationalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    where?: LgaNationalityWhereInput
    orderBy?: LgaNationalityOrderByWithRelationInput | LgaNationalityOrderByWithRelationInput[]
    cursor?: LgaNationalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LgaNationalityScalarFieldEnum | LgaNationalityScalarFieldEnum[]
  }

  /**
   * Nationality without action
   */
  export type NationalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nationality
     */
    select?: NationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nationality
     */
    omit?: NationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NationalityInclude<ExtArgs> | null
  }


  /**
   * Model LgaNationality
   */

  export type AggregateLgaNationality = {
    _count: LgaNationalityCountAggregateOutputType | null
    _avg: LgaNationalityAvgAggregateOutputType | null
    _sum: LgaNationalitySumAggregateOutputType | null
    _min: LgaNationalityMinAggregateOutputType | null
    _max: LgaNationalityMaxAggregateOutputType | null
  }

  export type LgaNationalityAvgAggregateOutputType = {
    lga_nationality_id: number | null
    lga_code: number | null
    nationality_id: number | null
    count: number | null
  }

  export type LgaNationalitySumAggregateOutputType = {
    lga_nationality_id: number | null
    lga_code: number | null
    nationality_id: number | null
    count: number | null
  }

  export type LgaNationalityMinAggregateOutputType = {
    lga_nationality_id: number | null
    lga_code: number | null
    nationality_id: number | null
    count: number | null
  }

  export type LgaNationalityMaxAggregateOutputType = {
    lga_nationality_id: number | null
    lga_code: number | null
    nationality_id: number | null
    count: number | null
  }

  export type LgaNationalityCountAggregateOutputType = {
    lga_nationality_id: number
    lga_code: number
    nationality_id: number
    count: number
    _all: number
  }


  export type LgaNationalityAvgAggregateInputType = {
    lga_nationality_id?: true
    lga_code?: true
    nationality_id?: true
    count?: true
  }

  export type LgaNationalitySumAggregateInputType = {
    lga_nationality_id?: true
    lga_code?: true
    nationality_id?: true
    count?: true
  }

  export type LgaNationalityMinAggregateInputType = {
    lga_nationality_id?: true
    lga_code?: true
    nationality_id?: true
    count?: true
  }

  export type LgaNationalityMaxAggregateInputType = {
    lga_nationality_id?: true
    lga_code?: true
    nationality_id?: true
    count?: true
  }

  export type LgaNationalityCountAggregateInputType = {
    lga_nationality_id?: true
    lga_code?: true
    nationality_id?: true
    count?: true
    _all?: true
  }

  export type LgaNationalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LgaNationality to aggregate.
     */
    where?: LgaNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaNationalities to fetch.
     */
    orderBy?: LgaNationalityOrderByWithRelationInput | LgaNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LgaNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaNationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LgaNationalities
    **/
    _count?: true | LgaNationalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LgaNationalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LgaNationalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LgaNationalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LgaNationalityMaxAggregateInputType
  }

  export type GetLgaNationalityAggregateType<T extends LgaNationalityAggregateArgs> = {
        [P in keyof T & keyof AggregateLgaNationality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLgaNationality[P]>
      : GetScalarType<T[P], AggregateLgaNationality[P]>
  }




  export type LgaNationalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaNationalityWhereInput
    orderBy?: LgaNationalityOrderByWithAggregationInput | LgaNationalityOrderByWithAggregationInput[]
    by: LgaNationalityScalarFieldEnum[] | LgaNationalityScalarFieldEnum
    having?: LgaNationalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LgaNationalityCountAggregateInputType | true
    _avg?: LgaNationalityAvgAggregateInputType
    _sum?: LgaNationalitySumAggregateInputType
    _min?: LgaNationalityMinAggregateInputType
    _max?: LgaNationalityMaxAggregateInputType
  }

  export type LgaNationalityGroupByOutputType = {
    lga_nationality_id: number
    lga_code: number
    nationality_id: number
    count: number
    _count: LgaNationalityCountAggregateOutputType | null
    _avg: LgaNationalityAvgAggregateOutputType | null
    _sum: LgaNationalitySumAggregateOutputType | null
    _min: LgaNationalityMinAggregateOutputType | null
    _max: LgaNationalityMaxAggregateOutputType | null
  }

  type GetLgaNationalityGroupByPayload<T extends LgaNationalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LgaNationalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LgaNationalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LgaNationalityGroupByOutputType[P]>
            : GetScalarType<T[P], LgaNationalityGroupByOutputType[P]>
        }
      >
    >


  export type LgaNationalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_nationality_id?: boolean
    lga_code?: boolean
    nationality_id?: boolean
    count?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
    nationality?: boolean | NationalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaNationality"]>

  export type LgaNationalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_nationality_id?: boolean
    lga_code?: boolean
    nationality_id?: boolean
    count?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
    nationality?: boolean | NationalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaNationality"]>

  export type LgaNationalitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_nationality_id?: boolean
    lga_code?: boolean
    nationality_id?: boolean
    count?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
    nationality?: boolean | NationalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaNationality"]>

  export type LgaNationalitySelectScalar = {
    lga_nationality_id?: boolean
    lga_code?: boolean
    nationality_id?: boolean
    count?: boolean
  }

  export type LgaNationalityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lga_nationality_id" | "lga_code" | "nationality_id" | "count", ExtArgs["result"]["lgaNationality"]>
  export type LgaNationalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
    nationality?: boolean | NationalityDefaultArgs<ExtArgs>
  }
  export type LgaNationalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
    nationality?: boolean | NationalityDefaultArgs<ExtArgs>
  }
  export type LgaNationalityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
    nationality?: boolean | NationalityDefaultArgs<ExtArgs>
  }

  export type $LgaNationalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LgaNationality"
    objects: {
      lga: Prisma.$LgaPayload<ExtArgs>
      nationality: Prisma.$NationalityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      lga_nationality_id: number
      lga_code: number
      nationality_id: number
      count: number
    }, ExtArgs["result"]["lgaNationality"]>
    composites: {}
  }

  type LgaNationalityGetPayload<S extends boolean | null | undefined | LgaNationalityDefaultArgs> = $Result.GetResult<Prisma.$LgaNationalityPayload, S>

  type LgaNationalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LgaNationalityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LgaNationalityCountAggregateInputType | true
    }

  export interface LgaNationalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LgaNationality'], meta: { name: 'LgaNationality' } }
    /**
     * Find zero or one LgaNationality that matches the filter.
     * @param {LgaNationalityFindUniqueArgs} args - Arguments to find a LgaNationality
     * @example
     * // Get one LgaNationality
     * const lgaNationality = await prisma.lgaNationality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LgaNationalityFindUniqueArgs>(args: SelectSubset<T, LgaNationalityFindUniqueArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LgaNationality that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LgaNationalityFindUniqueOrThrowArgs} args - Arguments to find a LgaNationality
     * @example
     * // Get one LgaNationality
     * const lgaNationality = await prisma.lgaNationality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LgaNationalityFindUniqueOrThrowArgs>(args: SelectSubset<T, LgaNationalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LgaNationality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaNationalityFindFirstArgs} args - Arguments to find a LgaNationality
     * @example
     * // Get one LgaNationality
     * const lgaNationality = await prisma.lgaNationality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LgaNationalityFindFirstArgs>(args?: SelectSubset<T, LgaNationalityFindFirstArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LgaNationality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaNationalityFindFirstOrThrowArgs} args - Arguments to find a LgaNationality
     * @example
     * // Get one LgaNationality
     * const lgaNationality = await prisma.lgaNationality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LgaNationalityFindFirstOrThrowArgs>(args?: SelectSubset<T, LgaNationalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LgaNationalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaNationalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LgaNationalities
     * const lgaNationalities = await prisma.lgaNationality.findMany()
     * 
     * // Get first 10 LgaNationalities
     * const lgaNationalities = await prisma.lgaNationality.findMany({ take: 10 })
     * 
     * // Only select the `lga_nationality_id`
     * const lgaNationalityWithLga_nationality_idOnly = await prisma.lgaNationality.findMany({ select: { lga_nationality_id: true } })
     * 
     */
    findMany<T extends LgaNationalityFindManyArgs>(args?: SelectSubset<T, LgaNationalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LgaNationality.
     * @param {LgaNationalityCreateArgs} args - Arguments to create a LgaNationality.
     * @example
     * // Create one LgaNationality
     * const LgaNationality = await prisma.lgaNationality.create({
     *   data: {
     *     // ... data to create a LgaNationality
     *   }
     * })
     * 
     */
    create<T extends LgaNationalityCreateArgs>(args: SelectSubset<T, LgaNationalityCreateArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LgaNationalities.
     * @param {LgaNationalityCreateManyArgs} args - Arguments to create many LgaNationalities.
     * @example
     * // Create many LgaNationalities
     * const lgaNationality = await prisma.lgaNationality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LgaNationalityCreateManyArgs>(args?: SelectSubset<T, LgaNationalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LgaNationalities and returns the data saved in the database.
     * @param {LgaNationalityCreateManyAndReturnArgs} args - Arguments to create many LgaNationalities.
     * @example
     * // Create many LgaNationalities
     * const lgaNationality = await prisma.lgaNationality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LgaNationalities and only return the `lga_nationality_id`
     * const lgaNationalityWithLga_nationality_idOnly = await prisma.lgaNationality.createManyAndReturn({
     *   select: { lga_nationality_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LgaNationalityCreateManyAndReturnArgs>(args?: SelectSubset<T, LgaNationalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LgaNationality.
     * @param {LgaNationalityDeleteArgs} args - Arguments to delete one LgaNationality.
     * @example
     * // Delete one LgaNationality
     * const LgaNationality = await prisma.lgaNationality.delete({
     *   where: {
     *     // ... filter to delete one LgaNationality
     *   }
     * })
     * 
     */
    delete<T extends LgaNationalityDeleteArgs>(args: SelectSubset<T, LgaNationalityDeleteArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LgaNationality.
     * @param {LgaNationalityUpdateArgs} args - Arguments to update one LgaNationality.
     * @example
     * // Update one LgaNationality
     * const lgaNationality = await prisma.lgaNationality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LgaNationalityUpdateArgs>(args: SelectSubset<T, LgaNationalityUpdateArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LgaNationalities.
     * @param {LgaNationalityDeleteManyArgs} args - Arguments to filter LgaNationalities to delete.
     * @example
     * // Delete a few LgaNationalities
     * const { count } = await prisma.lgaNationality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LgaNationalityDeleteManyArgs>(args?: SelectSubset<T, LgaNationalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LgaNationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaNationalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LgaNationalities
     * const lgaNationality = await prisma.lgaNationality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LgaNationalityUpdateManyArgs>(args: SelectSubset<T, LgaNationalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LgaNationalities and returns the data updated in the database.
     * @param {LgaNationalityUpdateManyAndReturnArgs} args - Arguments to update many LgaNationalities.
     * @example
     * // Update many LgaNationalities
     * const lgaNationality = await prisma.lgaNationality.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LgaNationalities and only return the `lga_nationality_id`
     * const lgaNationalityWithLga_nationality_idOnly = await prisma.lgaNationality.updateManyAndReturn({
     *   select: { lga_nationality_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LgaNationalityUpdateManyAndReturnArgs>(args: SelectSubset<T, LgaNationalityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LgaNationality.
     * @param {LgaNationalityUpsertArgs} args - Arguments to update or create a LgaNationality.
     * @example
     * // Update or create a LgaNationality
     * const lgaNationality = await prisma.lgaNationality.upsert({
     *   create: {
     *     // ... data to create a LgaNationality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LgaNationality we want to update
     *   }
     * })
     */
    upsert<T extends LgaNationalityUpsertArgs>(args: SelectSubset<T, LgaNationalityUpsertArgs<ExtArgs>>): Prisma__LgaNationalityClient<$Result.GetResult<Prisma.$LgaNationalityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LgaNationalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaNationalityCountArgs} args - Arguments to filter LgaNationalities to count.
     * @example
     * // Count the number of LgaNationalities
     * const count = await prisma.lgaNationality.count({
     *   where: {
     *     // ... the filter for the LgaNationalities we want to count
     *   }
     * })
    **/
    count<T extends LgaNationalityCountArgs>(
      args?: Subset<T, LgaNationalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LgaNationalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LgaNationality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaNationalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LgaNationalityAggregateArgs>(args: Subset<T, LgaNationalityAggregateArgs>): Prisma.PrismaPromise<GetLgaNationalityAggregateType<T>>

    /**
     * Group by LgaNationality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaNationalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LgaNationalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LgaNationalityGroupByArgs['orderBy'] }
        : { orderBy?: LgaNationalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LgaNationalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLgaNationalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LgaNationality model
   */
  readonly fields: LgaNationalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LgaNationality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LgaNationalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lga<T extends LgaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LgaDefaultArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nationality<T extends NationalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NationalityDefaultArgs<ExtArgs>>): Prisma__NationalityClient<$Result.GetResult<Prisma.$NationalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LgaNationality model
   */
  interface LgaNationalityFieldRefs {
    readonly lga_nationality_id: FieldRef<"LgaNationality", 'Int'>
    readonly lga_code: FieldRef<"LgaNationality", 'Int'>
    readonly nationality_id: FieldRef<"LgaNationality", 'Int'>
    readonly count: FieldRef<"LgaNationality", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LgaNationality findUnique
   */
  export type LgaNationalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * Filter, which LgaNationality to fetch.
     */
    where: LgaNationalityWhereUniqueInput
  }

  /**
   * LgaNationality findUniqueOrThrow
   */
  export type LgaNationalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * Filter, which LgaNationality to fetch.
     */
    where: LgaNationalityWhereUniqueInput
  }

  /**
   * LgaNationality findFirst
   */
  export type LgaNationalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * Filter, which LgaNationality to fetch.
     */
    where?: LgaNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaNationalities to fetch.
     */
    orderBy?: LgaNationalityOrderByWithRelationInput | LgaNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LgaNationalities.
     */
    cursor?: LgaNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaNationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LgaNationalities.
     */
    distinct?: LgaNationalityScalarFieldEnum | LgaNationalityScalarFieldEnum[]
  }

  /**
   * LgaNationality findFirstOrThrow
   */
  export type LgaNationalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * Filter, which LgaNationality to fetch.
     */
    where?: LgaNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaNationalities to fetch.
     */
    orderBy?: LgaNationalityOrderByWithRelationInput | LgaNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LgaNationalities.
     */
    cursor?: LgaNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaNationalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LgaNationalities.
     */
    distinct?: LgaNationalityScalarFieldEnum | LgaNationalityScalarFieldEnum[]
  }

  /**
   * LgaNationality findMany
   */
  export type LgaNationalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * Filter, which LgaNationalities to fetch.
     */
    where?: LgaNationalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaNationalities to fetch.
     */
    orderBy?: LgaNationalityOrderByWithRelationInput | LgaNationalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LgaNationalities.
     */
    cursor?: LgaNationalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaNationalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaNationalities.
     */
    skip?: number
    distinct?: LgaNationalityScalarFieldEnum | LgaNationalityScalarFieldEnum[]
  }

  /**
   * LgaNationality create
   */
  export type LgaNationalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * The data needed to create a LgaNationality.
     */
    data: XOR<LgaNationalityCreateInput, LgaNationalityUncheckedCreateInput>
  }

  /**
   * LgaNationality createMany
   */
  export type LgaNationalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LgaNationalities.
     */
    data: LgaNationalityCreateManyInput | LgaNationalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LgaNationality createManyAndReturn
   */
  export type LgaNationalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * The data used to create many LgaNationalities.
     */
    data: LgaNationalityCreateManyInput | LgaNationalityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LgaNationality update
   */
  export type LgaNationalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * The data needed to update a LgaNationality.
     */
    data: XOR<LgaNationalityUpdateInput, LgaNationalityUncheckedUpdateInput>
    /**
     * Choose, which LgaNationality to update.
     */
    where: LgaNationalityWhereUniqueInput
  }

  /**
   * LgaNationality updateMany
   */
  export type LgaNationalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LgaNationalities.
     */
    data: XOR<LgaNationalityUpdateManyMutationInput, LgaNationalityUncheckedUpdateManyInput>
    /**
     * Filter which LgaNationalities to update
     */
    where?: LgaNationalityWhereInput
    /**
     * Limit how many LgaNationalities to update.
     */
    limit?: number
  }

  /**
   * LgaNationality updateManyAndReturn
   */
  export type LgaNationalityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * The data used to update LgaNationalities.
     */
    data: XOR<LgaNationalityUpdateManyMutationInput, LgaNationalityUncheckedUpdateManyInput>
    /**
     * Filter which LgaNationalities to update
     */
    where?: LgaNationalityWhereInput
    /**
     * Limit how many LgaNationalities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LgaNationality upsert
   */
  export type LgaNationalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * The filter to search for the LgaNationality to update in case it exists.
     */
    where: LgaNationalityWhereUniqueInput
    /**
     * In case the LgaNationality found by the `where` argument doesn't exist, create a new LgaNationality with this data.
     */
    create: XOR<LgaNationalityCreateInput, LgaNationalityUncheckedCreateInput>
    /**
     * In case the LgaNationality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LgaNationalityUpdateInput, LgaNationalityUncheckedUpdateInput>
  }

  /**
   * LgaNationality delete
   */
  export type LgaNationalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
    /**
     * Filter which LgaNationality to delete.
     */
    where: LgaNationalityWhereUniqueInput
  }

  /**
   * LgaNationality deleteMany
   */
  export type LgaNationalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LgaNationalities to delete
     */
    where?: LgaNationalityWhereInput
    /**
     * Limit how many LgaNationalities to delete.
     */
    limit?: number
  }

  /**
   * LgaNationality without action
   */
  export type LgaNationalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaNationality
     */
    select?: LgaNationalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaNationality
     */
    omit?: LgaNationalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaNationalityInclude<ExtArgs> | null
  }


  /**
   * Model CouncilInfo
   */

  export type AggregateCouncilInfo = {
    _count: CouncilInfoCountAggregateOutputType | null
    _avg: CouncilInfoAvgAggregateOutputType | null
    _sum: CouncilInfoSumAggregateOutputType | null
    _min: CouncilInfoMinAggregateOutputType | null
    _max: CouncilInfoMaxAggregateOutputType | null
  }

  export type CouncilInfoAvgAggregateOutputType = {
    lga_code: number | null
    postcode: number | null
  }

  export type CouncilInfoSumAggregateOutputType = {
    lga_code: number | null
    postcode: number | null
  }

  export type CouncilInfoMinAggregateOutputType = {
    lga_code: number | null
    council_name: string | null
    council_info: string | null
    address: string | null
    suburb: string | null
    postcode: number | null
    phone: string | null
    email: string | null
    website: string | null
  }

  export type CouncilInfoMaxAggregateOutputType = {
    lga_code: number | null
    council_name: string | null
    council_info: string | null
    address: string | null
    suburb: string | null
    postcode: number | null
    phone: string | null
    email: string | null
    website: string | null
  }

  export type CouncilInfoCountAggregateOutputType = {
    lga_code: number
    council_name: number
    council_info: number
    address: number
    suburb: number
    postcode: number
    phone: number
    email: number
    website: number
    _all: number
  }


  export type CouncilInfoAvgAggregateInputType = {
    lga_code?: true
    postcode?: true
  }

  export type CouncilInfoSumAggregateInputType = {
    lga_code?: true
    postcode?: true
  }

  export type CouncilInfoMinAggregateInputType = {
    lga_code?: true
    council_name?: true
    council_info?: true
    address?: true
    suburb?: true
    postcode?: true
    phone?: true
    email?: true
    website?: true
  }

  export type CouncilInfoMaxAggregateInputType = {
    lga_code?: true
    council_name?: true
    council_info?: true
    address?: true
    suburb?: true
    postcode?: true
    phone?: true
    email?: true
    website?: true
  }

  export type CouncilInfoCountAggregateInputType = {
    lga_code?: true
    council_name?: true
    council_info?: true
    address?: true
    suburb?: true
    postcode?: true
    phone?: true
    email?: true
    website?: true
    _all?: true
  }

  export type CouncilInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouncilInfo to aggregate.
     */
    where?: CouncilInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouncilInfos to fetch.
     */
    orderBy?: CouncilInfoOrderByWithRelationInput | CouncilInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouncilInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouncilInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouncilInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CouncilInfos
    **/
    _count?: true | CouncilInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouncilInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouncilInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouncilInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouncilInfoMaxAggregateInputType
  }

  export type GetCouncilInfoAggregateType<T extends CouncilInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateCouncilInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouncilInfo[P]>
      : GetScalarType<T[P], AggregateCouncilInfo[P]>
  }




  export type CouncilInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouncilInfoWhereInput
    orderBy?: CouncilInfoOrderByWithAggregationInput | CouncilInfoOrderByWithAggregationInput[]
    by: CouncilInfoScalarFieldEnum[] | CouncilInfoScalarFieldEnum
    having?: CouncilInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouncilInfoCountAggregateInputType | true
    _avg?: CouncilInfoAvgAggregateInputType
    _sum?: CouncilInfoSumAggregateInputType
    _min?: CouncilInfoMinAggregateInputType
    _max?: CouncilInfoMaxAggregateInputType
  }

  export type CouncilInfoGroupByOutputType = {
    lga_code: number
    council_name: string | null
    council_info: string | null
    address: string | null
    suburb: string | null
    postcode: number | null
    phone: string | null
    email: string | null
    website: string | null
    _count: CouncilInfoCountAggregateOutputType | null
    _avg: CouncilInfoAvgAggregateOutputType | null
    _sum: CouncilInfoSumAggregateOutputType | null
    _min: CouncilInfoMinAggregateOutputType | null
    _max: CouncilInfoMaxAggregateOutputType | null
  }

  type GetCouncilInfoGroupByPayload<T extends CouncilInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouncilInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouncilInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouncilInfoGroupByOutputType[P]>
            : GetScalarType<T[P], CouncilInfoGroupByOutputType[P]>
        }
      >
    >


  export type CouncilInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    council_name?: boolean
    council_info?: boolean
    address?: boolean
    suburb?: boolean
    postcode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["councilInfo"]>

  export type CouncilInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    council_name?: boolean
    council_info?: boolean
    address?: boolean
    suburb?: boolean
    postcode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["councilInfo"]>

  export type CouncilInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    council_name?: boolean
    council_info?: boolean
    address?: boolean
    suburb?: boolean
    postcode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["councilInfo"]>

  export type CouncilInfoSelectScalar = {
    lga_code?: boolean
    council_name?: boolean
    council_info?: boolean
    address?: boolean
    suburb?: boolean
    postcode?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
  }

  export type CouncilInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lga_code" | "council_name" | "council_info" | "address" | "suburb" | "postcode" | "phone" | "email" | "website", ExtArgs["result"]["councilInfo"]>
  export type CouncilInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type CouncilInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type CouncilInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }

  export type $CouncilInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CouncilInfo"
    objects: {
      lga: Prisma.$LgaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      lga_code: number
      council_name: string | null
      council_info: string | null
      address: string | null
      suburb: string | null
      postcode: number | null
      phone: string | null
      email: string | null
      website: string | null
    }, ExtArgs["result"]["councilInfo"]>
    composites: {}
  }

  type CouncilInfoGetPayload<S extends boolean | null | undefined | CouncilInfoDefaultArgs> = $Result.GetResult<Prisma.$CouncilInfoPayload, S>

  type CouncilInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouncilInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouncilInfoCountAggregateInputType | true
    }

  export interface CouncilInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CouncilInfo'], meta: { name: 'CouncilInfo' } }
    /**
     * Find zero or one CouncilInfo that matches the filter.
     * @param {CouncilInfoFindUniqueArgs} args - Arguments to find a CouncilInfo
     * @example
     * // Get one CouncilInfo
     * const councilInfo = await prisma.councilInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouncilInfoFindUniqueArgs>(args: SelectSubset<T, CouncilInfoFindUniqueArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CouncilInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouncilInfoFindUniqueOrThrowArgs} args - Arguments to find a CouncilInfo
     * @example
     * // Get one CouncilInfo
     * const councilInfo = await prisma.councilInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouncilInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, CouncilInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CouncilInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouncilInfoFindFirstArgs} args - Arguments to find a CouncilInfo
     * @example
     * // Get one CouncilInfo
     * const councilInfo = await prisma.councilInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouncilInfoFindFirstArgs>(args?: SelectSubset<T, CouncilInfoFindFirstArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CouncilInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouncilInfoFindFirstOrThrowArgs} args - Arguments to find a CouncilInfo
     * @example
     * // Get one CouncilInfo
     * const councilInfo = await prisma.councilInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouncilInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, CouncilInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CouncilInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouncilInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CouncilInfos
     * const councilInfos = await prisma.councilInfo.findMany()
     * 
     * // Get first 10 CouncilInfos
     * const councilInfos = await prisma.councilInfo.findMany({ take: 10 })
     * 
     * // Only select the `lga_code`
     * const councilInfoWithLga_codeOnly = await prisma.councilInfo.findMany({ select: { lga_code: true } })
     * 
     */
    findMany<T extends CouncilInfoFindManyArgs>(args?: SelectSubset<T, CouncilInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CouncilInfo.
     * @param {CouncilInfoCreateArgs} args - Arguments to create a CouncilInfo.
     * @example
     * // Create one CouncilInfo
     * const CouncilInfo = await prisma.councilInfo.create({
     *   data: {
     *     // ... data to create a CouncilInfo
     *   }
     * })
     * 
     */
    create<T extends CouncilInfoCreateArgs>(args: SelectSubset<T, CouncilInfoCreateArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CouncilInfos.
     * @param {CouncilInfoCreateManyArgs} args - Arguments to create many CouncilInfos.
     * @example
     * // Create many CouncilInfos
     * const councilInfo = await prisma.councilInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouncilInfoCreateManyArgs>(args?: SelectSubset<T, CouncilInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CouncilInfos and returns the data saved in the database.
     * @param {CouncilInfoCreateManyAndReturnArgs} args - Arguments to create many CouncilInfos.
     * @example
     * // Create many CouncilInfos
     * const councilInfo = await prisma.councilInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CouncilInfos and only return the `lga_code`
     * const councilInfoWithLga_codeOnly = await prisma.councilInfo.createManyAndReturn({
     *   select: { lga_code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouncilInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, CouncilInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CouncilInfo.
     * @param {CouncilInfoDeleteArgs} args - Arguments to delete one CouncilInfo.
     * @example
     * // Delete one CouncilInfo
     * const CouncilInfo = await prisma.councilInfo.delete({
     *   where: {
     *     // ... filter to delete one CouncilInfo
     *   }
     * })
     * 
     */
    delete<T extends CouncilInfoDeleteArgs>(args: SelectSubset<T, CouncilInfoDeleteArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CouncilInfo.
     * @param {CouncilInfoUpdateArgs} args - Arguments to update one CouncilInfo.
     * @example
     * // Update one CouncilInfo
     * const councilInfo = await prisma.councilInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouncilInfoUpdateArgs>(args: SelectSubset<T, CouncilInfoUpdateArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CouncilInfos.
     * @param {CouncilInfoDeleteManyArgs} args - Arguments to filter CouncilInfos to delete.
     * @example
     * // Delete a few CouncilInfos
     * const { count } = await prisma.councilInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouncilInfoDeleteManyArgs>(args?: SelectSubset<T, CouncilInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CouncilInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouncilInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CouncilInfos
     * const councilInfo = await prisma.councilInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouncilInfoUpdateManyArgs>(args: SelectSubset<T, CouncilInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CouncilInfos and returns the data updated in the database.
     * @param {CouncilInfoUpdateManyAndReturnArgs} args - Arguments to update many CouncilInfos.
     * @example
     * // Update many CouncilInfos
     * const councilInfo = await prisma.councilInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CouncilInfos and only return the `lga_code`
     * const councilInfoWithLga_codeOnly = await prisma.councilInfo.updateManyAndReturn({
     *   select: { lga_code: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouncilInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, CouncilInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CouncilInfo.
     * @param {CouncilInfoUpsertArgs} args - Arguments to update or create a CouncilInfo.
     * @example
     * // Update or create a CouncilInfo
     * const councilInfo = await prisma.councilInfo.upsert({
     *   create: {
     *     // ... data to create a CouncilInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CouncilInfo we want to update
     *   }
     * })
     */
    upsert<T extends CouncilInfoUpsertArgs>(args: SelectSubset<T, CouncilInfoUpsertArgs<ExtArgs>>): Prisma__CouncilInfoClient<$Result.GetResult<Prisma.$CouncilInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CouncilInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouncilInfoCountArgs} args - Arguments to filter CouncilInfos to count.
     * @example
     * // Count the number of CouncilInfos
     * const count = await prisma.councilInfo.count({
     *   where: {
     *     // ... the filter for the CouncilInfos we want to count
     *   }
     * })
    **/
    count<T extends CouncilInfoCountArgs>(
      args?: Subset<T, CouncilInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouncilInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CouncilInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouncilInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouncilInfoAggregateArgs>(args: Subset<T, CouncilInfoAggregateArgs>): Prisma.PrismaPromise<GetCouncilInfoAggregateType<T>>

    /**
     * Group by CouncilInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouncilInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouncilInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouncilInfoGroupByArgs['orderBy'] }
        : { orderBy?: CouncilInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouncilInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouncilInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CouncilInfo model
   */
  readonly fields: CouncilInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CouncilInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouncilInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lga<T extends LgaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LgaDefaultArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CouncilInfo model
   */
  interface CouncilInfoFieldRefs {
    readonly lga_code: FieldRef<"CouncilInfo", 'Int'>
    readonly council_name: FieldRef<"CouncilInfo", 'String'>
    readonly council_info: FieldRef<"CouncilInfo", 'String'>
    readonly address: FieldRef<"CouncilInfo", 'String'>
    readonly suburb: FieldRef<"CouncilInfo", 'String'>
    readonly postcode: FieldRef<"CouncilInfo", 'Int'>
    readonly phone: FieldRef<"CouncilInfo", 'String'>
    readonly email: FieldRef<"CouncilInfo", 'String'>
    readonly website: FieldRef<"CouncilInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CouncilInfo findUnique
   */
  export type CouncilInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * Filter, which CouncilInfo to fetch.
     */
    where: CouncilInfoWhereUniqueInput
  }

  /**
   * CouncilInfo findUniqueOrThrow
   */
  export type CouncilInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * Filter, which CouncilInfo to fetch.
     */
    where: CouncilInfoWhereUniqueInput
  }

  /**
   * CouncilInfo findFirst
   */
  export type CouncilInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * Filter, which CouncilInfo to fetch.
     */
    where?: CouncilInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouncilInfos to fetch.
     */
    orderBy?: CouncilInfoOrderByWithRelationInput | CouncilInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouncilInfos.
     */
    cursor?: CouncilInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouncilInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouncilInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouncilInfos.
     */
    distinct?: CouncilInfoScalarFieldEnum | CouncilInfoScalarFieldEnum[]
  }

  /**
   * CouncilInfo findFirstOrThrow
   */
  export type CouncilInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * Filter, which CouncilInfo to fetch.
     */
    where?: CouncilInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouncilInfos to fetch.
     */
    orderBy?: CouncilInfoOrderByWithRelationInput | CouncilInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouncilInfos.
     */
    cursor?: CouncilInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouncilInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouncilInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouncilInfos.
     */
    distinct?: CouncilInfoScalarFieldEnum | CouncilInfoScalarFieldEnum[]
  }

  /**
   * CouncilInfo findMany
   */
  export type CouncilInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * Filter, which CouncilInfos to fetch.
     */
    where?: CouncilInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouncilInfos to fetch.
     */
    orderBy?: CouncilInfoOrderByWithRelationInput | CouncilInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CouncilInfos.
     */
    cursor?: CouncilInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouncilInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouncilInfos.
     */
    skip?: number
    distinct?: CouncilInfoScalarFieldEnum | CouncilInfoScalarFieldEnum[]
  }

  /**
   * CouncilInfo create
   */
  export type CouncilInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a CouncilInfo.
     */
    data: XOR<CouncilInfoCreateInput, CouncilInfoUncheckedCreateInput>
  }

  /**
   * CouncilInfo createMany
   */
  export type CouncilInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CouncilInfos.
     */
    data: CouncilInfoCreateManyInput | CouncilInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CouncilInfo createManyAndReturn
   */
  export type CouncilInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * The data used to create many CouncilInfos.
     */
    data: CouncilInfoCreateManyInput | CouncilInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CouncilInfo update
   */
  export type CouncilInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a CouncilInfo.
     */
    data: XOR<CouncilInfoUpdateInput, CouncilInfoUncheckedUpdateInput>
    /**
     * Choose, which CouncilInfo to update.
     */
    where: CouncilInfoWhereUniqueInput
  }

  /**
   * CouncilInfo updateMany
   */
  export type CouncilInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CouncilInfos.
     */
    data: XOR<CouncilInfoUpdateManyMutationInput, CouncilInfoUncheckedUpdateManyInput>
    /**
     * Filter which CouncilInfos to update
     */
    where?: CouncilInfoWhereInput
    /**
     * Limit how many CouncilInfos to update.
     */
    limit?: number
  }

  /**
   * CouncilInfo updateManyAndReturn
   */
  export type CouncilInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * The data used to update CouncilInfos.
     */
    data: XOR<CouncilInfoUpdateManyMutationInput, CouncilInfoUncheckedUpdateManyInput>
    /**
     * Filter which CouncilInfos to update
     */
    where?: CouncilInfoWhereInput
    /**
     * Limit how many CouncilInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CouncilInfo upsert
   */
  export type CouncilInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the CouncilInfo to update in case it exists.
     */
    where: CouncilInfoWhereUniqueInput
    /**
     * In case the CouncilInfo found by the `where` argument doesn't exist, create a new CouncilInfo with this data.
     */
    create: XOR<CouncilInfoCreateInput, CouncilInfoUncheckedCreateInput>
    /**
     * In case the CouncilInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouncilInfoUpdateInput, CouncilInfoUncheckedUpdateInput>
  }

  /**
   * CouncilInfo delete
   */
  export type CouncilInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
    /**
     * Filter which CouncilInfo to delete.
     */
    where: CouncilInfoWhereUniqueInput
  }

  /**
   * CouncilInfo deleteMany
   */
  export type CouncilInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouncilInfos to delete
     */
    where?: CouncilInfoWhereInput
    /**
     * Limit how many CouncilInfos to delete.
     */
    limit?: number
  }

  /**
   * CouncilInfo without action
   */
  export type CouncilInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouncilInfo
     */
    select?: CouncilInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouncilInfo
     */
    omit?: CouncilInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouncilInfoInclude<ExtArgs> | null
  }


  /**
   * Model Postcode
   */

  export type AggregatePostcode = {
    _count: PostcodeCountAggregateOutputType | null
    _avg: PostcodeAvgAggregateOutputType | null
    _sum: PostcodeSumAggregateOutputType | null
    _min: PostcodeMinAggregateOutputType | null
    _max: PostcodeMaxAggregateOutputType | null
  }

  export type PostcodeAvgAggregateOutputType = {
    postcode: number | null
    latitude: number | null
    longitude: number | null
    lga_code: number | null
  }

  export type PostcodeSumAggregateOutputType = {
    postcode: number | null
    latitude: number | null
    longitude: number | null
    lga_code: number | null
  }

  export type PostcodeMinAggregateOutputType = {
    postcode: number | null
    suburb: string | null
    latitude: number | null
    longitude: number | null
    lga_code: number | null
  }

  export type PostcodeMaxAggregateOutputType = {
    postcode: number | null
    suburb: string | null
    latitude: number | null
    longitude: number | null
    lga_code: number | null
  }

  export type PostcodeCountAggregateOutputType = {
    postcode: number
    suburb: number
    latitude: number
    longitude: number
    lga_code: number
    _all: number
  }


  export type PostcodeAvgAggregateInputType = {
    postcode?: true
    latitude?: true
    longitude?: true
    lga_code?: true
  }

  export type PostcodeSumAggregateInputType = {
    postcode?: true
    latitude?: true
    longitude?: true
    lga_code?: true
  }

  export type PostcodeMinAggregateInputType = {
    postcode?: true
    suburb?: true
    latitude?: true
    longitude?: true
    lga_code?: true
  }

  export type PostcodeMaxAggregateInputType = {
    postcode?: true
    suburb?: true
    latitude?: true
    longitude?: true
    lga_code?: true
  }

  export type PostcodeCountAggregateInputType = {
    postcode?: true
    suburb?: true
    latitude?: true
    longitude?: true
    lga_code?: true
    _all?: true
  }

  export type PostcodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Postcode to aggregate.
     */
    where?: PostcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Postcodes to fetch.
     */
    orderBy?: PostcodeOrderByWithRelationInput | PostcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Postcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Postcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Postcodes
    **/
    _count?: true | PostcodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostcodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostcodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostcodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostcodeMaxAggregateInputType
  }

  export type GetPostcodeAggregateType<T extends PostcodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePostcode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostcode[P]>
      : GetScalarType<T[P], AggregatePostcode[P]>
  }




  export type PostcodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostcodeWhereInput
    orderBy?: PostcodeOrderByWithAggregationInput | PostcodeOrderByWithAggregationInput[]
    by: PostcodeScalarFieldEnum[] | PostcodeScalarFieldEnum
    having?: PostcodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostcodeCountAggregateInputType | true
    _avg?: PostcodeAvgAggregateInputType
    _sum?: PostcodeSumAggregateInputType
    _min?: PostcodeMinAggregateInputType
    _max?: PostcodeMaxAggregateInputType
  }

  export type PostcodeGroupByOutputType = {
    postcode: number
    suburb: string
    latitude: number
    longitude: number
    lga_code: number
    _count: PostcodeCountAggregateOutputType | null
    _avg: PostcodeAvgAggregateOutputType | null
    _sum: PostcodeSumAggregateOutputType | null
    _min: PostcodeMinAggregateOutputType | null
    _max: PostcodeMaxAggregateOutputType | null
  }

  type GetPostcodeGroupByPayload<T extends PostcodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostcodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostcodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostcodeGroupByOutputType[P]>
            : GetScalarType<T[P], PostcodeGroupByOutputType[P]>
        }
      >
    >


  export type PostcodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postcode?: boolean
    suburb?: boolean
    latitude?: boolean
    longitude?: boolean
    lga_code?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postcode"]>

  export type PostcodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postcode?: boolean
    suburb?: boolean
    latitude?: boolean
    longitude?: boolean
    lga_code?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postcode"]>

  export type PostcodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postcode?: boolean
    suburb?: boolean
    latitude?: boolean
    longitude?: boolean
    lga_code?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postcode"]>

  export type PostcodeSelectScalar = {
    postcode?: boolean
    suburb?: boolean
    latitude?: boolean
    longitude?: boolean
    lga_code?: boolean
  }

  export type PostcodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postcode" | "suburb" | "latitude" | "longitude" | "lga_code", ExtArgs["result"]["postcode"]>
  export type PostcodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type PostcodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type PostcodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }

  export type $PostcodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Postcode"
    objects: {
      lga: Prisma.$LgaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postcode: number
      suburb: string
      latitude: number
      longitude: number
      lga_code: number
    }, ExtArgs["result"]["postcode"]>
    composites: {}
  }

  type PostcodeGetPayload<S extends boolean | null | undefined | PostcodeDefaultArgs> = $Result.GetResult<Prisma.$PostcodePayload, S>

  type PostcodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostcodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostcodeCountAggregateInputType | true
    }

  export interface PostcodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Postcode'], meta: { name: 'Postcode' } }
    /**
     * Find zero or one Postcode that matches the filter.
     * @param {PostcodeFindUniqueArgs} args - Arguments to find a Postcode
     * @example
     * // Get one Postcode
     * const postcode = await prisma.postcode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostcodeFindUniqueArgs>(args: SelectSubset<T, PostcodeFindUniqueArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Postcode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostcodeFindUniqueOrThrowArgs} args - Arguments to find a Postcode
     * @example
     * // Get one Postcode
     * const postcode = await prisma.postcode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostcodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PostcodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Postcode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostcodeFindFirstArgs} args - Arguments to find a Postcode
     * @example
     * // Get one Postcode
     * const postcode = await prisma.postcode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostcodeFindFirstArgs>(args?: SelectSubset<T, PostcodeFindFirstArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Postcode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostcodeFindFirstOrThrowArgs} args - Arguments to find a Postcode
     * @example
     * // Get one Postcode
     * const postcode = await prisma.postcode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostcodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PostcodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Postcodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostcodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Postcodes
     * const postcodes = await prisma.postcode.findMany()
     * 
     * // Get first 10 Postcodes
     * const postcodes = await prisma.postcode.findMany({ take: 10 })
     * 
     * // Only select the `postcode`
     * const postcodeWithPostcodeOnly = await prisma.postcode.findMany({ select: { postcode: true } })
     * 
     */
    findMany<T extends PostcodeFindManyArgs>(args?: SelectSubset<T, PostcodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Postcode.
     * @param {PostcodeCreateArgs} args - Arguments to create a Postcode.
     * @example
     * // Create one Postcode
     * const Postcode = await prisma.postcode.create({
     *   data: {
     *     // ... data to create a Postcode
     *   }
     * })
     * 
     */
    create<T extends PostcodeCreateArgs>(args: SelectSubset<T, PostcodeCreateArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Postcodes.
     * @param {PostcodeCreateManyArgs} args - Arguments to create many Postcodes.
     * @example
     * // Create many Postcodes
     * const postcode = await prisma.postcode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostcodeCreateManyArgs>(args?: SelectSubset<T, PostcodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Postcodes and returns the data saved in the database.
     * @param {PostcodeCreateManyAndReturnArgs} args - Arguments to create many Postcodes.
     * @example
     * // Create many Postcodes
     * const postcode = await prisma.postcode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Postcodes and only return the `postcode`
     * const postcodeWithPostcodeOnly = await prisma.postcode.createManyAndReturn({
     *   select: { postcode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostcodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PostcodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Postcode.
     * @param {PostcodeDeleteArgs} args - Arguments to delete one Postcode.
     * @example
     * // Delete one Postcode
     * const Postcode = await prisma.postcode.delete({
     *   where: {
     *     // ... filter to delete one Postcode
     *   }
     * })
     * 
     */
    delete<T extends PostcodeDeleteArgs>(args: SelectSubset<T, PostcodeDeleteArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Postcode.
     * @param {PostcodeUpdateArgs} args - Arguments to update one Postcode.
     * @example
     * // Update one Postcode
     * const postcode = await prisma.postcode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostcodeUpdateArgs>(args: SelectSubset<T, PostcodeUpdateArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Postcodes.
     * @param {PostcodeDeleteManyArgs} args - Arguments to filter Postcodes to delete.
     * @example
     * // Delete a few Postcodes
     * const { count } = await prisma.postcode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostcodeDeleteManyArgs>(args?: SelectSubset<T, PostcodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Postcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostcodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Postcodes
     * const postcode = await prisma.postcode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostcodeUpdateManyArgs>(args: SelectSubset<T, PostcodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Postcodes and returns the data updated in the database.
     * @param {PostcodeUpdateManyAndReturnArgs} args - Arguments to update many Postcodes.
     * @example
     * // Update many Postcodes
     * const postcode = await prisma.postcode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Postcodes and only return the `postcode`
     * const postcodeWithPostcodeOnly = await prisma.postcode.updateManyAndReturn({
     *   select: { postcode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostcodeUpdateManyAndReturnArgs>(args: SelectSubset<T, PostcodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Postcode.
     * @param {PostcodeUpsertArgs} args - Arguments to update or create a Postcode.
     * @example
     * // Update or create a Postcode
     * const postcode = await prisma.postcode.upsert({
     *   create: {
     *     // ... data to create a Postcode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Postcode we want to update
     *   }
     * })
     */
    upsert<T extends PostcodeUpsertArgs>(args: SelectSubset<T, PostcodeUpsertArgs<ExtArgs>>): Prisma__PostcodeClient<$Result.GetResult<Prisma.$PostcodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Postcodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostcodeCountArgs} args - Arguments to filter Postcodes to count.
     * @example
     * // Count the number of Postcodes
     * const count = await prisma.postcode.count({
     *   where: {
     *     // ... the filter for the Postcodes we want to count
     *   }
     * })
    **/
    count<T extends PostcodeCountArgs>(
      args?: Subset<T, PostcodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostcodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Postcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostcodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostcodeAggregateArgs>(args: Subset<T, PostcodeAggregateArgs>): Prisma.PrismaPromise<GetPostcodeAggregateType<T>>

    /**
     * Group by Postcode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostcodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostcodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostcodeGroupByArgs['orderBy'] }
        : { orderBy?: PostcodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostcodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostcodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Postcode model
   */
  readonly fields: PostcodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Postcode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostcodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lga<T extends LgaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LgaDefaultArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Postcode model
   */
  interface PostcodeFieldRefs {
    readonly postcode: FieldRef<"Postcode", 'Int'>
    readonly suburb: FieldRef<"Postcode", 'String'>
    readonly latitude: FieldRef<"Postcode", 'Float'>
    readonly longitude: FieldRef<"Postcode", 'Float'>
    readonly lga_code: FieldRef<"Postcode", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Postcode findUnique
   */
  export type PostcodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * Filter, which Postcode to fetch.
     */
    where: PostcodeWhereUniqueInput
  }

  /**
   * Postcode findUniqueOrThrow
   */
  export type PostcodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * Filter, which Postcode to fetch.
     */
    where: PostcodeWhereUniqueInput
  }

  /**
   * Postcode findFirst
   */
  export type PostcodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * Filter, which Postcode to fetch.
     */
    where?: PostcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Postcodes to fetch.
     */
    orderBy?: PostcodeOrderByWithRelationInput | PostcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Postcodes.
     */
    cursor?: PostcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Postcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Postcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Postcodes.
     */
    distinct?: PostcodeScalarFieldEnum | PostcodeScalarFieldEnum[]
  }

  /**
   * Postcode findFirstOrThrow
   */
  export type PostcodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * Filter, which Postcode to fetch.
     */
    where?: PostcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Postcodes to fetch.
     */
    orderBy?: PostcodeOrderByWithRelationInput | PostcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Postcodes.
     */
    cursor?: PostcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Postcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Postcodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Postcodes.
     */
    distinct?: PostcodeScalarFieldEnum | PostcodeScalarFieldEnum[]
  }

  /**
   * Postcode findMany
   */
  export type PostcodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * Filter, which Postcodes to fetch.
     */
    where?: PostcodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Postcodes to fetch.
     */
    orderBy?: PostcodeOrderByWithRelationInput | PostcodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Postcodes.
     */
    cursor?: PostcodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Postcodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Postcodes.
     */
    skip?: number
    distinct?: PostcodeScalarFieldEnum | PostcodeScalarFieldEnum[]
  }

  /**
   * Postcode create
   */
  export type PostcodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * The data needed to create a Postcode.
     */
    data: XOR<PostcodeCreateInput, PostcodeUncheckedCreateInput>
  }

  /**
   * Postcode createMany
   */
  export type PostcodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Postcodes.
     */
    data: PostcodeCreateManyInput | PostcodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Postcode createManyAndReturn
   */
  export type PostcodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * The data used to create many Postcodes.
     */
    data: PostcodeCreateManyInput | PostcodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Postcode update
   */
  export type PostcodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * The data needed to update a Postcode.
     */
    data: XOR<PostcodeUpdateInput, PostcodeUncheckedUpdateInput>
    /**
     * Choose, which Postcode to update.
     */
    where: PostcodeWhereUniqueInput
  }

  /**
   * Postcode updateMany
   */
  export type PostcodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Postcodes.
     */
    data: XOR<PostcodeUpdateManyMutationInput, PostcodeUncheckedUpdateManyInput>
    /**
     * Filter which Postcodes to update
     */
    where?: PostcodeWhereInput
    /**
     * Limit how many Postcodes to update.
     */
    limit?: number
  }

  /**
   * Postcode updateManyAndReturn
   */
  export type PostcodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * The data used to update Postcodes.
     */
    data: XOR<PostcodeUpdateManyMutationInput, PostcodeUncheckedUpdateManyInput>
    /**
     * Filter which Postcodes to update
     */
    where?: PostcodeWhereInput
    /**
     * Limit how many Postcodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Postcode upsert
   */
  export type PostcodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * The filter to search for the Postcode to update in case it exists.
     */
    where: PostcodeWhereUniqueInput
    /**
     * In case the Postcode found by the `where` argument doesn't exist, create a new Postcode with this data.
     */
    create: XOR<PostcodeCreateInput, PostcodeUncheckedCreateInput>
    /**
     * In case the Postcode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostcodeUpdateInput, PostcodeUncheckedUpdateInput>
  }

  /**
   * Postcode delete
   */
  export type PostcodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
    /**
     * Filter which Postcode to delete.
     */
    where: PostcodeWhereUniqueInput
  }

  /**
   * Postcode deleteMany
   */
  export type PostcodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Postcodes to delete
     */
    where?: PostcodeWhereInput
    /**
     * Limit how many Postcodes to delete.
     */
    limit?: number
  }

  /**
   * Postcode without action
   */
  export type PostcodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Postcode
     */
    select?: PostcodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Postcode
     */
    omit?: PostcodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostcodeInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    language_id: number | null
  }

  export type LanguageSumAggregateOutputType = {
    language_id: number | null
  }

  export type LanguageMinAggregateOutputType = {
    language_id: number | null
    language: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    language_id: number | null
    language: string | null
  }

  export type LanguageCountAggregateOutputType = {
    language_id: number
    language: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    language_id?: true
  }

  export type LanguageSumAggregateInputType = {
    language_id?: true
  }

  export type LanguageMinAggregateInputType = {
    language_id?: true
    language?: true
  }

  export type LanguageMaxAggregateInputType = {
    language_id?: true
    language?: true
  }

  export type LanguageCountAggregateInputType = {
    language_id?: true
    language?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    language_id: number
    language: string | null
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    language_id?: boolean
    language?: boolean
    proficiencies?: boolean | Language$proficienciesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    language_id?: boolean
    language?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    language_id?: boolean
    language?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    language_id?: boolean
    language?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"language_id" | "language", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proficiencies?: boolean | Language$proficienciesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      proficiencies: Prisma.$LgaLanguageProficiencyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      language_id: number
      language: string | null
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `language_id`
     * const languageWithLanguage_idOnly = await prisma.language.findMany({ select: { language_id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `language_id`
     * const languageWithLanguage_idOnly = await prisma.language.createManyAndReturn({
     *   select: { language_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `language_id`
     * const languageWithLanguage_idOnly = await prisma.language.updateManyAndReturn({
     *   select: { language_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proficiencies<T extends Language$proficienciesArgs<ExtArgs> = {}>(args?: Subset<T, Language$proficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */
  interface LanguageFieldRefs {
    readonly language_id: FieldRef<"Language", 'Int'>
    readonly language: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data?: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.proficiencies
   */
  export type Language$proficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    where?: LgaLanguageProficiencyWhereInput
    orderBy?: LgaLanguageProficiencyOrderByWithRelationInput | LgaLanguageProficiencyOrderByWithRelationInput[]
    cursor?: LgaLanguageProficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LgaLanguageProficiencyScalarFieldEnum | LgaLanguageProficiencyScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model LgaLanguageProficiency
   */

  export type AggregateLgaLanguageProficiency = {
    _count: LgaLanguageProficiencyCountAggregateOutputType | null
    _avg: LgaLanguageProficiencyAvgAggregateOutputType | null
    _sum: LgaLanguageProficiencySumAggregateOutputType | null
    _min: LgaLanguageProficiencyMinAggregateOutputType | null
    _max: LgaLanguageProficiencyMaxAggregateOutputType | null
  }

  export type LgaLanguageProficiencyAvgAggregateOutputType = {
    lga_language_prof_id: number | null
    lga_code: number | null
    language_id: number | null
    count: number | null
  }

  export type LgaLanguageProficiencySumAggregateOutputType = {
    lga_language_prof_id: number | null
    lga_code: number | null
    language_id: number | null
    count: number | null
  }

  export type LgaLanguageProficiencyMinAggregateOutputType = {
    lga_language_prof_id: number | null
    lga_code: number | null
    language_id: number | null
    english_profiency_level: string | null
    count: number | null
  }

  export type LgaLanguageProficiencyMaxAggregateOutputType = {
    lga_language_prof_id: number | null
    lga_code: number | null
    language_id: number | null
    english_profiency_level: string | null
    count: number | null
  }

  export type LgaLanguageProficiencyCountAggregateOutputType = {
    lga_language_prof_id: number
    lga_code: number
    language_id: number
    english_profiency_level: number
    count: number
    _all: number
  }


  export type LgaLanguageProficiencyAvgAggregateInputType = {
    lga_language_prof_id?: true
    lga_code?: true
    language_id?: true
    count?: true
  }

  export type LgaLanguageProficiencySumAggregateInputType = {
    lga_language_prof_id?: true
    lga_code?: true
    language_id?: true
    count?: true
  }

  export type LgaLanguageProficiencyMinAggregateInputType = {
    lga_language_prof_id?: true
    lga_code?: true
    language_id?: true
    english_profiency_level?: true
    count?: true
  }

  export type LgaLanguageProficiencyMaxAggregateInputType = {
    lga_language_prof_id?: true
    lga_code?: true
    language_id?: true
    english_profiency_level?: true
    count?: true
  }

  export type LgaLanguageProficiencyCountAggregateInputType = {
    lga_language_prof_id?: true
    lga_code?: true
    language_id?: true
    english_profiency_level?: true
    count?: true
    _all?: true
  }

  export type LgaLanguageProficiencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LgaLanguageProficiency to aggregate.
     */
    where?: LgaLanguageProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaLanguageProficiencies to fetch.
     */
    orderBy?: LgaLanguageProficiencyOrderByWithRelationInput | LgaLanguageProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LgaLanguageProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaLanguageProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaLanguageProficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LgaLanguageProficiencies
    **/
    _count?: true | LgaLanguageProficiencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LgaLanguageProficiencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LgaLanguageProficiencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LgaLanguageProficiencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LgaLanguageProficiencyMaxAggregateInputType
  }

  export type GetLgaLanguageProficiencyAggregateType<T extends LgaLanguageProficiencyAggregateArgs> = {
        [P in keyof T & keyof AggregateLgaLanguageProficiency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLgaLanguageProficiency[P]>
      : GetScalarType<T[P], AggregateLgaLanguageProficiency[P]>
  }




  export type LgaLanguageProficiencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaLanguageProficiencyWhereInput
    orderBy?: LgaLanguageProficiencyOrderByWithAggregationInput | LgaLanguageProficiencyOrderByWithAggregationInput[]
    by: LgaLanguageProficiencyScalarFieldEnum[] | LgaLanguageProficiencyScalarFieldEnum
    having?: LgaLanguageProficiencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LgaLanguageProficiencyCountAggregateInputType | true
    _avg?: LgaLanguageProficiencyAvgAggregateInputType
    _sum?: LgaLanguageProficiencySumAggregateInputType
    _min?: LgaLanguageProficiencyMinAggregateInputType
    _max?: LgaLanguageProficiencyMaxAggregateInputType
  }

  export type LgaLanguageProficiencyGroupByOutputType = {
    lga_language_prof_id: number
    lga_code: number
    language_id: number
    english_profiency_level: string
    count: number
    _count: LgaLanguageProficiencyCountAggregateOutputType | null
    _avg: LgaLanguageProficiencyAvgAggregateOutputType | null
    _sum: LgaLanguageProficiencySumAggregateOutputType | null
    _min: LgaLanguageProficiencyMinAggregateOutputType | null
    _max: LgaLanguageProficiencyMaxAggregateOutputType | null
  }

  type GetLgaLanguageProficiencyGroupByPayload<T extends LgaLanguageProficiencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LgaLanguageProficiencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LgaLanguageProficiencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LgaLanguageProficiencyGroupByOutputType[P]>
            : GetScalarType<T[P], LgaLanguageProficiencyGroupByOutputType[P]>
        }
      >
    >


  export type LgaLanguageProficiencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_language_prof_id?: boolean
    lga_code?: boolean
    language_id?: boolean
    english_profiency_level?: boolean
    count?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaLanguageProficiency"]>

  export type LgaLanguageProficiencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_language_prof_id?: boolean
    lga_code?: boolean
    language_id?: boolean
    english_profiency_level?: boolean
    count?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaLanguageProficiency"]>

  export type LgaLanguageProficiencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_language_prof_id?: boolean
    lga_code?: boolean
    language_id?: boolean
    english_profiency_level?: boolean
    count?: boolean
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaLanguageProficiency"]>

  export type LgaLanguageProficiencySelectScalar = {
    lga_language_prof_id?: boolean
    lga_code?: boolean
    language_id?: boolean
    english_profiency_level?: boolean
    count?: boolean
  }

  export type LgaLanguageProficiencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lga_language_prof_id" | "lga_code" | "language_id" | "english_profiency_level" | "count", ExtArgs["result"]["lgaLanguageProficiency"]>
  export type LgaLanguageProficiencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type LgaLanguageProficiencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type LgaLanguageProficiencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    language?: boolean | LanguageDefaultArgs<ExtArgs>
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }

  export type $LgaLanguageProficiencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LgaLanguageProficiency"
    objects: {
      language: Prisma.$LanguagePayload<ExtArgs>
      lga: Prisma.$LgaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      lga_language_prof_id: number
      lga_code: number
      language_id: number
      english_profiency_level: string
      count: number
    }, ExtArgs["result"]["lgaLanguageProficiency"]>
    composites: {}
  }

  type LgaLanguageProficiencyGetPayload<S extends boolean | null | undefined | LgaLanguageProficiencyDefaultArgs> = $Result.GetResult<Prisma.$LgaLanguageProficiencyPayload, S>

  type LgaLanguageProficiencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LgaLanguageProficiencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LgaLanguageProficiencyCountAggregateInputType | true
    }

  export interface LgaLanguageProficiencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LgaLanguageProficiency'], meta: { name: 'LgaLanguageProficiency' } }
    /**
     * Find zero or one LgaLanguageProficiency that matches the filter.
     * @param {LgaLanguageProficiencyFindUniqueArgs} args - Arguments to find a LgaLanguageProficiency
     * @example
     * // Get one LgaLanguageProficiency
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LgaLanguageProficiencyFindUniqueArgs>(args: SelectSubset<T, LgaLanguageProficiencyFindUniqueArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LgaLanguageProficiency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LgaLanguageProficiencyFindUniqueOrThrowArgs} args - Arguments to find a LgaLanguageProficiency
     * @example
     * // Get one LgaLanguageProficiency
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LgaLanguageProficiencyFindUniqueOrThrowArgs>(args: SelectSubset<T, LgaLanguageProficiencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LgaLanguageProficiency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaLanguageProficiencyFindFirstArgs} args - Arguments to find a LgaLanguageProficiency
     * @example
     * // Get one LgaLanguageProficiency
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LgaLanguageProficiencyFindFirstArgs>(args?: SelectSubset<T, LgaLanguageProficiencyFindFirstArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LgaLanguageProficiency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaLanguageProficiencyFindFirstOrThrowArgs} args - Arguments to find a LgaLanguageProficiency
     * @example
     * // Get one LgaLanguageProficiency
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LgaLanguageProficiencyFindFirstOrThrowArgs>(args?: SelectSubset<T, LgaLanguageProficiencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LgaLanguageProficiencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaLanguageProficiencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LgaLanguageProficiencies
     * const lgaLanguageProficiencies = await prisma.lgaLanguageProficiency.findMany()
     * 
     * // Get first 10 LgaLanguageProficiencies
     * const lgaLanguageProficiencies = await prisma.lgaLanguageProficiency.findMany({ take: 10 })
     * 
     * // Only select the `lga_language_prof_id`
     * const lgaLanguageProficiencyWithLga_language_prof_idOnly = await prisma.lgaLanguageProficiency.findMany({ select: { lga_language_prof_id: true } })
     * 
     */
    findMany<T extends LgaLanguageProficiencyFindManyArgs>(args?: SelectSubset<T, LgaLanguageProficiencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LgaLanguageProficiency.
     * @param {LgaLanguageProficiencyCreateArgs} args - Arguments to create a LgaLanguageProficiency.
     * @example
     * // Create one LgaLanguageProficiency
     * const LgaLanguageProficiency = await prisma.lgaLanguageProficiency.create({
     *   data: {
     *     // ... data to create a LgaLanguageProficiency
     *   }
     * })
     * 
     */
    create<T extends LgaLanguageProficiencyCreateArgs>(args: SelectSubset<T, LgaLanguageProficiencyCreateArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LgaLanguageProficiencies.
     * @param {LgaLanguageProficiencyCreateManyArgs} args - Arguments to create many LgaLanguageProficiencies.
     * @example
     * // Create many LgaLanguageProficiencies
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LgaLanguageProficiencyCreateManyArgs>(args?: SelectSubset<T, LgaLanguageProficiencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LgaLanguageProficiencies and returns the data saved in the database.
     * @param {LgaLanguageProficiencyCreateManyAndReturnArgs} args - Arguments to create many LgaLanguageProficiencies.
     * @example
     * // Create many LgaLanguageProficiencies
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LgaLanguageProficiencies and only return the `lga_language_prof_id`
     * const lgaLanguageProficiencyWithLga_language_prof_idOnly = await prisma.lgaLanguageProficiency.createManyAndReturn({
     *   select: { lga_language_prof_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LgaLanguageProficiencyCreateManyAndReturnArgs>(args?: SelectSubset<T, LgaLanguageProficiencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LgaLanguageProficiency.
     * @param {LgaLanguageProficiencyDeleteArgs} args - Arguments to delete one LgaLanguageProficiency.
     * @example
     * // Delete one LgaLanguageProficiency
     * const LgaLanguageProficiency = await prisma.lgaLanguageProficiency.delete({
     *   where: {
     *     // ... filter to delete one LgaLanguageProficiency
     *   }
     * })
     * 
     */
    delete<T extends LgaLanguageProficiencyDeleteArgs>(args: SelectSubset<T, LgaLanguageProficiencyDeleteArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LgaLanguageProficiency.
     * @param {LgaLanguageProficiencyUpdateArgs} args - Arguments to update one LgaLanguageProficiency.
     * @example
     * // Update one LgaLanguageProficiency
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LgaLanguageProficiencyUpdateArgs>(args: SelectSubset<T, LgaLanguageProficiencyUpdateArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LgaLanguageProficiencies.
     * @param {LgaLanguageProficiencyDeleteManyArgs} args - Arguments to filter LgaLanguageProficiencies to delete.
     * @example
     * // Delete a few LgaLanguageProficiencies
     * const { count } = await prisma.lgaLanguageProficiency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LgaLanguageProficiencyDeleteManyArgs>(args?: SelectSubset<T, LgaLanguageProficiencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LgaLanguageProficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaLanguageProficiencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LgaLanguageProficiencies
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LgaLanguageProficiencyUpdateManyArgs>(args: SelectSubset<T, LgaLanguageProficiencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LgaLanguageProficiencies and returns the data updated in the database.
     * @param {LgaLanguageProficiencyUpdateManyAndReturnArgs} args - Arguments to update many LgaLanguageProficiencies.
     * @example
     * // Update many LgaLanguageProficiencies
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LgaLanguageProficiencies and only return the `lga_language_prof_id`
     * const lgaLanguageProficiencyWithLga_language_prof_idOnly = await prisma.lgaLanguageProficiency.updateManyAndReturn({
     *   select: { lga_language_prof_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LgaLanguageProficiencyUpdateManyAndReturnArgs>(args: SelectSubset<T, LgaLanguageProficiencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LgaLanguageProficiency.
     * @param {LgaLanguageProficiencyUpsertArgs} args - Arguments to update or create a LgaLanguageProficiency.
     * @example
     * // Update or create a LgaLanguageProficiency
     * const lgaLanguageProficiency = await prisma.lgaLanguageProficiency.upsert({
     *   create: {
     *     // ... data to create a LgaLanguageProficiency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LgaLanguageProficiency we want to update
     *   }
     * })
     */
    upsert<T extends LgaLanguageProficiencyUpsertArgs>(args: SelectSubset<T, LgaLanguageProficiencyUpsertArgs<ExtArgs>>): Prisma__LgaLanguageProficiencyClient<$Result.GetResult<Prisma.$LgaLanguageProficiencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LgaLanguageProficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaLanguageProficiencyCountArgs} args - Arguments to filter LgaLanguageProficiencies to count.
     * @example
     * // Count the number of LgaLanguageProficiencies
     * const count = await prisma.lgaLanguageProficiency.count({
     *   where: {
     *     // ... the filter for the LgaLanguageProficiencies we want to count
     *   }
     * })
    **/
    count<T extends LgaLanguageProficiencyCountArgs>(
      args?: Subset<T, LgaLanguageProficiencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LgaLanguageProficiencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LgaLanguageProficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaLanguageProficiencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LgaLanguageProficiencyAggregateArgs>(args: Subset<T, LgaLanguageProficiencyAggregateArgs>): Prisma.PrismaPromise<GetLgaLanguageProficiencyAggregateType<T>>

    /**
     * Group by LgaLanguageProficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaLanguageProficiencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LgaLanguageProficiencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LgaLanguageProficiencyGroupByArgs['orderBy'] }
        : { orderBy?: LgaLanguageProficiencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LgaLanguageProficiencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLgaLanguageProficiencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LgaLanguageProficiency model
   */
  readonly fields: LgaLanguageProficiencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LgaLanguageProficiency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LgaLanguageProficiencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    language<T extends LanguageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguageDefaultArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lga<T extends LgaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LgaDefaultArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LgaLanguageProficiency model
   */
  interface LgaLanguageProficiencyFieldRefs {
    readonly lga_language_prof_id: FieldRef<"LgaLanguageProficiency", 'Int'>
    readonly lga_code: FieldRef<"LgaLanguageProficiency", 'Int'>
    readonly language_id: FieldRef<"LgaLanguageProficiency", 'Int'>
    readonly english_profiency_level: FieldRef<"LgaLanguageProficiency", 'String'>
    readonly count: FieldRef<"LgaLanguageProficiency", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LgaLanguageProficiency findUnique
   */
  export type LgaLanguageProficiencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which LgaLanguageProficiency to fetch.
     */
    where: LgaLanguageProficiencyWhereUniqueInput
  }

  /**
   * LgaLanguageProficiency findUniqueOrThrow
   */
  export type LgaLanguageProficiencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which LgaLanguageProficiency to fetch.
     */
    where: LgaLanguageProficiencyWhereUniqueInput
  }

  /**
   * LgaLanguageProficiency findFirst
   */
  export type LgaLanguageProficiencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which LgaLanguageProficiency to fetch.
     */
    where?: LgaLanguageProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaLanguageProficiencies to fetch.
     */
    orderBy?: LgaLanguageProficiencyOrderByWithRelationInput | LgaLanguageProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LgaLanguageProficiencies.
     */
    cursor?: LgaLanguageProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaLanguageProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaLanguageProficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LgaLanguageProficiencies.
     */
    distinct?: LgaLanguageProficiencyScalarFieldEnum | LgaLanguageProficiencyScalarFieldEnum[]
  }

  /**
   * LgaLanguageProficiency findFirstOrThrow
   */
  export type LgaLanguageProficiencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which LgaLanguageProficiency to fetch.
     */
    where?: LgaLanguageProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaLanguageProficiencies to fetch.
     */
    orderBy?: LgaLanguageProficiencyOrderByWithRelationInput | LgaLanguageProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LgaLanguageProficiencies.
     */
    cursor?: LgaLanguageProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaLanguageProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaLanguageProficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LgaLanguageProficiencies.
     */
    distinct?: LgaLanguageProficiencyScalarFieldEnum | LgaLanguageProficiencyScalarFieldEnum[]
  }

  /**
   * LgaLanguageProficiency findMany
   */
  export type LgaLanguageProficiencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * Filter, which LgaLanguageProficiencies to fetch.
     */
    where?: LgaLanguageProficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaLanguageProficiencies to fetch.
     */
    orderBy?: LgaLanguageProficiencyOrderByWithRelationInput | LgaLanguageProficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LgaLanguageProficiencies.
     */
    cursor?: LgaLanguageProficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaLanguageProficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaLanguageProficiencies.
     */
    skip?: number
    distinct?: LgaLanguageProficiencyScalarFieldEnum | LgaLanguageProficiencyScalarFieldEnum[]
  }

  /**
   * LgaLanguageProficiency create
   */
  export type LgaLanguageProficiencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * The data needed to create a LgaLanguageProficiency.
     */
    data: XOR<LgaLanguageProficiencyCreateInput, LgaLanguageProficiencyUncheckedCreateInput>
  }

  /**
   * LgaLanguageProficiency createMany
   */
  export type LgaLanguageProficiencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LgaLanguageProficiencies.
     */
    data: LgaLanguageProficiencyCreateManyInput | LgaLanguageProficiencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LgaLanguageProficiency createManyAndReturn
   */
  export type LgaLanguageProficiencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * The data used to create many LgaLanguageProficiencies.
     */
    data: LgaLanguageProficiencyCreateManyInput | LgaLanguageProficiencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LgaLanguageProficiency update
   */
  export type LgaLanguageProficiencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * The data needed to update a LgaLanguageProficiency.
     */
    data: XOR<LgaLanguageProficiencyUpdateInput, LgaLanguageProficiencyUncheckedUpdateInput>
    /**
     * Choose, which LgaLanguageProficiency to update.
     */
    where: LgaLanguageProficiencyWhereUniqueInput
  }

  /**
   * LgaLanguageProficiency updateMany
   */
  export type LgaLanguageProficiencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LgaLanguageProficiencies.
     */
    data: XOR<LgaLanguageProficiencyUpdateManyMutationInput, LgaLanguageProficiencyUncheckedUpdateManyInput>
    /**
     * Filter which LgaLanguageProficiencies to update
     */
    where?: LgaLanguageProficiencyWhereInput
    /**
     * Limit how many LgaLanguageProficiencies to update.
     */
    limit?: number
  }

  /**
   * LgaLanguageProficiency updateManyAndReturn
   */
  export type LgaLanguageProficiencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * The data used to update LgaLanguageProficiencies.
     */
    data: XOR<LgaLanguageProficiencyUpdateManyMutationInput, LgaLanguageProficiencyUncheckedUpdateManyInput>
    /**
     * Filter which LgaLanguageProficiencies to update
     */
    where?: LgaLanguageProficiencyWhereInput
    /**
     * Limit how many LgaLanguageProficiencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LgaLanguageProficiency upsert
   */
  export type LgaLanguageProficiencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * The filter to search for the LgaLanguageProficiency to update in case it exists.
     */
    where: LgaLanguageProficiencyWhereUniqueInput
    /**
     * In case the LgaLanguageProficiency found by the `where` argument doesn't exist, create a new LgaLanguageProficiency with this data.
     */
    create: XOR<LgaLanguageProficiencyCreateInput, LgaLanguageProficiencyUncheckedCreateInput>
    /**
     * In case the LgaLanguageProficiency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LgaLanguageProficiencyUpdateInput, LgaLanguageProficiencyUncheckedUpdateInput>
  }

  /**
   * LgaLanguageProficiency delete
   */
  export type LgaLanguageProficiencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
    /**
     * Filter which LgaLanguageProficiency to delete.
     */
    where: LgaLanguageProficiencyWhereUniqueInput
  }

  /**
   * LgaLanguageProficiency deleteMany
   */
  export type LgaLanguageProficiencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LgaLanguageProficiencies to delete
     */
    where?: LgaLanguageProficiencyWhereInput
    /**
     * Limit how many LgaLanguageProficiencies to delete.
     */
    limit?: number
  }

  /**
   * LgaLanguageProficiency without action
   */
  export type LgaLanguageProficiencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaLanguageProficiency
     */
    select?: LgaLanguageProficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaLanguageProficiency
     */
    omit?: LgaLanguageProficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaLanguageProficiencyInclude<ExtArgs> | null
  }


  /**
   * Model LgaStatistics
   */

  export type AggregateLgaStatistics = {
    _count: LgaStatisticsCountAggregateOutputType | null
    _avg: LgaStatisticsAvgAggregateOutputType | null
    _sum: LgaStatisticsSumAggregateOutputType | null
    _min: LgaStatisticsMinAggregateOutputType | null
    _max: LgaStatisticsMaxAggregateOutputType | null
  }

  export type LgaStatisticsAvgAggregateOutputType = {
    lga_code: number | null
    total_businesses: number | null
    total_employed_over_15: number | null
    born_overseas: number | null
    pct_arrived_within_5_years: number | null
    pct_proficient_english: number | null
    percent_speaks_other_lang_at_home: number | null
    median_age_years: number | null
    pct_completed_year_12: number | null
    pct_certificate: number | null
    pct_bachelor_degree: number | null
    pct_postgraduate: number | null
    pct_managers: number | null
    pct_professionals: number | null
    pct_labourers: number | null
  }

  export type LgaStatisticsSumAggregateOutputType = {
    lga_code: number | null
    total_businesses: number | null
    total_employed_over_15: number | null
    born_overseas: number | null
    pct_arrived_within_5_years: number | null
    pct_proficient_english: number | null
    percent_speaks_other_lang_at_home: number | null
    median_age_years: number | null
    pct_completed_year_12: number | null
    pct_certificate: number | null
    pct_bachelor_degree: number | null
    pct_postgraduate: number | null
    pct_managers: number | null
    pct_professionals: number | null
    pct_labourers: number | null
  }

  export type LgaStatisticsMinAggregateOutputType = {
    lga_code: number | null
    total_businesses: number | null
    total_employed_over_15: number | null
    born_overseas: number | null
    pct_arrived_within_5_years: number | null
    pct_proficient_english: number | null
    percent_speaks_other_lang_at_home: number | null
    median_age_years: number | null
    pct_completed_year_12: number | null
    pct_certificate: number | null
    pct_bachelor_degree: number | null
    pct_postgraduate: number | null
    pct_managers: number | null
    pct_professionals: number | null
    pct_labourers: number | null
  }

  export type LgaStatisticsMaxAggregateOutputType = {
    lga_code: number | null
    total_businesses: number | null
    total_employed_over_15: number | null
    born_overseas: number | null
    pct_arrived_within_5_years: number | null
    pct_proficient_english: number | null
    percent_speaks_other_lang_at_home: number | null
    median_age_years: number | null
    pct_completed_year_12: number | null
    pct_certificate: number | null
    pct_bachelor_degree: number | null
    pct_postgraduate: number | null
    pct_managers: number | null
    pct_professionals: number | null
    pct_labourers: number | null
  }

  export type LgaStatisticsCountAggregateOutputType = {
    lga_code: number
    total_businesses: number
    total_employed_over_15: number
    born_overseas: number
    pct_arrived_within_5_years: number
    pct_proficient_english: number
    percent_speaks_other_lang_at_home: number
    median_age_years: number
    pct_completed_year_12: number
    pct_certificate: number
    pct_bachelor_degree: number
    pct_postgraduate: number
    pct_managers: number
    pct_professionals: number
    pct_labourers: number
    _all: number
  }


  export type LgaStatisticsAvgAggregateInputType = {
    lga_code?: true
    total_businesses?: true
    total_employed_over_15?: true
    born_overseas?: true
    pct_arrived_within_5_years?: true
    pct_proficient_english?: true
    percent_speaks_other_lang_at_home?: true
    median_age_years?: true
    pct_completed_year_12?: true
    pct_certificate?: true
    pct_bachelor_degree?: true
    pct_postgraduate?: true
    pct_managers?: true
    pct_professionals?: true
    pct_labourers?: true
  }

  export type LgaStatisticsSumAggregateInputType = {
    lga_code?: true
    total_businesses?: true
    total_employed_over_15?: true
    born_overseas?: true
    pct_arrived_within_5_years?: true
    pct_proficient_english?: true
    percent_speaks_other_lang_at_home?: true
    median_age_years?: true
    pct_completed_year_12?: true
    pct_certificate?: true
    pct_bachelor_degree?: true
    pct_postgraduate?: true
    pct_managers?: true
    pct_professionals?: true
    pct_labourers?: true
  }

  export type LgaStatisticsMinAggregateInputType = {
    lga_code?: true
    total_businesses?: true
    total_employed_over_15?: true
    born_overseas?: true
    pct_arrived_within_5_years?: true
    pct_proficient_english?: true
    percent_speaks_other_lang_at_home?: true
    median_age_years?: true
    pct_completed_year_12?: true
    pct_certificate?: true
    pct_bachelor_degree?: true
    pct_postgraduate?: true
    pct_managers?: true
    pct_professionals?: true
    pct_labourers?: true
  }

  export type LgaStatisticsMaxAggregateInputType = {
    lga_code?: true
    total_businesses?: true
    total_employed_over_15?: true
    born_overseas?: true
    pct_arrived_within_5_years?: true
    pct_proficient_english?: true
    percent_speaks_other_lang_at_home?: true
    median_age_years?: true
    pct_completed_year_12?: true
    pct_certificate?: true
    pct_bachelor_degree?: true
    pct_postgraduate?: true
    pct_managers?: true
    pct_professionals?: true
    pct_labourers?: true
  }

  export type LgaStatisticsCountAggregateInputType = {
    lga_code?: true
    total_businesses?: true
    total_employed_over_15?: true
    born_overseas?: true
    pct_arrived_within_5_years?: true
    pct_proficient_english?: true
    percent_speaks_other_lang_at_home?: true
    median_age_years?: true
    pct_completed_year_12?: true
    pct_certificate?: true
    pct_bachelor_degree?: true
    pct_postgraduate?: true
    pct_managers?: true
    pct_professionals?: true
    pct_labourers?: true
    _all?: true
  }

  export type LgaStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LgaStatistics to aggregate.
     */
    where?: LgaStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaStatistics to fetch.
     */
    orderBy?: LgaStatisticsOrderByWithRelationInput | LgaStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LgaStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LgaStatistics
    **/
    _count?: true | LgaStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LgaStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LgaStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LgaStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LgaStatisticsMaxAggregateInputType
  }

  export type GetLgaStatisticsAggregateType<T extends LgaStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateLgaStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLgaStatistics[P]>
      : GetScalarType<T[P], AggregateLgaStatistics[P]>
  }




  export type LgaStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LgaStatisticsWhereInput
    orderBy?: LgaStatisticsOrderByWithAggregationInput | LgaStatisticsOrderByWithAggregationInput[]
    by: LgaStatisticsScalarFieldEnum[] | LgaStatisticsScalarFieldEnum
    having?: LgaStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LgaStatisticsCountAggregateInputType | true
    _avg?: LgaStatisticsAvgAggregateInputType
    _sum?: LgaStatisticsSumAggregateInputType
    _min?: LgaStatisticsMinAggregateInputType
    _max?: LgaStatisticsMaxAggregateInputType
  }

  export type LgaStatisticsGroupByOutputType = {
    lga_code: number
    total_businesses: number | null
    total_employed_over_15: number | null
    born_overseas: number | null
    pct_arrived_within_5_years: number | null
    pct_proficient_english: number | null
    percent_speaks_other_lang_at_home: number | null
    median_age_years: number | null
    pct_completed_year_12: number | null
    pct_certificate: number | null
    pct_bachelor_degree: number | null
    pct_postgraduate: number | null
    pct_managers: number | null
    pct_professionals: number | null
    pct_labourers: number | null
    _count: LgaStatisticsCountAggregateOutputType | null
    _avg: LgaStatisticsAvgAggregateOutputType | null
    _sum: LgaStatisticsSumAggregateOutputType | null
    _min: LgaStatisticsMinAggregateOutputType | null
    _max: LgaStatisticsMaxAggregateOutputType | null
  }

  type GetLgaStatisticsGroupByPayload<T extends LgaStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LgaStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LgaStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LgaStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], LgaStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type LgaStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    total_businesses?: boolean
    total_employed_over_15?: boolean
    born_overseas?: boolean
    pct_arrived_within_5_years?: boolean
    pct_proficient_english?: boolean
    percent_speaks_other_lang_at_home?: boolean
    median_age_years?: boolean
    pct_completed_year_12?: boolean
    pct_certificate?: boolean
    pct_bachelor_degree?: boolean
    pct_postgraduate?: boolean
    pct_managers?: boolean
    pct_professionals?: boolean
    pct_labourers?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaStatistics"]>

  export type LgaStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    total_businesses?: boolean
    total_employed_over_15?: boolean
    born_overseas?: boolean
    pct_arrived_within_5_years?: boolean
    pct_proficient_english?: boolean
    percent_speaks_other_lang_at_home?: boolean
    median_age_years?: boolean
    pct_completed_year_12?: boolean
    pct_certificate?: boolean
    pct_bachelor_degree?: boolean
    pct_postgraduate?: boolean
    pct_managers?: boolean
    pct_professionals?: boolean
    pct_labourers?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaStatistics"]>

  export type LgaStatisticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lga_code?: boolean
    total_businesses?: boolean
    total_employed_over_15?: boolean
    born_overseas?: boolean
    pct_arrived_within_5_years?: boolean
    pct_proficient_english?: boolean
    percent_speaks_other_lang_at_home?: boolean
    median_age_years?: boolean
    pct_completed_year_12?: boolean
    pct_certificate?: boolean
    pct_bachelor_degree?: boolean
    pct_postgraduate?: boolean
    pct_managers?: boolean
    pct_professionals?: boolean
    pct_labourers?: boolean
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lgaStatistics"]>

  export type LgaStatisticsSelectScalar = {
    lga_code?: boolean
    total_businesses?: boolean
    total_employed_over_15?: boolean
    born_overseas?: boolean
    pct_arrived_within_5_years?: boolean
    pct_proficient_english?: boolean
    percent_speaks_other_lang_at_home?: boolean
    median_age_years?: boolean
    pct_completed_year_12?: boolean
    pct_certificate?: boolean
    pct_bachelor_degree?: boolean
    pct_postgraduate?: boolean
    pct_managers?: boolean
    pct_professionals?: boolean
    pct_labourers?: boolean
  }

  export type LgaStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lga_code" | "total_businesses" | "total_employed_over_15" | "born_overseas" | "pct_arrived_within_5_years" | "pct_proficient_english" | "percent_speaks_other_lang_at_home" | "median_age_years" | "pct_completed_year_12" | "pct_certificate" | "pct_bachelor_degree" | "pct_postgraduate" | "pct_managers" | "pct_professionals" | "pct_labourers", ExtArgs["result"]["lgaStatistics"]>
  export type LgaStatisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type LgaStatisticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }
  export type LgaStatisticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lga?: boolean | LgaDefaultArgs<ExtArgs>
  }

  export type $LgaStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LgaStatistics"
    objects: {
      lga: Prisma.$LgaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      lga_code: number
      total_businesses: number | null
      total_employed_over_15: number | null
      born_overseas: number | null
      pct_arrived_within_5_years: number | null
      pct_proficient_english: number | null
      percent_speaks_other_lang_at_home: number | null
      median_age_years: number | null
      pct_completed_year_12: number | null
      pct_certificate: number | null
      pct_bachelor_degree: number | null
      pct_postgraduate: number | null
      pct_managers: number | null
      pct_professionals: number | null
      pct_labourers: number | null
    }, ExtArgs["result"]["lgaStatistics"]>
    composites: {}
  }

  type LgaStatisticsGetPayload<S extends boolean | null | undefined | LgaStatisticsDefaultArgs> = $Result.GetResult<Prisma.$LgaStatisticsPayload, S>

  type LgaStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LgaStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LgaStatisticsCountAggregateInputType | true
    }

  export interface LgaStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LgaStatistics'], meta: { name: 'LgaStatistics' } }
    /**
     * Find zero or one LgaStatistics that matches the filter.
     * @param {LgaStatisticsFindUniqueArgs} args - Arguments to find a LgaStatistics
     * @example
     * // Get one LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LgaStatisticsFindUniqueArgs>(args: SelectSubset<T, LgaStatisticsFindUniqueArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LgaStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LgaStatisticsFindUniqueOrThrowArgs} args - Arguments to find a LgaStatistics
     * @example
     * // Get one LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LgaStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, LgaStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LgaStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaStatisticsFindFirstArgs} args - Arguments to find a LgaStatistics
     * @example
     * // Get one LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LgaStatisticsFindFirstArgs>(args?: SelectSubset<T, LgaStatisticsFindFirstArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LgaStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaStatisticsFindFirstOrThrowArgs} args - Arguments to find a LgaStatistics
     * @example
     * // Get one LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LgaStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, LgaStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LgaStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.findMany()
     * 
     * // Get first 10 LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.findMany({ take: 10 })
     * 
     * // Only select the `lga_code`
     * const lgaStatisticsWithLga_codeOnly = await prisma.lgaStatistics.findMany({ select: { lga_code: true } })
     * 
     */
    findMany<T extends LgaStatisticsFindManyArgs>(args?: SelectSubset<T, LgaStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LgaStatistics.
     * @param {LgaStatisticsCreateArgs} args - Arguments to create a LgaStatistics.
     * @example
     * // Create one LgaStatistics
     * const LgaStatistics = await prisma.lgaStatistics.create({
     *   data: {
     *     // ... data to create a LgaStatistics
     *   }
     * })
     * 
     */
    create<T extends LgaStatisticsCreateArgs>(args: SelectSubset<T, LgaStatisticsCreateArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LgaStatistics.
     * @param {LgaStatisticsCreateManyArgs} args - Arguments to create many LgaStatistics.
     * @example
     * // Create many LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LgaStatisticsCreateManyArgs>(args?: SelectSubset<T, LgaStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LgaStatistics and returns the data saved in the database.
     * @param {LgaStatisticsCreateManyAndReturnArgs} args - Arguments to create many LgaStatistics.
     * @example
     * // Create many LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LgaStatistics and only return the `lga_code`
     * const lgaStatisticsWithLga_codeOnly = await prisma.lgaStatistics.createManyAndReturn({
     *   select: { lga_code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LgaStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, LgaStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LgaStatistics.
     * @param {LgaStatisticsDeleteArgs} args - Arguments to delete one LgaStatistics.
     * @example
     * // Delete one LgaStatistics
     * const LgaStatistics = await prisma.lgaStatistics.delete({
     *   where: {
     *     // ... filter to delete one LgaStatistics
     *   }
     * })
     * 
     */
    delete<T extends LgaStatisticsDeleteArgs>(args: SelectSubset<T, LgaStatisticsDeleteArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LgaStatistics.
     * @param {LgaStatisticsUpdateArgs} args - Arguments to update one LgaStatistics.
     * @example
     * // Update one LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LgaStatisticsUpdateArgs>(args: SelectSubset<T, LgaStatisticsUpdateArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LgaStatistics.
     * @param {LgaStatisticsDeleteManyArgs} args - Arguments to filter LgaStatistics to delete.
     * @example
     * // Delete a few LgaStatistics
     * const { count } = await prisma.lgaStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LgaStatisticsDeleteManyArgs>(args?: SelectSubset<T, LgaStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LgaStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LgaStatisticsUpdateManyArgs>(args: SelectSubset<T, LgaStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LgaStatistics and returns the data updated in the database.
     * @param {LgaStatisticsUpdateManyAndReturnArgs} args - Arguments to update many LgaStatistics.
     * @example
     * // Update many LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LgaStatistics and only return the `lga_code`
     * const lgaStatisticsWithLga_codeOnly = await prisma.lgaStatistics.updateManyAndReturn({
     *   select: { lga_code: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LgaStatisticsUpdateManyAndReturnArgs>(args: SelectSubset<T, LgaStatisticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LgaStatistics.
     * @param {LgaStatisticsUpsertArgs} args - Arguments to update or create a LgaStatistics.
     * @example
     * // Update or create a LgaStatistics
     * const lgaStatistics = await prisma.lgaStatistics.upsert({
     *   create: {
     *     // ... data to create a LgaStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LgaStatistics we want to update
     *   }
     * })
     */
    upsert<T extends LgaStatisticsUpsertArgs>(args: SelectSubset<T, LgaStatisticsUpsertArgs<ExtArgs>>): Prisma__LgaStatisticsClient<$Result.GetResult<Prisma.$LgaStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LgaStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaStatisticsCountArgs} args - Arguments to filter LgaStatistics to count.
     * @example
     * // Count the number of LgaStatistics
     * const count = await prisma.lgaStatistics.count({
     *   where: {
     *     // ... the filter for the LgaStatistics we want to count
     *   }
     * })
    **/
    count<T extends LgaStatisticsCountArgs>(
      args?: Subset<T, LgaStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LgaStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LgaStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LgaStatisticsAggregateArgs>(args: Subset<T, LgaStatisticsAggregateArgs>): Prisma.PrismaPromise<GetLgaStatisticsAggregateType<T>>

    /**
     * Group by LgaStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LgaStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LgaStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LgaStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: LgaStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LgaStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLgaStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LgaStatistics model
   */
  readonly fields: LgaStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LgaStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LgaStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lga<T extends LgaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LgaDefaultArgs<ExtArgs>>): Prisma__LgaClient<$Result.GetResult<Prisma.$LgaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LgaStatistics model
   */
  interface LgaStatisticsFieldRefs {
    readonly lga_code: FieldRef<"LgaStatistics", 'Int'>
    readonly total_businesses: FieldRef<"LgaStatistics", 'Int'>
    readonly total_employed_over_15: FieldRef<"LgaStatistics", 'Int'>
    readonly born_overseas: FieldRef<"LgaStatistics", 'Int'>
    readonly pct_arrived_within_5_years: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_proficient_english: FieldRef<"LgaStatistics", 'Float'>
    readonly percent_speaks_other_lang_at_home: FieldRef<"LgaStatistics", 'Float'>
    readonly median_age_years: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_completed_year_12: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_certificate: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_bachelor_degree: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_postgraduate: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_managers: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_professionals: FieldRef<"LgaStatistics", 'Float'>
    readonly pct_labourers: FieldRef<"LgaStatistics", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * LgaStatistics findUnique
   */
  export type LgaStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which LgaStatistics to fetch.
     */
    where: LgaStatisticsWhereUniqueInput
  }

  /**
   * LgaStatistics findUniqueOrThrow
   */
  export type LgaStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which LgaStatistics to fetch.
     */
    where: LgaStatisticsWhereUniqueInput
  }

  /**
   * LgaStatistics findFirst
   */
  export type LgaStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which LgaStatistics to fetch.
     */
    where?: LgaStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaStatistics to fetch.
     */
    orderBy?: LgaStatisticsOrderByWithRelationInput | LgaStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LgaStatistics.
     */
    cursor?: LgaStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LgaStatistics.
     */
    distinct?: LgaStatisticsScalarFieldEnum | LgaStatisticsScalarFieldEnum[]
  }

  /**
   * LgaStatistics findFirstOrThrow
   */
  export type LgaStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which LgaStatistics to fetch.
     */
    where?: LgaStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaStatistics to fetch.
     */
    orderBy?: LgaStatisticsOrderByWithRelationInput | LgaStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LgaStatistics.
     */
    cursor?: LgaStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LgaStatistics.
     */
    distinct?: LgaStatisticsScalarFieldEnum | LgaStatisticsScalarFieldEnum[]
  }

  /**
   * LgaStatistics findMany
   */
  export type LgaStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which LgaStatistics to fetch.
     */
    where?: LgaStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LgaStatistics to fetch.
     */
    orderBy?: LgaStatisticsOrderByWithRelationInput | LgaStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LgaStatistics.
     */
    cursor?: LgaStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LgaStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LgaStatistics.
     */
    skip?: number
    distinct?: LgaStatisticsScalarFieldEnum | LgaStatisticsScalarFieldEnum[]
  }

  /**
   * LgaStatistics create
   */
  export type LgaStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a LgaStatistics.
     */
    data: XOR<LgaStatisticsCreateInput, LgaStatisticsUncheckedCreateInput>
  }

  /**
   * LgaStatistics createMany
   */
  export type LgaStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LgaStatistics.
     */
    data: LgaStatisticsCreateManyInput | LgaStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LgaStatistics createManyAndReturn
   */
  export type LgaStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * The data used to create many LgaStatistics.
     */
    data: LgaStatisticsCreateManyInput | LgaStatisticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LgaStatistics update
   */
  export type LgaStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a LgaStatistics.
     */
    data: XOR<LgaStatisticsUpdateInput, LgaStatisticsUncheckedUpdateInput>
    /**
     * Choose, which LgaStatistics to update.
     */
    where: LgaStatisticsWhereUniqueInput
  }

  /**
   * LgaStatistics updateMany
   */
  export type LgaStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LgaStatistics.
     */
    data: XOR<LgaStatisticsUpdateManyMutationInput, LgaStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which LgaStatistics to update
     */
    where?: LgaStatisticsWhereInput
    /**
     * Limit how many LgaStatistics to update.
     */
    limit?: number
  }

  /**
   * LgaStatistics updateManyAndReturn
   */
  export type LgaStatisticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * The data used to update LgaStatistics.
     */
    data: XOR<LgaStatisticsUpdateManyMutationInput, LgaStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which LgaStatistics to update
     */
    where?: LgaStatisticsWhereInput
    /**
     * Limit how many LgaStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LgaStatistics upsert
   */
  export type LgaStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the LgaStatistics to update in case it exists.
     */
    where: LgaStatisticsWhereUniqueInput
    /**
     * In case the LgaStatistics found by the `where` argument doesn't exist, create a new LgaStatistics with this data.
     */
    create: XOR<LgaStatisticsCreateInput, LgaStatisticsUncheckedCreateInput>
    /**
     * In case the LgaStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LgaStatisticsUpdateInput, LgaStatisticsUncheckedUpdateInput>
  }

  /**
   * LgaStatistics delete
   */
  export type LgaStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
    /**
     * Filter which LgaStatistics to delete.
     */
    where: LgaStatisticsWhereUniqueInput
  }

  /**
   * LgaStatistics deleteMany
   */
  export type LgaStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LgaStatistics to delete
     */
    where?: LgaStatisticsWhereInput
    /**
     * Limit how many LgaStatistics to delete.
     */
    limit?: number
  }

  /**
   * LgaStatistics without action
   */
  export type LgaStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LgaStatistics
     */
    select?: LgaStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LgaStatistics
     */
    omit?: LgaStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LgaStatisticsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VenueScalarFieldEnum: {
    venue_id: 'venue_id',
    venue_name: 'venue_name',
    venue_address: 'venue_address',
    venue_city: 'venue_city',
    venue_latitude: 'venue_latitude',
    venue_longitude: 'venue_longitude',
    venue_postcode: 'venue_postcode'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    category_id: 'category_id',
    category_name: 'category_name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const OrganizerScalarFieldEnum: {
    organizer_id: 'organizer_id',
    organizer_name: 'organizer_name',
    organizer_url: 'organizer_url'
  };

  export type OrganizerScalarFieldEnum = (typeof OrganizerScalarFieldEnum)[keyof typeof OrganizerScalarFieldEnum]


  export const LogoScalarFieldEnum: {
    logo_id: 'logo_id',
    logo_url: 'logo_url',
    logo_width: 'logo_width',
    logo_height: 'logo_height',
    logo_aspect_ratio: 'logo_aspect_ratio'
  };

  export type LogoScalarFieldEnum = (typeof LogoScalarFieldEnum)[keyof typeof LogoScalarFieldEnum]


  export const EventScalarFieldEnum: {
    event_id: 'event_id',
    event_name: 'event_name',
    event_description: 'event_description',
    start_datetime: 'start_datetime',
    end_datetime: 'end_datetime',
    event_summary: 'event_summary',
    category_id: 'category_id',
    organizer_id: 'organizer_id',
    venue_id: 'venue_id',
    logo_id: 'logo_id',
    event_status: 'event_status',
    event_url: 'event_url',
    is_free_event: 'is_free_event',
    community_friendly: 'community_friendly',
    predicted_community_friendly: 'predicted_community_friendly'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const WebsiteScalarFieldEnum: {
    event_url: 'event_url',
    event_id: 'event_id'
  };

  export type WebsiteScalarFieldEnum = (typeof WebsiteScalarFieldEnum)[keyof typeof WebsiteScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    provider_id: 'provider_id',
    provider_name: 'provider_name',
    site_name: 'site_name',
    government_subsidised: 'government_subsidised',
    subsidy_tag: 'subsidy_tag',
    asqa_code: 'asqa_code',
    url: 'url',
    email: 'email'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    geographic_id: 'geographic_id',
    provider_id: 'provider_id',
    address_line_1: 'address_line_1',
    suburb: 'suburb',
    postcode: 'postcode',
    latitude: 'latitude',
    longitude: 'longitude',
    full_address: 'full_address',
    region_name: 'region_name',
    local_government_authority: 'local_government_authority'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    course_id: 'course_id',
    provider_id: 'provider_id',
    course_title: 'course_title',
    course_code: 'course_code',
    qualification_level: 'qualification_level',
    course_type: 'course_type',
    government_subsidised: 'government_subsidised',
    apprenticeship: 'apprenticeship',
    traineeship: 'traineeship',
    entry_requirements: 'entry_requirements',
    description: 'description',
    is_english_course: 'is_english_course'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const LgaScalarFieldEnum: {
    lga_code: 'lga_code',
    lga_name: 'lga_name'
  };

  export type LgaScalarFieldEnum = (typeof LgaScalarFieldEnum)[keyof typeof LgaScalarFieldEnum]


  export const NationalityScalarFieldEnum: {
    nationality_id: 'nationality_id',
    nationality: 'nationality'
  };

  export type NationalityScalarFieldEnum = (typeof NationalityScalarFieldEnum)[keyof typeof NationalityScalarFieldEnum]


  export const LgaNationalityScalarFieldEnum: {
    lga_nationality_id: 'lga_nationality_id',
    lga_code: 'lga_code',
    nationality_id: 'nationality_id',
    count: 'count'
  };

  export type LgaNationalityScalarFieldEnum = (typeof LgaNationalityScalarFieldEnum)[keyof typeof LgaNationalityScalarFieldEnum]


  export const CouncilInfoScalarFieldEnum: {
    lga_code: 'lga_code',
    council_name: 'council_name',
    council_info: 'council_info',
    address: 'address',
    suburb: 'suburb',
    postcode: 'postcode',
    phone: 'phone',
    email: 'email',
    website: 'website'
  };

  export type CouncilInfoScalarFieldEnum = (typeof CouncilInfoScalarFieldEnum)[keyof typeof CouncilInfoScalarFieldEnum]


  export const PostcodeScalarFieldEnum: {
    postcode: 'postcode',
    suburb: 'suburb',
    latitude: 'latitude',
    longitude: 'longitude',
    lga_code: 'lga_code'
  };

  export type PostcodeScalarFieldEnum = (typeof PostcodeScalarFieldEnum)[keyof typeof PostcodeScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    language_id: 'language_id',
    language: 'language'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const LgaLanguageProficiencyScalarFieldEnum: {
    lga_language_prof_id: 'lga_language_prof_id',
    lga_code: 'lga_code',
    language_id: 'language_id',
    english_profiency_level: 'english_profiency_level',
    count: 'count'
  };

  export type LgaLanguageProficiencyScalarFieldEnum = (typeof LgaLanguageProficiencyScalarFieldEnum)[keyof typeof LgaLanguageProficiencyScalarFieldEnum]


  export const LgaStatisticsScalarFieldEnum: {
    lga_code: 'lga_code',
    total_businesses: 'total_businesses',
    total_employed_over_15: 'total_employed_over_15',
    born_overseas: 'born_overseas',
    pct_arrived_within_5_years: 'pct_arrived_within_5_years',
    pct_proficient_english: 'pct_proficient_english',
    percent_speaks_other_lang_at_home: 'percent_speaks_other_lang_at_home',
    median_age_years: 'median_age_years',
    pct_completed_year_12: 'pct_completed_year_12',
    pct_certificate: 'pct_certificate',
    pct_bachelor_degree: 'pct_bachelor_degree',
    pct_postgraduate: 'pct_postgraduate',
    pct_managers: 'pct_managers',
    pct_professionals: 'pct_professionals',
    pct_labourers: 'pct_labourers'
  };

  export type LgaStatisticsScalarFieldEnum = (typeof LgaStatisticsScalarFieldEnum)[keyof typeof LgaStatisticsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    venue_id?: StringFilter<"Venue"> | string
    venue_name?: StringFilter<"Venue"> | string
    venue_address?: StringFilter<"Venue"> | string
    venue_city?: StringFilter<"Venue"> | string
    venue_latitude?: FloatFilter<"Venue"> | number
    venue_longitude?: FloatFilter<"Venue"> | number
    venue_postcode?: IntFilter<"Venue"> | number
    events?: EventListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    venue_id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    venue_city?: SortOrder
    venue_latitude?: SortOrder
    venue_longitude?: SortOrder
    venue_postcode?: SortOrder
    events?: EventOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    venue_id?: string
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    venue_name?: StringFilter<"Venue"> | string
    venue_address?: StringFilter<"Venue"> | string
    venue_city?: StringFilter<"Venue"> | string
    venue_latitude?: FloatFilter<"Venue"> | number
    venue_longitude?: FloatFilter<"Venue"> | number
    venue_postcode?: IntFilter<"Venue"> | number
    events?: EventListRelationFilter
  }, "venue_id">

  export type VenueOrderByWithAggregationInput = {
    venue_id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    venue_city?: SortOrder
    venue_latitude?: SortOrder
    venue_longitude?: SortOrder
    venue_postcode?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    venue_id?: StringWithAggregatesFilter<"Venue"> | string
    venue_name?: StringWithAggregatesFilter<"Venue"> | string
    venue_address?: StringWithAggregatesFilter<"Venue"> | string
    venue_city?: StringWithAggregatesFilter<"Venue"> | string
    venue_latitude?: FloatWithAggregatesFilter<"Venue"> | number
    venue_longitude?: FloatWithAggregatesFilter<"Venue"> | number
    venue_postcode?: IntWithAggregatesFilter<"Venue"> | number
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    category_id?: StringFilter<"Category"> | string
    category_name?: StringFilter<"Category"> | string
    events?: EventListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    category_id?: SortOrder
    category_name?: SortOrder
    events?: EventOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    category_id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    category_name?: StringFilter<"Category"> | string
    events?: EventListRelationFilter
  }, "category_id">

  export type CategoryOrderByWithAggregationInput = {
    category_id?: SortOrder
    category_name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    category_id?: StringWithAggregatesFilter<"Category"> | string
    category_name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type OrganizerWhereInput = {
    AND?: OrganizerWhereInput | OrganizerWhereInput[]
    OR?: OrganizerWhereInput[]
    NOT?: OrganizerWhereInput | OrganizerWhereInput[]
    organizer_id?: StringFilter<"Organizer"> | string
    organizer_name?: StringFilter<"Organizer"> | string
    organizer_url?: StringFilter<"Organizer"> | string
    events?: EventListRelationFilter
  }

  export type OrganizerOrderByWithRelationInput = {
    organizer_id?: SortOrder
    organizer_name?: SortOrder
    organizer_url?: SortOrder
    events?: EventOrderByRelationAggregateInput
  }

  export type OrganizerWhereUniqueInput = Prisma.AtLeast<{
    organizer_id?: string
    AND?: OrganizerWhereInput | OrganizerWhereInput[]
    OR?: OrganizerWhereInput[]
    NOT?: OrganizerWhereInput | OrganizerWhereInput[]
    organizer_name?: StringFilter<"Organizer"> | string
    organizer_url?: StringFilter<"Organizer"> | string
    events?: EventListRelationFilter
  }, "organizer_id">

  export type OrganizerOrderByWithAggregationInput = {
    organizer_id?: SortOrder
    organizer_name?: SortOrder
    organizer_url?: SortOrder
    _count?: OrganizerCountOrderByAggregateInput
    _max?: OrganizerMaxOrderByAggregateInput
    _min?: OrganizerMinOrderByAggregateInput
  }

  export type OrganizerScalarWhereWithAggregatesInput = {
    AND?: OrganizerScalarWhereWithAggregatesInput | OrganizerScalarWhereWithAggregatesInput[]
    OR?: OrganizerScalarWhereWithAggregatesInput[]
    NOT?: OrganizerScalarWhereWithAggregatesInput | OrganizerScalarWhereWithAggregatesInput[]
    organizer_id?: StringWithAggregatesFilter<"Organizer"> | string
    organizer_name?: StringWithAggregatesFilter<"Organizer"> | string
    organizer_url?: StringWithAggregatesFilter<"Organizer"> | string
  }

  export type LogoWhereInput = {
    AND?: LogoWhereInput | LogoWhereInput[]
    OR?: LogoWhereInput[]
    NOT?: LogoWhereInput | LogoWhereInput[]
    logo_id?: BigIntFilter<"Logo"> | bigint | number
    logo_url?: StringFilter<"Logo"> | string
    logo_width?: IntFilter<"Logo"> | number
    logo_height?: IntFilter<"Logo"> | number
    logo_aspect_ratio?: FloatFilter<"Logo"> | number
    events?: EventListRelationFilter
  }

  export type LogoOrderByWithRelationInput = {
    logo_id?: SortOrder
    logo_url?: SortOrder
    logo_width?: SortOrder
    logo_height?: SortOrder
    logo_aspect_ratio?: SortOrder
    events?: EventOrderByRelationAggregateInput
  }

  export type LogoWhereUniqueInput = Prisma.AtLeast<{
    logo_id?: bigint | number
    AND?: LogoWhereInput | LogoWhereInput[]
    OR?: LogoWhereInput[]
    NOT?: LogoWhereInput | LogoWhereInput[]
    logo_url?: StringFilter<"Logo"> | string
    logo_width?: IntFilter<"Logo"> | number
    logo_height?: IntFilter<"Logo"> | number
    logo_aspect_ratio?: FloatFilter<"Logo"> | number
    events?: EventListRelationFilter
  }, "logo_id">

  export type LogoOrderByWithAggregationInput = {
    logo_id?: SortOrder
    logo_url?: SortOrder
    logo_width?: SortOrder
    logo_height?: SortOrder
    logo_aspect_ratio?: SortOrder
    _count?: LogoCountOrderByAggregateInput
    _avg?: LogoAvgOrderByAggregateInput
    _max?: LogoMaxOrderByAggregateInput
    _min?: LogoMinOrderByAggregateInput
    _sum?: LogoSumOrderByAggregateInput
  }

  export type LogoScalarWhereWithAggregatesInput = {
    AND?: LogoScalarWhereWithAggregatesInput | LogoScalarWhereWithAggregatesInput[]
    OR?: LogoScalarWhereWithAggregatesInput[]
    NOT?: LogoScalarWhereWithAggregatesInput | LogoScalarWhereWithAggregatesInput[]
    logo_id?: BigIntWithAggregatesFilter<"Logo"> | bigint | number
    logo_url?: StringWithAggregatesFilter<"Logo"> | string
    logo_width?: IntWithAggregatesFilter<"Logo"> | number
    logo_height?: IntWithAggregatesFilter<"Logo"> | number
    logo_aspect_ratio?: FloatWithAggregatesFilter<"Logo"> | number
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    event_id?: StringFilter<"Event"> | string
    event_name?: StringFilter<"Event"> | string
    event_description?: StringFilter<"Event"> | string
    start_datetime?: DateTimeFilter<"Event"> | Date | string
    end_datetime?: DateTimeFilter<"Event"> | Date | string
    event_summary?: StringFilter<"Event"> | string
    category_id?: StringNullableFilter<"Event"> | string | null
    organizer_id?: StringNullableFilter<"Event"> | string | null
    venue_id?: StringNullableFilter<"Event"> | string | null
    logo_id?: BigIntNullableFilter<"Event"> | bigint | number | null
    event_status?: StringFilter<"Event"> | string
    event_url?: StringNullableFilter<"Event"> | string | null
    is_free_event?: BoolFilter<"Event"> | boolean
    community_friendly?: BoolFilter<"Event"> | boolean
    predicted_community_friendly?: BoolFilter<"Event"> | boolean
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    logo?: XOR<LogoNullableScalarRelationFilter, LogoWhereInput> | null
    organizer?: XOR<OrganizerNullableScalarRelationFilter, OrganizerWhereInput> | null
    venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
    websites?: WebsiteListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    start_datetime?: SortOrder
    end_datetime?: SortOrder
    event_summary?: SortOrder
    category_id?: SortOrderInput | SortOrder
    organizer_id?: SortOrderInput | SortOrder
    venue_id?: SortOrderInput | SortOrder
    logo_id?: SortOrderInput | SortOrder
    event_status?: SortOrder
    event_url?: SortOrderInput | SortOrder
    is_free_event?: SortOrder
    community_friendly?: SortOrder
    predicted_community_friendly?: SortOrder
    category?: CategoryOrderByWithRelationInput
    logo?: LogoOrderByWithRelationInput
    organizer?: OrganizerOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    websites?: WebsiteOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    event_id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    event_name?: StringFilter<"Event"> | string
    event_description?: StringFilter<"Event"> | string
    start_datetime?: DateTimeFilter<"Event"> | Date | string
    end_datetime?: DateTimeFilter<"Event"> | Date | string
    event_summary?: StringFilter<"Event"> | string
    category_id?: StringNullableFilter<"Event"> | string | null
    organizer_id?: StringNullableFilter<"Event"> | string | null
    venue_id?: StringNullableFilter<"Event"> | string | null
    logo_id?: BigIntNullableFilter<"Event"> | bigint | number | null
    event_status?: StringFilter<"Event"> | string
    event_url?: StringNullableFilter<"Event"> | string | null
    is_free_event?: BoolFilter<"Event"> | boolean
    community_friendly?: BoolFilter<"Event"> | boolean
    predicted_community_friendly?: BoolFilter<"Event"> | boolean
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    logo?: XOR<LogoNullableScalarRelationFilter, LogoWhereInput> | null
    organizer?: XOR<OrganizerNullableScalarRelationFilter, OrganizerWhereInput> | null
    venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
    websites?: WebsiteListRelationFilter
  }, "event_id">

  export type EventOrderByWithAggregationInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    start_datetime?: SortOrder
    end_datetime?: SortOrder
    event_summary?: SortOrder
    category_id?: SortOrderInput | SortOrder
    organizer_id?: SortOrderInput | SortOrder
    venue_id?: SortOrderInput | SortOrder
    logo_id?: SortOrderInput | SortOrder
    event_status?: SortOrder
    event_url?: SortOrderInput | SortOrder
    is_free_event?: SortOrder
    community_friendly?: SortOrder
    predicted_community_friendly?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    event_id?: StringWithAggregatesFilter<"Event"> | string
    event_name?: StringWithAggregatesFilter<"Event"> | string
    event_description?: StringWithAggregatesFilter<"Event"> | string
    start_datetime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    end_datetime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    event_summary?: StringWithAggregatesFilter<"Event"> | string
    category_id?: StringNullableWithAggregatesFilter<"Event"> | string | null
    organizer_id?: StringNullableWithAggregatesFilter<"Event"> | string | null
    venue_id?: StringNullableWithAggregatesFilter<"Event"> | string | null
    logo_id?: BigIntNullableWithAggregatesFilter<"Event"> | bigint | number | null
    event_status?: StringWithAggregatesFilter<"Event"> | string
    event_url?: StringNullableWithAggregatesFilter<"Event"> | string | null
    is_free_event?: BoolWithAggregatesFilter<"Event"> | boolean
    community_friendly?: BoolWithAggregatesFilter<"Event"> | boolean
    predicted_community_friendly?: BoolWithAggregatesFilter<"Event"> | boolean
  }

  export type WebsiteWhereInput = {
    AND?: WebsiteWhereInput | WebsiteWhereInput[]
    OR?: WebsiteWhereInput[]
    NOT?: WebsiteWhereInput | WebsiteWhereInput[]
    event_url?: StringFilter<"Website"> | string
    event_id?: StringFilter<"Website"> | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type WebsiteOrderByWithRelationInput = {
    event_url?: SortOrder
    event_id?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type WebsiteWhereUniqueInput = Prisma.AtLeast<{
    event_url?: string
    AND?: WebsiteWhereInput | WebsiteWhereInput[]
    OR?: WebsiteWhereInput[]
    NOT?: WebsiteWhereInput | WebsiteWhereInput[]
    event_id?: StringFilter<"Website"> | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "event_url">

  export type WebsiteOrderByWithAggregationInput = {
    event_url?: SortOrder
    event_id?: SortOrder
    _count?: WebsiteCountOrderByAggregateInput
    _max?: WebsiteMaxOrderByAggregateInput
    _min?: WebsiteMinOrderByAggregateInput
  }

  export type WebsiteScalarWhereWithAggregatesInput = {
    AND?: WebsiteScalarWhereWithAggregatesInput | WebsiteScalarWhereWithAggregatesInput[]
    OR?: WebsiteScalarWhereWithAggregatesInput[]
    NOT?: WebsiteScalarWhereWithAggregatesInput | WebsiteScalarWhereWithAggregatesInput[]
    event_url?: StringWithAggregatesFilter<"Website"> | string
    event_id?: StringWithAggregatesFilter<"Website"> | string
  }

  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    provider_id?: IntFilter<"Provider"> | number
    provider_name?: StringFilter<"Provider"> | string
    site_name?: StringFilter<"Provider"> | string
    government_subsidised?: StringFilter<"Provider"> | string
    subsidy_tag?: StringNullableFilter<"Provider"> | string | null
    asqa_code?: IntFilter<"Provider"> | number
    url?: StringNullableFilter<"Provider"> | string | null
    email?: StringNullableFilter<"Provider"> | string | null
    courses?: CourseListRelationFilter
    locations?: LocationListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    provider_id?: SortOrder
    provider_name?: SortOrder
    site_name?: SortOrder
    government_subsidised?: SortOrder
    subsidy_tag?: SortOrderInput | SortOrder
    asqa_code?: SortOrder
    url?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    courses?: CourseOrderByRelationAggregateInput
    locations?: LocationOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    provider_id?: number
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    provider_name?: StringFilter<"Provider"> | string
    site_name?: StringFilter<"Provider"> | string
    government_subsidised?: StringFilter<"Provider"> | string
    subsidy_tag?: StringNullableFilter<"Provider"> | string | null
    asqa_code?: IntFilter<"Provider"> | number
    url?: StringNullableFilter<"Provider"> | string | null
    email?: StringNullableFilter<"Provider"> | string | null
    courses?: CourseListRelationFilter
    locations?: LocationListRelationFilter
  }, "provider_id">

  export type ProviderOrderByWithAggregationInput = {
    provider_id?: SortOrder
    provider_name?: SortOrder
    site_name?: SortOrder
    government_subsidised?: SortOrder
    subsidy_tag?: SortOrderInput | SortOrder
    asqa_code?: SortOrder
    url?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _avg?: ProviderAvgOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
    _sum?: ProviderSumOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    provider_id?: IntWithAggregatesFilter<"Provider"> | number
    provider_name?: StringWithAggregatesFilter<"Provider"> | string
    site_name?: StringWithAggregatesFilter<"Provider"> | string
    government_subsidised?: StringWithAggregatesFilter<"Provider"> | string
    subsidy_tag?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    asqa_code?: IntWithAggregatesFilter<"Provider"> | number
    url?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    email?: StringNullableWithAggregatesFilter<"Provider"> | string | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    geographic_id?: IntFilter<"Location"> | number
    provider_id?: IntFilter<"Location"> | number
    address_line_1?: StringFilter<"Location"> | string
    suburb?: StringFilter<"Location"> | string
    postcode?: IntFilter<"Location"> | number
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    full_address?: StringFilter<"Location"> | string
    region_name?: StringFilter<"Location"> | string
    local_government_authority?: StringFilter<"Location"> | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type LocationOrderByWithRelationInput = {
    geographic_id?: SortOrder
    provider_id?: SortOrder
    address_line_1?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    full_address?: SortOrder
    region_name?: SortOrder
    local_government_authority?: SortOrder
    provider?: ProviderOrderByWithRelationInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    geographic_id?: number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    provider_id?: IntFilter<"Location"> | number
    address_line_1?: StringFilter<"Location"> | string
    suburb?: StringFilter<"Location"> | string
    postcode?: IntFilter<"Location"> | number
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    full_address?: StringFilter<"Location"> | string
    region_name?: StringFilter<"Location"> | string
    local_government_authority?: StringFilter<"Location"> | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "geographic_id">

  export type LocationOrderByWithAggregationInput = {
    geographic_id?: SortOrder
    provider_id?: SortOrder
    address_line_1?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    full_address?: SortOrder
    region_name?: SortOrder
    local_government_authority?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    geographic_id?: IntWithAggregatesFilter<"Location"> | number
    provider_id?: IntWithAggregatesFilter<"Location"> | number
    address_line_1?: StringWithAggregatesFilter<"Location"> | string
    suburb?: StringWithAggregatesFilter<"Location"> | string
    postcode?: IntWithAggregatesFilter<"Location"> | number
    latitude?: FloatWithAggregatesFilter<"Location"> | number
    longitude?: FloatWithAggregatesFilter<"Location"> | number
    full_address?: StringWithAggregatesFilter<"Location"> | string
    region_name?: StringWithAggregatesFilter<"Location"> | string
    local_government_authority?: StringWithAggregatesFilter<"Location"> | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    course_id?: IntFilter<"Course"> | number
    provider_id?: IntFilter<"Course"> | number
    course_title?: StringFilter<"Course"> | string
    course_code?: StringFilter<"Course"> | string
    qualification_level?: StringFilter<"Course"> | string
    course_type?: StringFilter<"Course"> | string
    government_subsidised?: BoolFilter<"Course"> | boolean
    apprenticeship?: BoolFilter<"Course"> | boolean
    traineeship?: BoolFilter<"Course"> | boolean
    entry_requirements?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    is_english_course?: BoolFilter<"Course"> | boolean
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type CourseOrderByWithRelationInput = {
    course_id?: SortOrder
    provider_id?: SortOrder
    course_title?: SortOrder
    course_code?: SortOrder
    qualification_level?: SortOrder
    course_type?: SortOrder
    government_subsidised?: SortOrder
    apprenticeship?: SortOrder
    traineeship?: SortOrder
    entry_requirements?: SortOrder
    description?: SortOrder
    is_english_course?: SortOrder
    provider?: ProviderOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    course_id?: number
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    provider_id?: IntFilter<"Course"> | number
    course_title?: StringFilter<"Course"> | string
    course_code?: StringFilter<"Course"> | string
    qualification_level?: StringFilter<"Course"> | string
    course_type?: StringFilter<"Course"> | string
    government_subsidised?: BoolFilter<"Course"> | boolean
    apprenticeship?: BoolFilter<"Course"> | boolean
    traineeship?: BoolFilter<"Course"> | boolean
    entry_requirements?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    is_english_course?: BoolFilter<"Course"> | boolean
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "course_id">

  export type CourseOrderByWithAggregationInput = {
    course_id?: SortOrder
    provider_id?: SortOrder
    course_title?: SortOrder
    course_code?: SortOrder
    qualification_level?: SortOrder
    course_type?: SortOrder
    government_subsidised?: SortOrder
    apprenticeship?: SortOrder
    traineeship?: SortOrder
    entry_requirements?: SortOrder
    description?: SortOrder
    is_english_course?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    course_id?: IntWithAggregatesFilter<"Course"> | number
    provider_id?: IntWithAggregatesFilter<"Course"> | number
    course_title?: StringWithAggregatesFilter<"Course"> | string
    course_code?: StringWithAggregatesFilter<"Course"> | string
    qualification_level?: StringWithAggregatesFilter<"Course"> | string
    course_type?: StringWithAggregatesFilter<"Course"> | string
    government_subsidised?: BoolWithAggregatesFilter<"Course"> | boolean
    apprenticeship?: BoolWithAggregatesFilter<"Course"> | boolean
    traineeship?: BoolWithAggregatesFilter<"Course"> | boolean
    entry_requirements?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    is_english_course?: BoolWithAggregatesFilter<"Course"> | boolean
  }

  export type LgaWhereInput = {
    AND?: LgaWhereInput | LgaWhereInput[]
    OR?: LgaWhereInput[]
    NOT?: LgaWhereInput | LgaWhereInput[]
    lga_code?: IntFilter<"Lga"> | number
    lga_name?: StringFilter<"Lga"> | string
    council_info?: XOR<CouncilInfoNullableScalarRelationFilter, CouncilInfoWhereInput> | null
    language_proficiencies?: LgaLanguageProficiencyListRelationFilter
    lga_nationalities?: LgaNationalityListRelationFilter
    statistics?: XOR<LgaStatisticsNullableScalarRelationFilter, LgaStatisticsWhereInput> | null
    postcodes?: PostcodeListRelationFilter
  }

  export type LgaOrderByWithRelationInput = {
    lga_code?: SortOrder
    lga_name?: SortOrder
    council_info?: CouncilInfoOrderByWithRelationInput
    language_proficiencies?: LgaLanguageProficiencyOrderByRelationAggregateInput
    lga_nationalities?: LgaNationalityOrderByRelationAggregateInput
    statistics?: LgaStatisticsOrderByWithRelationInput
    postcodes?: PostcodeOrderByRelationAggregateInput
  }

  export type LgaWhereUniqueInput = Prisma.AtLeast<{
    lga_code?: number
    AND?: LgaWhereInput | LgaWhereInput[]
    OR?: LgaWhereInput[]
    NOT?: LgaWhereInput | LgaWhereInput[]
    lga_name?: StringFilter<"Lga"> | string
    council_info?: XOR<CouncilInfoNullableScalarRelationFilter, CouncilInfoWhereInput> | null
    language_proficiencies?: LgaLanguageProficiencyListRelationFilter
    lga_nationalities?: LgaNationalityListRelationFilter
    statistics?: XOR<LgaStatisticsNullableScalarRelationFilter, LgaStatisticsWhereInput> | null
    postcodes?: PostcodeListRelationFilter
  }, "lga_code">

  export type LgaOrderByWithAggregationInput = {
    lga_code?: SortOrder
    lga_name?: SortOrder
    _count?: LgaCountOrderByAggregateInput
    _avg?: LgaAvgOrderByAggregateInput
    _max?: LgaMaxOrderByAggregateInput
    _min?: LgaMinOrderByAggregateInput
    _sum?: LgaSumOrderByAggregateInput
  }

  export type LgaScalarWhereWithAggregatesInput = {
    AND?: LgaScalarWhereWithAggregatesInput | LgaScalarWhereWithAggregatesInput[]
    OR?: LgaScalarWhereWithAggregatesInput[]
    NOT?: LgaScalarWhereWithAggregatesInput | LgaScalarWhereWithAggregatesInput[]
    lga_code?: IntWithAggregatesFilter<"Lga"> | number
    lga_name?: StringWithAggregatesFilter<"Lga"> | string
  }

  export type NationalityWhereInput = {
    AND?: NationalityWhereInput | NationalityWhereInput[]
    OR?: NationalityWhereInput[]
    NOT?: NationalityWhereInput | NationalityWhereInput[]
    nationality_id?: IntFilter<"Nationality"> | number
    nationality?: StringFilter<"Nationality"> | string
    lga_nationalities?: LgaNationalityListRelationFilter
  }

  export type NationalityOrderByWithRelationInput = {
    nationality_id?: SortOrder
    nationality?: SortOrder
    lga_nationalities?: LgaNationalityOrderByRelationAggregateInput
  }

  export type NationalityWhereUniqueInput = Prisma.AtLeast<{
    nationality_id?: number
    nationality?: string
    AND?: NationalityWhereInput | NationalityWhereInput[]
    OR?: NationalityWhereInput[]
    NOT?: NationalityWhereInput | NationalityWhereInput[]
    lga_nationalities?: LgaNationalityListRelationFilter
  }, "nationality_id" | "nationality">

  export type NationalityOrderByWithAggregationInput = {
    nationality_id?: SortOrder
    nationality?: SortOrder
    _count?: NationalityCountOrderByAggregateInput
    _avg?: NationalityAvgOrderByAggregateInput
    _max?: NationalityMaxOrderByAggregateInput
    _min?: NationalityMinOrderByAggregateInput
    _sum?: NationalitySumOrderByAggregateInput
  }

  export type NationalityScalarWhereWithAggregatesInput = {
    AND?: NationalityScalarWhereWithAggregatesInput | NationalityScalarWhereWithAggregatesInput[]
    OR?: NationalityScalarWhereWithAggregatesInput[]
    NOT?: NationalityScalarWhereWithAggregatesInput | NationalityScalarWhereWithAggregatesInput[]
    nationality_id?: IntWithAggregatesFilter<"Nationality"> | number
    nationality?: StringWithAggregatesFilter<"Nationality"> | string
  }

  export type LgaNationalityWhereInput = {
    AND?: LgaNationalityWhereInput | LgaNationalityWhereInput[]
    OR?: LgaNationalityWhereInput[]
    NOT?: LgaNationalityWhereInput | LgaNationalityWhereInput[]
    lga_nationality_id?: IntFilter<"LgaNationality"> | number
    lga_code?: IntFilter<"LgaNationality"> | number
    nationality_id?: IntFilter<"LgaNationality"> | number
    count?: IntFilter<"LgaNationality"> | number
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
    nationality?: XOR<NationalityScalarRelationFilter, NationalityWhereInput>
  }

  export type LgaNationalityOrderByWithRelationInput = {
    lga_nationality_id?: SortOrder
    lga_code?: SortOrder
    nationality_id?: SortOrder
    count?: SortOrder
    lga?: LgaOrderByWithRelationInput
    nationality?: NationalityOrderByWithRelationInput
  }

  export type LgaNationalityWhereUniqueInput = Prisma.AtLeast<{
    lga_nationality_id?: number
    AND?: LgaNationalityWhereInput | LgaNationalityWhereInput[]
    OR?: LgaNationalityWhereInput[]
    NOT?: LgaNationalityWhereInput | LgaNationalityWhereInput[]
    lga_code?: IntFilter<"LgaNationality"> | number
    nationality_id?: IntFilter<"LgaNationality"> | number
    count?: IntFilter<"LgaNationality"> | number
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
    nationality?: XOR<NationalityScalarRelationFilter, NationalityWhereInput>
  }, "lga_nationality_id">

  export type LgaNationalityOrderByWithAggregationInput = {
    lga_nationality_id?: SortOrder
    lga_code?: SortOrder
    nationality_id?: SortOrder
    count?: SortOrder
    _count?: LgaNationalityCountOrderByAggregateInput
    _avg?: LgaNationalityAvgOrderByAggregateInput
    _max?: LgaNationalityMaxOrderByAggregateInput
    _min?: LgaNationalityMinOrderByAggregateInput
    _sum?: LgaNationalitySumOrderByAggregateInput
  }

  export type LgaNationalityScalarWhereWithAggregatesInput = {
    AND?: LgaNationalityScalarWhereWithAggregatesInput | LgaNationalityScalarWhereWithAggregatesInput[]
    OR?: LgaNationalityScalarWhereWithAggregatesInput[]
    NOT?: LgaNationalityScalarWhereWithAggregatesInput | LgaNationalityScalarWhereWithAggregatesInput[]
    lga_nationality_id?: IntWithAggregatesFilter<"LgaNationality"> | number
    lga_code?: IntWithAggregatesFilter<"LgaNationality"> | number
    nationality_id?: IntWithAggregatesFilter<"LgaNationality"> | number
    count?: IntWithAggregatesFilter<"LgaNationality"> | number
  }

  export type CouncilInfoWhereInput = {
    AND?: CouncilInfoWhereInput | CouncilInfoWhereInput[]
    OR?: CouncilInfoWhereInput[]
    NOT?: CouncilInfoWhereInput | CouncilInfoWhereInput[]
    lga_code?: IntFilter<"CouncilInfo"> | number
    council_name?: StringNullableFilter<"CouncilInfo"> | string | null
    council_info?: StringNullableFilter<"CouncilInfo"> | string | null
    address?: StringNullableFilter<"CouncilInfo"> | string | null
    suburb?: StringNullableFilter<"CouncilInfo"> | string | null
    postcode?: IntNullableFilter<"CouncilInfo"> | number | null
    phone?: StringNullableFilter<"CouncilInfo"> | string | null
    email?: StringNullableFilter<"CouncilInfo"> | string | null
    website?: StringNullableFilter<"CouncilInfo"> | string | null
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }

  export type CouncilInfoOrderByWithRelationInput = {
    lga_code?: SortOrder
    council_name?: SortOrderInput | SortOrder
    council_info?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    suburb?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    lga?: LgaOrderByWithRelationInput
  }

  export type CouncilInfoWhereUniqueInput = Prisma.AtLeast<{
    lga_code?: number
    AND?: CouncilInfoWhereInput | CouncilInfoWhereInput[]
    OR?: CouncilInfoWhereInput[]
    NOT?: CouncilInfoWhereInput | CouncilInfoWhereInput[]
    council_name?: StringNullableFilter<"CouncilInfo"> | string | null
    council_info?: StringNullableFilter<"CouncilInfo"> | string | null
    address?: StringNullableFilter<"CouncilInfo"> | string | null
    suburb?: StringNullableFilter<"CouncilInfo"> | string | null
    postcode?: IntNullableFilter<"CouncilInfo"> | number | null
    phone?: StringNullableFilter<"CouncilInfo"> | string | null
    email?: StringNullableFilter<"CouncilInfo"> | string | null
    website?: StringNullableFilter<"CouncilInfo"> | string | null
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }, "lga_code">

  export type CouncilInfoOrderByWithAggregationInput = {
    lga_code?: SortOrder
    council_name?: SortOrderInput | SortOrder
    council_info?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    suburb?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    _count?: CouncilInfoCountOrderByAggregateInput
    _avg?: CouncilInfoAvgOrderByAggregateInput
    _max?: CouncilInfoMaxOrderByAggregateInput
    _min?: CouncilInfoMinOrderByAggregateInput
    _sum?: CouncilInfoSumOrderByAggregateInput
  }

  export type CouncilInfoScalarWhereWithAggregatesInput = {
    AND?: CouncilInfoScalarWhereWithAggregatesInput | CouncilInfoScalarWhereWithAggregatesInput[]
    OR?: CouncilInfoScalarWhereWithAggregatesInput[]
    NOT?: CouncilInfoScalarWhereWithAggregatesInput | CouncilInfoScalarWhereWithAggregatesInput[]
    lga_code?: IntWithAggregatesFilter<"CouncilInfo"> | number
    council_name?: StringNullableWithAggregatesFilter<"CouncilInfo"> | string | null
    council_info?: StringNullableWithAggregatesFilter<"CouncilInfo"> | string | null
    address?: StringNullableWithAggregatesFilter<"CouncilInfo"> | string | null
    suburb?: StringNullableWithAggregatesFilter<"CouncilInfo"> | string | null
    postcode?: IntNullableWithAggregatesFilter<"CouncilInfo"> | number | null
    phone?: StringNullableWithAggregatesFilter<"CouncilInfo"> | string | null
    email?: StringNullableWithAggregatesFilter<"CouncilInfo"> | string | null
    website?: StringNullableWithAggregatesFilter<"CouncilInfo"> | string | null
  }

  export type PostcodeWhereInput = {
    AND?: PostcodeWhereInput | PostcodeWhereInput[]
    OR?: PostcodeWhereInput[]
    NOT?: PostcodeWhereInput | PostcodeWhereInput[]
    postcode?: IntFilter<"Postcode"> | number
    suburb?: StringFilter<"Postcode"> | string
    latitude?: FloatFilter<"Postcode"> | number
    longitude?: FloatFilter<"Postcode"> | number
    lga_code?: IntFilter<"Postcode"> | number
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }

  export type PostcodeOrderByWithRelationInput = {
    postcode?: SortOrder
    suburb?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lga_code?: SortOrder
    lga?: LgaOrderByWithRelationInput
  }

  export type PostcodeWhereUniqueInput = Prisma.AtLeast<{
    postcode?: number
    AND?: PostcodeWhereInput | PostcodeWhereInput[]
    OR?: PostcodeWhereInput[]
    NOT?: PostcodeWhereInput | PostcodeWhereInput[]
    suburb?: StringFilter<"Postcode"> | string
    latitude?: FloatFilter<"Postcode"> | number
    longitude?: FloatFilter<"Postcode"> | number
    lga_code?: IntFilter<"Postcode"> | number
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }, "postcode">

  export type PostcodeOrderByWithAggregationInput = {
    postcode?: SortOrder
    suburb?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lga_code?: SortOrder
    _count?: PostcodeCountOrderByAggregateInput
    _avg?: PostcodeAvgOrderByAggregateInput
    _max?: PostcodeMaxOrderByAggregateInput
    _min?: PostcodeMinOrderByAggregateInput
    _sum?: PostcodeSumOrderByAggregateInput
  }

  export type PostcodeScalarWhereWithAggregatesInput = {
    AND?: PostcodeScalarWhereWithAggregatesInput | PostcodeScalarWhereWithAggregatesInput[]
    OR?: PostcodeScalarWhereWithAggregatesInput[]
    NOT?: PostcodeScalarWhereWithAggregatesInput | PostcodeScalarWhereWithAggregatesInput[]
    postcode?: IntWithAggregatesFilter<"Postcode"> | number
    suburb?: StringWithAggregatesFilter<"Postcode"> | string
    latitude?: FloatWithAggregatesFilter<"Postcode"> | number
    longitude?: FloatWithAggregatesFilter<"Postcode"> | number
    lga_code?: IntWithAggregatesFilter<"Postcode"> | number
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    language_id?: IntFilter<"Language"> | number
    language?: StringNullableFilter<"Language"> | string | null
    proficiencies?: LgaLanguageProficiencyListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    language_id?: SortOrder
    language?: SortOrderInput | SortOrder
    proficiencies?: LgaLanguageProficiencyOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    language_id?: number
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    language?: StringNullableFilter<"Language"> | string | null
    proficiencies?: LgaLanguageProficiencyListRelationFilter
  }, "language_id">

  export type LanguageOrderByWithAggregationInput = {
    language_id?: SortOrder
    language?: SortOrderInput | SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    language_id?: IntWithAggregatesFilter<"Language"> | number
    language?: StringNullableWithAggregatesFilter<"Language"> | string | null
  }

  export type LgaLanguageProficiencyWhereInput = {
    AND?: LgaLanguageProficiencyWhereInput | LgaLanguageProficiencyWhereInput[]
    OR?: LgaLanguageProficiencyWhereInput[]
    NOT?: LgaLanguageProficiencyWhereInput | LgaLanguageProficiencyWhereInput[]
    lga_language_prof_id?: IntFilter<"LgaLanguageProficiency"> | number
    lga_code?: IntFilter<"LgaLanguageProficiency"> | number
    language_id?: IntFilter<"LgaLanguageProficiency"> | number
    english_profiency_level?: StringFilter<"LgaLanguageProficiency"> | string
    count?: IntFilter<"LgaLanguageProficiency"> | number
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }

  export type LgaLanguageProficiencyOrderByWithRelationInput = {
    lga_language_prof_id?: SortOrder
    lga_code?: SortOrder
    language_id?: SortOrder
    english_profiency_level?: SortOrder
    count?: SortOrder
    language?: LanguageOrderByWithRelationInput
    lga?: LgaOrderByWithRelationInput
  }

  export type LgaLanguageProficiencyWhereUniqueInput = Prisma.AtLeast<{
    lga_language_prof_id?: number
    AND?: LgaLanguageProficiencyWhereInput | LgaLanguageProficiencyWhereInput[]
    OR?: LgaLanguageProficiencyWhereInput[]
    NOT?: LgaLanguageProficiencyWhereInput | LgaLanguageProficiencyWhereInput[]
    lga_code?: IntFilter<"LgaLanguageProficiency"> | number
    language_id?: IntFilter<"LgaLanguageProficiency"> | number
    english_profiency_level?: StringFilter<"LgaLanguageProficiency"> | string
    count?: IntFilter<"LgaLanguageProficiency"> | number
    language?: XOR<LanguageScalarRelationFilter, LanguageWhereInput>
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }, "lga_language_prof_id">

  export type LgaLanguageProficiencyOrderByWithAggregationInput = {
    lga_language_prof_id?: SortOrder
    lga_code?: SortOrder
    language_id?: SortOrder
    english_profiency_level?: SortOrder
    count?: SortOrder
    _count?: LgaLanguageProficiencyCountOrderByAggregateInput
    _avg?: LgaLanguageProficiencyAvgOrderByAggregateInput
    _max?: LgaLanguageProficiencyMaxOrderByAggregateInput
    _min?: LgaLanguageProficiencyMinOrderByAggregateInput
    _sum?: LgaLanguageProficiencySumOrderByAggregateInput
  }

  export type LgaLanguageProficiencyScalarWhereWithAggregatesInput = {
    AND?: LgaLanguageProficiencyScalarWhereWithAggregatesInput | LgaLanguageProficiencyScalarWhereWithAggregatesInput[]
    OR?: LgaLanguageProficiencyScalarWhereWithAggregatesInput[]
    NOT?: LgaLanguageProficiencyScalarWhereWithAggregatesInput | LgaLanguageProficiencyScalarWhereWithAggregatesInput[]
    lga_language_prof_id?: IntWithAggregatesFilter<"LgaLanguageProficiency"> | number
    lga_code?: IntWithAggregatesFilter<"LgaLanguageProficiency"> | number
    language_id?: IntWithAggregatesFilter<"LgaLanguageProficiency"> | number
    english_profiency_level?: StringWithAggregatesFilter<"LgaLanguageProficiency"> | string
    count?: IntWithAggregatesFilter<"LgaLanguageProficiency"> | number
  }

  export type LgaStatisticsWhereInput = {
    AND?: LgaStatisticsWhereInput | LgaStatisticsWhereInput[]
    OR?: LgaStatisticsWhereInput[]
    NOT?: LgaStatisticsWhereInput | LgaStatisticsWhereInput[]
    lga_code?: IntFilter<"LgaStatistics"> | number
    total_businesses?: IntNullableFilter<"LgaStatistics"> | number | null
    total_employed_over_15?: IntNullableFilter<"LgaStatistics"> | number | null
    born_overseas?: IntNullableFilter<"LgaStatistics"> | number | null
    pct_arrived_within_5_years?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_proficient_english?: FloatNullableFilter<"LgaStatistics"> | number | null
    percent_speaks_other_lang_at_home?: FloatNullableFilter<"LgaStatistics"> | number | null
    median_age_years?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_completed_year_12?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_certificate?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_bachelor_degree?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_postgraduate?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_managers?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_professionals?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_labourers?: FloatNullableFilter<"LgaStatistics"> | number | null
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }

  export type LgaStatisticsOrderByWithRelationInput = {
    lga_code?: SortOrder
    total_businesses?: SortOrderInput | SortOrder
    total_employed_over_15?: SortOrderInput | SortOrder
    born_overseas?: SortOrderInput | SortOrder
    pct_arrived_within_5_years?: SortOrderInput | SortOrder
    pct_proficient_english?: SortOrderInput | SortOrder
    percent_speaks_other_lang_at_home?: SortOrderInput | SortOrder
    median_age_years?: SortOrderInput | SortOrder
    pct_completed_year_12?: SortOrderInput | SortOrder
    pct_certificate?: SortOrderInput | SortOrder
    pct_bachelor_degree?: SortOrderInput | SortOrder
    pct_postgraduate?: SortOrderInput | SortOrder
    pct_managers?: SortOrderInput | SortOrder
    pct_professionals?: SortOrderInput | SortOrder
    pct_labourers?: SortOrderInput | SortOrder
    lga?: LgaOrderByWithRelationInput
  }

  export type LgaStatisticsWhereUniqueInput = Prisma.AtLeast<{
    lga_code?: number
    AND?: LgaStatisticsWhereInput | LgaStatisticsWhereInput[]
    OR?: LgaStatisticsWhereInput[]
    NOT?: LgaStatisticsWhereInput | LgaStatisticsWhereInput[]
    total_businesses?: IntNullableFilter<"LgaStatistics"> | number | null
    total_employed_over_15?: IntNullableFilter<"LgaStatistics"> | number | null
    born_overseas?: IntNullableFilter<"LgaStatistics"> | number | null
    pct_arrived_within_5_years?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_proficient_english?: FloatNullableFilter<"LgaStatistics"> | number | null
    percent_speaks_other_lang_at_home?: FloatNullableFilter<"LgaStatistics"> | number | null
    median_age_years?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_completed_year_12?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_certificate?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_bachelor_degree?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_postgraduate?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_managers?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_professionals?: FloatNullableFilter<"LgaStatistics"> | number | null
    pct_labourers?: FloatNullableFilter<"LgaStatistics"> | number | null
    lga?: XOR<LgaScalarRelationFilter, LgaWhereInput>
  }, "lga_code">

  export type LgaStatisticsOrderByWithAggregationInput = {
    lga_code?: SortOrder
    total_businesses?: SortOrderInput | SortOrder
    total_employed_over_15?: SortOrderInput | SortOrder
    born_overseas?: SortOrderInput | SortOrder
    pct_arrived_within_5_years?: SortOrderInput | SortOrder
    pct_proficient_english?: SortOrderInput | SortOrder
    percent_speaks_other_lang_at_home?: SortOrderInput | SortOrder
    median_age_years?: SortOrderInput | SortOrder
    pct_completed_year_12?: SortOrderInput | SortOrder
    pct_certificate?: SortOrderInput | SortOrder
    pct_bachelor_degree?: SortOrderInput | SortOrder
    pct_postgraduate?: SortOrderInput | SortOrder
    pct_managers?: SortOrderInput | SortOrder
    pct_professionals?: SortOrderInput | SortOrder
    pct_labourers?: SortOrderInput | SortOrder
    _count?: LgaStatisticsCountOrderByAggregateInput
    _avg?: LgaStatisticsAvgOrderByAggregateInput
    _max?: LgaStatisticsMaxOrderByAggregateInput
    _min?: LgaStatisticsMinOrderByAggregateInput
    _sum?: LgaStatisticsSumOrderByAggregateInput
  }

  export type LgaStatisticsScalarWhereWithAggregatesInput = {
    AND?: LgaStatisticsScalarWhereWithAggregatesInput | LgaStatisticsScalarWhereWithAggregatesInput[]
    OR?: LgaStatisticsScalarWhereWithAggregatesInput[]
    NOT?: LgaStatisticsScalarWhereWithAggregatesInput | LgaStatisticsScalarWhereWithAggregatesInput[]
    lga_code?: IntWithAggregatesFilter<"LgaStatistics"> | number
    total_businesses?: IntNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    total_employed_over_15?: IntNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    born_overseas?: IntNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_arrived_within_5_years?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_proficient_english?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    percent_speaks_other_lang_at_home?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    median_age_years?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_completed_year_12?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_certificate?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_bachelor_degree?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_postgraduate?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_managers?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_professionals?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
    pct_labourers?: FloatNullableWithAggregatesFilter<"LgaStatistics"> | number | null
  }

  export type VenueCreateInput = {
    venue_id: string
    venue_name: string
    venue_address: string
    venue_city: string
    venue_latitude: number
    venue_longitude: number
    venue_postcode: number
    events?: EventCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    venue_id: string
    venue_name: string
    venue_address: string
    venue_city: string
    venue_latitude: number
    venue_longitude: number
    venue_postcode: number
    events?: EventUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    venue_id?: StringFieldUpdateOperationsInput | string
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    venue_city?: StringFieldUpdateOperationsInput | string
    venue_latitude?: FloatFieldUpdateOperationsInput | number
    venue_longitude?: FloatFieldUpdateOperationsInput | number
    venue_postcode?: IntFieldUpdateOperationsInput | number
    events?: EventUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    venue_id?: StringFieldUpdateOperationsInput | string
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    venue_city?: StringFieldUpdateOperationsInput | string
    venue_latitude?: FloatFieldUpdateOperationsInput | number
    venue_longitude?: FloatFieldUpdateOperationsInput | number
    venue_postcode?: IntFieldUpdateOperationsInput | number
    events?: EventUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    venue_id: string
    venue_name: string
    venue_address: string
    venue_city: string
    venue_latitude: number
    venue_longitude: number
    venue_postcode: number
  }

  export type VenueUpdateManyMutationInput = {
    venue_id?: StringFieldUpdateOperationsInput | string
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    venue_city?: StringFieldUpdateOperationsInput | string
    venue_latitude?: FloatFieldUpdateOperationsInput | number
    venue_longitude?: FloatFieldUpdateOperationsInput | number
    venue_postcode?: IntFieldUpdateOperationsInput | number
  }

  export type VenueUncheckedUpdateManyInput = {
    venue_id?: StringFieldUpdateOperationsInput | string
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    venue_city?: StringFieldUpdateOperationsInput | string
    venue_latitude?: FloatFieldUpdateOperationsInput | number
    venue_longitude?: FloatFieldUpdateOperationsInput | number
    venue_postcode?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryCreateInput = {
    category_id: string
    category_name: string
    events?: EventCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    category_id: string
    category_name: string
    events?: EventUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    category_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
    events?: EventUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    category_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    category_id: string
    category_name: string
  }

  export type CategoryUpdateManyMutationInput = {
    category_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    category_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizerCreateInput = {
    organizer_id: string
    organizer_name: string
    organizer_url: string
    events?: EventCreateNestedManyWithoutOrganizerInput
  }

  export type OrganizerUncheckedCreateInput = {
    organizer_id: string
    organizer_name: string
    organizer_url: string
    events?: EventUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type OrganizerUpdateInput = {
    organizer_id?: StringFieldUpdateOperationsInput | string
    organizer_name?: StringFieldUpdateOperationsInput | string
    organizer_url?: StringFieldUpdateOperationsInput | string
    events?: EventUpdateManyWithoutOrganizerNestedInput
  }

  export type OrganizerUncheckedUpdateInput = {
    organizer_id?: StringFieldUpdateOperationsInput | string
    organizer_name?: StringFieldUpdateOperationsInput | string
    organizer_url?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type OrganizerCreateManyInput = {
    organizer_id: string
    organizer_name: string
    organizer_url: string
  }

  export type OrganizerUpdateManyMutationInput = {
    organizer_id?: StringFieldUpdateOperationsInput | string
    organizer_name?: StringFieldUpdateOperationsInput | string
    organizer_url?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizerUncheckedUpdateManyInput = {
    organizer_id?: StringFieldUpdateOperationsInput | string
    organizer_name?: StringFieldUpdateOperationsInput | string
    organizer_url?: StringFieldUpdateOperationsInput | string
  }

  export type LogoCreateInput = {
    logo_id: bigint | number
    logo_url: string
    logo_width: number
    logo_height: number
    logo_aspect_ratio: number
    events?: EventCreateNestedManyWithoutLogoInput
  }

  export type LogoUncheckedCreateInput = {
    logo_id: bigint | number
    logo_url: string
    logo_width: number
    logo_height: number
    logo_aspect_ratio: number
    events?: EventUncheckedCreateNestedManyWithoutLogoInput
  }

  export type LogoUpdateInput = {
    logo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    logo_url?: StringFieldUpdateOperationsInput | string
    logo_width?: IntFieldUpdateOperationsInput | number
    logo_height?: IntFieldUpdateOperationsInput | number
    logo_aspect_ratio?: FloatFieldUpdateOperationsInput | number
    events?: EventUpdateManyWithoutLogoNestedInput
  }

  export type LogoUncheckedUpdateInput = {
    logo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    logo_url?: StringFieldUpdateOperationsInput | string
    logo_width?: IntFieldUpdateOperationsInput | number
    logo_height?: IntFieldUpdateOperationsInput | number
    logo_aspect_ratio?: FloatFieldUpdateOperationsInput | number
    events?: EventUncheckedUpdateManyWithoutLogoNestedInput
  }

  export type LogoCreateManyInput = {
    logo_id: bigint | number
    logo_url: string
    logo_width: number
    logo_height: number
    logo_aspect_ratio: number
  }

  export type LogoUpdateManyMutationInput = {
    logo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    logo_url?: StringFieldUpdateOperationsInput | string
    logo_width?: IntFieldUpdateOperationsInput | number
    logo_height?: IntFieldUpdateOperationsInput | number
    logo_aspect_ratio?: FloatFieldUpdateOperationsInput | number
  }

  export type LogoUncheckedUpdateManyInput = {
    logo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    logo_url?: StringFieldUpdateOperationsInput | string
    logo_width?: IntFieldUpdateOperationsInput | number
    logo_height?: IntFieldUpdateOperationsInput | number
    logo_aspect_ratio?: FloatFieldUpdateOperationsInput | number
  }

  export type EventCreateInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    category?: CategoryCreateNestedOneWithoutEventsInput
    logo?: LogoCreateNestedOneWithoutEventsInput
    organizer?: OrganizerCreateNestedOneWithoutEventsInput
    venue?: VenueCreateNestedOneWithoutEventsInput
    websites?: WebsiteCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    organizer_id?: string | null
    venue_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    websites?: WebsiteUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneWithoutEventsNestedInput
    logo?: LogoUpdateOneWithoutEventsNestedInput
    organizer?: OrganizerUpdateOneWithoutEventsNestedInput
    venue?: VenueUpdateOneWithoutEventsNestedInput
    websites?: WebsiteUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    websites?: WebsiteUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    organizer_id?: string | null
    venue_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
  }

  export type EventUpdateManyMutationInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventUncheckedUpdateManyInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WebsiteCreateInput = {
    event_url: string
    event: EventCreateNestedOneWithoutWebsitesInput
  }

  export type WebsiteUncheckedCreateInput = {
    event_url: string
    event_id: string
  }

  export type WebsiteUpdateInput = {
    event_url?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutWebsitesNestedInput
  }

  export type WebsiteUncheckedUpdateInput = {
    event_url?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
  }

  export type WebsiteCreateManyInput = {
    event_url: string
    event_id: string
  }

  export type WebsiteUpdateManyMutationInput = {
    event_url?: StringFieldUpdateOperationsInput | string
  }

  export type WebsiteUncheckedUpdateManyInput = {
    event_url?: StringFieldUpdateOperationsInput | string
    event_id?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderCreateInput = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag?: string | null
    asqa_code: number
    url?: string | null
    email?: string | null
    courses?: CourseCreateNestedManyWithoutProviderInput
    locations?: LocationCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag?: string | null
    asqa_code: number
    url?: string | null
    email?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutProviderInput
    locations?: LocationUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutProviderNestedInput
    locations?: LocationUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutProviderNestedInput
    locations?: LocationUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag?: string | null
    asqa_code: number
    url?: string | null
    email?: string | null
  }

  export type ProviderUpdateManyMutationInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProviderUncheckedUpdateManyInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocationCreateInput = {
    geographic_id: number
    address_line_1: string
    suburb: string
    postcode: number
    latitude: number
    longitude: number
    full_address: string
    region_name: string
    local_government_authority: string
    provider: ProviderCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateInput = {
    geographic_id: number
    provider_id: number
    address_line_1: string
    suburb: string
    postcode: number
    latitude: number
    longitude: number
    full_address: string
    region_name: string
    local_government_authority: string
  }

  export type LocationUpdateInput = {
    geographic_id?: IntFieldUpdateOperationsInput | number
    address_line_1?: StringFieldUpdateOperationsInput | string
    suburb?: StringFieldUpdateOperationsInput | string
    postcode?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    full_address?: StringFieldUpdateOperationsInput | string
    region_name?: StringFieldUpdateOperationsInput | string
    local_government_authority?: StringFieldUpdateOperationsInput | string
    provider?: ProviderUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    geographic_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    address_line_1?: StringFieldUpdateOperationsInput | string
    suburb?: StringFieldUpdateOperationsInput | string
    postcode?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    full_address?: StringFieldUpdateOperationsInput | string
    region_name?: StringFieldUpdateOperationsInput | string
    local_government_authority?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateManyInput = {
    geographic_id: number
    provider_id: number
    address_line_1: string
    suburb: string
    postcode: number
    latitude: number
    longitude: number
    full_address: string
    region_name: string
    local_government_authority: string
  }

  export type LocationUpdateManyMutationInput = {
    geographic_id?: IntFieldUpdateOperationsInput | number
    address_line_1?: StringFieldUpdateOperationsInput | string
    suburb?: StringFieldUpdateOperationsInput | string
    postcode?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    full_address?: StringFieldUpdateOperationsInput | string
    region_name?: StringFieldUpdateOperationsInput | string
    local_government_authority?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyInput = {
    geographic_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    address_line_1?: StringFieldUpdateOperationsInput | string
    suburb?: StringFieldUpdateOperationsInput | string
    postcode?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    full_address?: StringFieldUpdateOperationsInput | string
    region_name?: StringFieldUpdateOperationsInput | string
    local_government_authority?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateInput = {
    course_id: number
    course_title: string
    course_code: string
    qualification_level: string
    course_type: string
    government_subsidised: boolean
    apprenticeship: boolean
    traineeship: boolean
    entry_requirements: string
    description: string
    is_english_course: boolean
    provider: ProviderCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateInput = {
    course_id: number
    provider_id: number
    course_title: string
    course_code: string
    qualification_level: string
    course_type: string
    government_subsidised: boolean
    apprenticeship: boolean
    traineeship: boolean
    entry_requirements: string
    description: string
    is_english_course: boolean
  }

  export type CourseUpdateInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_title?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    qualification_level?: StringFieldUpdateOperationsInput | string
    course_type?: StringFieldUpdateOperationsInput | string
    government_subsidised?: BoolFieldUpdateOperationsInput | boolean
    apprenticeship?: BoolFieldUpdateOperationsInput | boolean
    traineeship?: BoolFieldUpdateOperationsInput | boolean
    entry_requirements?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_english_course?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    course_title?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    qualification_level?: StringFieldUpdateOperationsInput | string
    course_type?: StringFieldUpdateOperationsInput | string
    government_subsidised?: BoolFieldUpdateOperationsInput | boolean
    apprenticeship?: BoolFieldUpdateOperationsInput | boolean
    traineeship?: BoolFieldUpdateOperationsInput | boolean
    entry_requirements?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_english_course?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCreateManyInput = {
    course_id: number
    provider_id: number
    course_title: string
    course_code: string
    qualification_level: string
    course_type: string
    government_subsidised: boolean
    apprenticeship: boolean
    traineeship: boolean
    entry_requirements: string
    description: string
    is_english_course: boolean
  }

  export type CourseUpdateManyMutationInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_title?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    qualification_level?: StringFieldUpdateOperationsInput | string
    course_type?: StringFieldUpdateOperationsInput | string
    government_subsidised?: BoolFieldUpdateOperationsInput | boolean
    apprenticeship?: BoolFieldUpdateOperationsInput | boolean
    traineeship?: BoolFieldUpdateOperationsInput | boolean
    entry_requirements?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_english_course?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUncheckedUpdateManyInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    provider_id?: IntFieldUpdateOperationsInput | number
    course_title?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    qualification_level?: StringFieldUpdateOperationsInput | string
    course_type?: StringFieldUpdateOperationsInput | string
    government_subsidised?: BoolFieldUpdateOperationsInput | boolean
    apprenticeship?: BoolFieldUpdateOperationsInput | boolean
    traineeship?: BoolFieldUpdateOperationsInput | boolean
    entry_requirements?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_english_course?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LgaCreateInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeCreateNestedManyWithoutLgaInput
  }

  export type LgaUncheckedCreateInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoUncheckedCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityUncheckedCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsUncheckedCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeUncheckedCreateNestedManyWithoutLgaInput
  }

  export type LgaUpdateInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUpdateManyWithoutLgaNestedInput
  }

  export type LgaUncheckedUpdateInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUncheckedUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUncheckedUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUncheckedUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUncheckedUpdateManyWithoutLgaNestedInput
  }

  export type LgaCreateManyInput = {
    lga_code: number
    lga_name: string
  }

  export type LgaUpdateManyMutationInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
  }

  export type LgaUncheckedUpdateManyInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
  }

  export type NationalityCreateInput = {
    nationality: string
    lga_nationalities?: LgaNationalityCreateNestedManyWithoutNationalityInput
  }

  export type NationalityUncheckedCreateInput = {
    nationality_id?: number
    nationality: string
    lga_nationalities?: LgaNationalityUncheckedCreateNestedManyWithoutNationalityInput
  }

  export type NationalityUpdateInput = {
    nationality?: StringFieldUpdateOperationsInput | string
    lga_nationalities?: LgaNationalityUpdateManyWithoutNationalityNestedInput
  }

  export type NationalityUncheckedUpdateInput = {
    nationality_id?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
    lga_nationalities?: LgaNationalityUncheckedUpdateManyWithoutNationalityNestedInput
  }

  export type NationalityCreateManyInput = {
    nationality_id?: number
    nationality: string
  }

  export type NationalityUpdateManyMutationInput = {
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type NationalityUncheckedUpdateManyInput = {
    nationality_id?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type LgaNationalityCreateInput = {
    count: number
    lga: LgaCreateNestedOneWithoutLga_nationalitiesInput
    nationality: NationalityCreateNestedOneWithoutLga_nationalitiesInput
  }

  export type LgaNationalityUncheckedCreateInput = {
    lga_nationality_id?: number
    lga_code: number
    nationality_id: number
    count: number
  }

  export type LgaNationalityUpdateInput = {
    count?: IntFieldUpdateOperationsInput | number
    lga?: LgaUpdateOneRequiredWithoutLga_nationalitiesNestedInput
    nationality?: NationalityUpdateOneRequiredWithoutLga_nationalitiesNestedInput
  }

  export type LgaNationalityUncheckedUpdateInput = {
    lga_nationality_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    nationality_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaNationalityCreateManyInput = {
    lga_nationality_id?: number
    lga_code: number
    nationality_id: number
    count: number
  }

  export type LgaNationalityUpdateManyMutationInput = {
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaNationalityUncheckedUpdateManyInput = {
    lga_nationality_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    nationality_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type CouncilInfoCreateInput = {
    council_name?: string | null
    council_info?: string | null
    address?: string | null
    suburb?: string | null
    postcode?: number | null
    phone?: string | null
    email?: string | null
    website?: string | null
    lga: LgaCreateNestedOneWithoutCouncil_infoInput
  }

  export type CouncilInfoUncheckedCreateInput = {
    lga_code: number
    council_name?: string | null
    council_info?: string | null
    address?: string | null
    suburb?: string | null
    postcode?: number | null
    phone?: string | null
    email?: string | null
    website?: string | null
  }

  export type CouncilInfoUpdateInput = {
    council_name?: NullableStringFieldUpdateOperationsInput | string | null
    council_info?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    suburb?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: LgaUpdateOneRequiredWithoutCouncil_infoNestedInput
  }

  export type CouncilInfoUncheckedUpdateInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    council_name?: NullableStringFieldUpdateOperationsInput | string | null
    council_info?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    suburb?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouncilInfoCreateManyInput = {
    lga_code: number
    council_name?: string | null
    council_info?: string | null
    address?: string | null
    suburb?: string | null
    postcode?: number | null
    phone?: string | null
    email?: string | null
    website?: string | null
  }

  export type CouncilInfoUpdateManyMutationInput = {
    council_name?: NullableStringFieldUpdateOperationsInput | string | null
    council_info?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    suburb?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouncilInfoUncheckedUpdateManyInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    council_name?: NullableStringFieldUpdateOperationsInput | string | null
    council_info?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    suburb?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostcodeCreateInput = {
    postcode: number
    suburb: string
    latitude: number
    longitude: number
    lga: LgaCreateNestedOneWithoutPostcodesInput
  }

  export type PostcodeUncheckedCreateInput = {
    postcode: number
    suburb: string
    latitude: number
    longitude: number
    lga_code: number
  }

  export type PostcodeUpdateInput = {
    postcode?: IntFieldUpdateOperationsInput | number
    suburb?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    lga?: LgaUpdateOneRequiredWithoutPostcodesNestedInput
  }

  export type PostcodeUncheckedUpdateInput = {
    postcode?: IntFieldUpdateOperationsInput | number
    suburb?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
  }

  export type PostcodeCreateManyInput = {
    postcode: number
    suburb: string
    latitude: number
    longitude: number
    lga_code: number
  }

  export type PostcodeUpdateManyMutationInput = {
    postcode?: IntFieldUpdateOperationsInput | number
    suburb?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PostcodeUncheckedUpdateManyInput = {
    postcode?: IntFieldUpdateOperationsInput | number
    suburb?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
  }

  export type LanguageCreateInput = {
    language?: string | null
    proficiencies?: LgaLanguageProficiencyCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUncheckedCreateInput = {
    language_id?: number
    language?: string | null
    proficiencies?: LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLanguageInput
  }

  export type LanguageUpdateInput = {
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiencies?: LgaLanguageProficiencyUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    proficiencies?: LgaLanguageProficiencyUncheckedUpdateManyWithoutLanguageNestedInput
  }

  export type LanguageCreateManyInput = {
    language_id?: number
    language?: string | null
  }

  export type LanguageUpdateManyMutationInput = {
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageUncheckedUpdateManyInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LgaLanguageProficiencyCreateInput = {
    english_profiency_level: string
    count: number
    language: LanguageCreateNestedOneWithoutProficienciesInput
    lga: LgaCreateNestedOneWithoutLanguage_proficienciesInput
  }

  export type LgaLanguageProficiencyUncheckedCreateInput = {
    lga_language_prof_id?: number
    lga_code: number
    language_id: number
    english_profiency_level: string
    count: number
  }

  export type LgaLanguageProficiencyUpdateInput = {
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    language?: LanguageUpdateOneRequiredWithoutProficienciesNestedInput
    lga?: LgaUpdateOneRequiredWithoutLanguage_proficienciesNestedInput
  }

  export type LgaLanguageProficiencyUncheckedUpdateInput = {
    lga_language_prof_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaLanguageProficiencyCreateManyInput = {
    lga_language_prof_id?: number
    lga_code: number
    language_id: number
    english_profiency_level: string
    count: number
  }

  export type LgaLanguageProficiencyUpdateManyMutationInput = {
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaLanguageProficiencyUncheckedUpdateManyInput = {
    lga_language_prof_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaStatisticsCreateInput = {
    total_businesses?: number | null
    total_employed_over_15?: number | null
    born_overseas?: number | null
    pct_arrived_within_5_years?: number | null
    pct_proficient_english?: number | null
    percent_speaks_other_lang_at_home?: number | null
    median_age_years?: number | null
    pct_completed_year_12?: number | null
    pct_certificate?: number | null
    pct_bachelor_degree?: number | null
    pct_postgraduate?: number | null
    pct_managers?: number | null
    pct_professionals?: number | null
    pct_labourers?: number | null
    lga: LgaCreateNestedOneWithoutStatisticsInput
  }

  export type LgaStatisticsUncheckedCreateInput = {
    lga_code: number
    total_businesses?: number | null
    total_employed_over_15?: number | null
    born_overseas?: number | null
    pct_arrived_within_5_years?: number | null
    pct_proficient_english?: number | null
    percent_speaks_other_lang_at_home?: number | null
    median_age_years?: number | null
    pct_completed_year_12?: number | null
    pct_certificate?: number | null
    pct_bachelor_degree?: number | null
    pct_postgraduate?: number | null
    pct_managers?: number | null
    pct_professionals?: number | null
    pct_labourers?: number | null
  }

  export type LgaStatisticsUpdateInput = {
    total_businesses?: NullableIntFieldUpdateOperationsInput | number | null
    total_employed_over_15?: NullableIntFieldUpdateOperationsInput | number | null
    born_overseas?: NullableIntFieldUpdateOperationsInput | number | null
    pct_arrived_within_5_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_proficient_english?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_speaks_other_lang_at_home?: NullableFloatFieldUpdateOperationsInput | number | null
    median_age_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_completed_year_12?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_certificate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_bachelor_degree?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_postgraduate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_managers?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_professionals?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_labourers?: NullableFloatFieldUpdateOperationsInput | number | null
    lga?: LgaUpdateOneRequiredWithoutStatisticsNestedInput
  }

  export type LgaStatisticsUncheckedUpdateInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    total_businesses?: NullableIntFieldUpdateOperationsInput | number | null
    total_employed_over_15?: NullableIntFieldUpdateOperationsInput | number | null
    born_overseas?: NullableIntFieldUpdateOperationsInput | number | null
    pct_arrived_within_5_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_proficient_english?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_speaks_other_lang_at_home?: NullableFloatFieldUpdateOperationsInput | number | null
    median_age_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_completed_year_12?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_certificate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_bachelor_degree?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_postgraduate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_managers?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_professionals?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_labourers?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LgaStatisticsCreateManyInput = {
    lga_code: number
    total_businesses?: number | null
    total_employed_over_15?: number | null
    born_overseas?: number | null
    pct_arrived_within_5_years?: number | null
    pct_proficient_english?: number | null
    percent_speaks_other_lang_at_home?: number | null
    median_age_years?: number | null
    pct_completed_year_12?: number | null
    pct_certificate?: number | null
    pct_bachelor_degree?: number | null
    pct_postgraduate?: number | null
    pct_managers?: number | null
    pct_professionals?: number | null
    pct_labourers?: number | null
  }

  export type LgaStatisticsUpdateManyMutationInput = {
    total_businesses?: NullableIntFieldUpdateOperationsInput | number | null
    total_employed_over_15?: NullableIntFieldUpdateOperationsInput | number | null
    born_overseas?: NullableIntFieldUpdateOperationsInput | number | null
    pct_arrived_within_5_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_proficient_english?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_speaks_other_lang_at_home?: NullableFloatFieldUpdateOperationsInput | number | null
    median_age_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_completed_year_12?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_certificate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_bachelor_degree?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_postgraduate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_managers?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_professionals?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_labourers?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LgaStatisticsUncheckedUpdateManyInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    total_businesses?: NullableIntFieldUpdateOperationsInput | number | null
    total_employed_over_15?: NullableIntFieldUpdateOperationsInput | number | null
    born_overseas?: NullableIntFieldUpdateOperationsInput | number | null
    pct_arrived_within_5_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_proficient_english?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_speaks_other_lang_at_home?: NullableFloatFieldUpdateOperationsInput | number | null
    median_age_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_completed_year_12?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_certificate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_bachelor_degree?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_postgraduate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_managers?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_professionals?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_labourers?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueCountOrderByAggregateInput = {
    venue_id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    venue_city?: SortOrder
    venue_latitude?: SortOrder
    venue_longitude?: SortOrder
    venue_postcode?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    venue_latitude?: SortOrder
    venue_longitude?: SortOrder
    venue_postcode?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    venue_id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    venue_city?: SortOrder
    venue_latitude?: SortOrder
    venue_longitude?: SortOrder
    venue_postcode?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    venue_id?: SortOrder
    venue_name?: SortOrder
    venue_address?: SortOrder
    venue_city?: SortOrder
    venue_latitude?: SortOrder
    venue_longitude?: SortOrder
    venue_postcode?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    venue_latitude?: SortOrder
    venue_longitude?: SortOrder
    venue_postcode?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CategoryCountOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    category_id?: SortOrder
    category_name?: SortOrder
  }

  export type OrganizerCountOrderByAggregateInput = {
    organizer_id?: SortOrder
    organizer_name?: SortOrder
    organizer_url?: SortOrder
  }

  export type OrganizerMaxOrderByAggregateInput = {
    organizer_id?: SortOrder
    organizer_name?: SortOrder
    organizer_url?: SortOrder
  }

  export type OrganizerMinOrderByAggregateInput = {
    organizer_id?: SortOrder
    organizer_name?: SortOrder
    organizer_url?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type LogoCountOrderByAggregateInput = {
    logo_id?: SortOrder
    logo_url?: SortOrder
    logo_width?: SortOrder
    logo_height?: SortOrder
    logo_aspect_ratio?: SortOrder
  }

  export type LogoAvgOrderByAggregateInput = {
    logo_id?: SortOrder
    logo_width?: SortOrder
    logo_height?: SortOrder
    logo_aspect_ratio?: SortOrder
  }

  export type LogoMaxOrderByAggregateInput = {
    logo_id?: SortOrder
    logo_url?: SortOrder
    logo_width?: SortOrder
    logo_height?: SortOrder
    logo_aspect_ratio?: SortOrder
  }

  export type LogoMinOrderByAggregateInput = {
    logo_id?: SortOrder
    logo_url?: SortOrder
    logo_width?: SortOrder
    logo_height?: SortOrder
    logo_aspect_ratio?: SortOrder
  }

  export type LogoSumOrderByAggregateInput = {
    logo_id?: SortOrder
    logo_width?: SortOrder
    logo_height?: SortOrder
    logo_aspect_ratio?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type LogoNullableScalarRelationFilter = {
    is?: LogoWhereInput | null
    isNot?: LogoWhereInput | null
  }

  export type OrganizerNullableScalarRelationFilter = {
    is?: OrganizerWhereInput | null
    isNot?: OrganizerWhereInput | null
  }

  export type VenueNullableScalarRelationFilter = {
    is?: VenueWhereInput | null
    isNot?: VenueWhereInput | null
  }

  export type WebsiteListRelationFilter = {
    every?: WebsiteWhereInput
    some?: WebsiteWhereInput
    none?: WebsiteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WebsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    start_datetime?: SortOrder
    end_datetime?: SortOrder
    event_summary?: SortOrder
    category_id?: SortOrder
    organizer_id?: SortOrder
    venue_id?: SortOrder
    logo_id?: SortOrder
    event_status?: SortOrder
    event_url?: SortOrder
    is_free_event?: SortOrder
    community_friendly?: SortOrder
    predicted_community_friendly?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    logo_id?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    start_datetime?: SortOrder
    end_datetime?: SortOrder
    event_summary?: SortOrder
    category_id?: SortOrder
    organizer_id?: SortOrder
    venue_id?: SortOrder
    logo_id?: SortOrder
    event_status?: SortOrder
    event_url?: SortOrder
    is_free_event?: SortOrder
    community_friendly?: SortOrder
    predicted_community_friendly?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    event_id?: SortOrder
    event_name?: SortOrder
    event_description?: SortOrder
    start_datetime?: SortOrder
    end_datetime?: SortOrder
    event_summary?: SortOrder
    category_id?: SortOrder
    organizer_id?: SortOrder
    venue_id?: SortOrder
    logo_id?: SortOrder
    event_status?: SortOrder
    event_url?: SortOrder
    is_free_event?: SortOrder
    community_friendly?: SortOrder
    predicted_community_friendly?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    logo_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type WebsiteCountOrderByAggregateInput = {
    event_url?: SortOrder
    event_id?: SortOrder
  }

  export type WebsiteMaxOrderByAggregateInput = {
    event_url?: SortOrder
    event_id?: SortOrder
  }

  export type WebsiteMinOrderByAggregateInput = {
    event_url?: SortOrder
    event_id?: SortOrder
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_name?: SortOrder
    site_name?: SortOrder
    government_subsidised?: SortOrder
    subsidy_tag?: SortOrder
    asqa_code?: SortOrder
    url?: SortOrder
    email?: SortOrder
  }

  export type ProviderAvgOrderByAggregateInput = {
    provider_id?: SortOrder
    asqa_code?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_name?: SortOrder
    site_name?: SortOrder
    government_subsidised?: SortOrder
    subsidy_tag?: SortOrder
    asqa_code?: SortOrder
    url?: SortOrder
    email?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    provider_id?: SortOrder
    provider_name?: SortOrder
    site_name?: SortOrder
    government_subsidised?: SortOrder
    subsidy_tag?: SortOrder
    asqa_code?: SortOrder
    url?: SortOrder
    email?: SortOrder
  }

  export type ProviderSumOrderByAggregateInput = {
    provider_id?: SortOrder
    asqa_code?: SortOrder
  }

  export type ProviderScalarRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type LocationCountOrderByAggregateInput = {
    geographic_id?: SortOrder
    provider_id?: SortOrder
    address_line_1?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    full_address?: SortOrder
    region_name?: SortOrder
    local_government_authority?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    geographic_id?: SortOrder
    provider_id?: SortOrder
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    geographic_id?: SortOrder
    provider_id?: SortOrder
    address_line_1?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    full_address?: SortOrder
    region_name?: SortOrder
    local_government_authority?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    geographic_id?: SortOrder
    provider_id?: SortOrder
    address_line_1?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    full_address?: SortOrder
    region_name?: SortOrder
    local_government_authority?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    geographic_id?: SortOrder
    provider_id?: SortOrder
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    course_id?: SortOrder
    provider_id?: SortOrder
    course_title?: SortOrder
    course_code?: SortOrder
    qualification_level?: SortOrder
    course_type?: SortOrder
    government_subsidised?: SortOrder
    apprenticeship?: SortOrder
    traineeship?: SortOrder
    entry_requirements?: SortOrder
    description?: SortOrder
    is_english_course?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    course_id?: SortOrder
    provider_id?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    course_id?: SortOrder
    provider_id?: SortOrder
    course_title?: SortOrder
    course_code?: SortOrder
    qualification_level?: SortOrder
    course_type?: SortOrder
    government_subsidised?: SortOrder
    apprenticeship?: SortOrder
    traineeship?: SortOrder
    entry_requirements?: SortOrder
    description?: SortOrder
    is_english_course?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    course_id?: SortOrder
    provider_id?: SortOrder
    course_title?: SortOrder
    course_code?: SortOrder
    qualification_level?: SortOrder
    course_type?: SortOrder
    government_subsidised?: SortOrder
    apprenticeship?: SortOrder
    traineeship?: SortOrder
    entry_requirements?: SortOrder
    description?: SortOrder
    is_english_course?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    course_id?: SortOrder
    provider_id?: SortOrder
  }

  export type CouncilInfoNullableScalarRelationFilter = {
    is?: CouncilInfoWhereInput | null
    isNot?: CouncilInfoWhereInput | null
  }

  export type LgaLanguageProficiencyListRelationFilter = {
    every?: LgaLanguageProficiencyWhereInput
    some?: LgaLanguageProficiencyWhereInput
    none?: LgaLanguageProficiencyWhereInput
  }

  export type LgaNationalityListRelationFilter = {
    every?: LgaNationalityWhereInput
    some?: LgaNationalityWhereInput
    none?: LgaNationalityWhereInput
  }

  export type LgaStatisticsNullableScalarRelationFilter = {
    is?: LgaStatisticsWhereInput | null
    isNot?: LgaStatisticsWhereInput | null
  }

  export type PostcodeListRelationFilter = {
    every?: PostcodeWhereInput
    some?: PostcodeWhereInput
    none?: PostcodeWhereInput
  }

  export type LgaLanguageProficiencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LgaNationalityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostcodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LgaCountOrderByAggregateInput = {
    lga_code?: SortOrder
    lga_name?: SortOrder
  }

  export type LgaAvgOrderByAggregateInput = {
    lga_code?: SortOrder
  }

  export type LgaMaxOrderByAggregateInput = {
    lga_code?: SortOrder
    lga_name?: SortOrder
  }

  export type LgaMinOrderByAggregateInput = {
    lga_code?: SortOrder
    lga_name?: SortOrder
  }

  export type LgaSumOrderByAggregateInput = {
    lga_code?: SortOrder
  }

  export type NationalityCountOrderByAggregateInput = {
    nationality_id?: SortOrder
    nationality?: SortOrder
  }

  export type NationalityAvgOrderByAggregateInput = {
    nationality_id?: SortOrder
  }

  export type NationalityMaxOrderByAggregateInput = {
    nationality_id?: SortOrder
    nationality?: SortOrder
  }

  export type NationalityMinOrderByAggregateInput = {
    nationality_id?: SortOrder
    nationality?: SortOrder
  }

  export type NationalitySumOrderByAggregateInput = {
    nationality_id?: SortOrder
  }

  export type LgaScalarRelationFilter = {
    is?: LgaWhereInput
    isNot?: LgaWhereInput
  }

  export type NationalityScalarRelationFilter = {
    is?: NationalityWhereInput
    isNot?: NationalityWhereInput
  }

  export type LgaNationalityCountOrderByAggregateInput = {
    lga_nationality_id?: SortOrder
    lga_code?: SortOrder
    nationality_id?: SortOrder
    count?: SortOrder
  }

  export type LgaNationalityAvgOrderByAggregateInput = {
    lga_nationality_id?: SortOrder
    lga_code?: SortOrder
    nationality_id?: SortOrder
    count?: SortOrder
  }

  export type LgaNationalityMaxOrderByAggregateInput = {
    lga_nationality_id?: SortOrder
    lga_code?: SortOrder
    nationality_id?: SortOrder
    count?: SortOrder
  }

  export type LgaNationalityMinOrderByAggregateInput = {
    lga_nationality_id?: SortOrder
    lga_code?: SortOrder
    nationality_id?: SortOrder
    count?: SortOrder
  }

  export type LgaNationalitySumOrderByAggregateInput = {
    lga_nationality_id?: SortOrder
    lga_code?: SortOrder
    nationality_id?: SortOrder
    count?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CouncilInfoCountOrderByAggregateInput = {
    lga_code?: SortOrder
    council_name?: SortOrder
    council_info?: SortOrder
    address?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
  }

  export type CouncilInfoAvgOrderByAggregateInput = {
    lga_code?: SortOrder
    postcode?: SortOrder
  }

  export type CouncilInfoMaxOrderByAggregateInput = {
    lga_code?: SortOrder
    council_name?: SortOrder
    council_info?: SortOrder
    address?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
  }

  export type CouncilInfoMinOrderByAggregateInput = {
    lga_code?: SortOrder
    council_name?: SortOrder
    council_info?: SortOrder
    address?: SortOrder
    suburb?: SortOrder
    postcode?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
  }

  export type CouncilInfoSumOrderByAggregateInput = {
    lga_code?: SortOrder
    postcode?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PostcodeCountOrderByAggregateInput = {
    postcode?: SortOrder
    suburb?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lga_code?: SortOrder
  }

  export type PostcodeAvgOrderByAggregateInput = {
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lga_code?: SortOrder
  }

  export type PostcodeMaxOrderByAggregateInput = {
    postcode?: SortOrder
    suburb?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lga_code?: SortOrder
  }

  export type PostcodeMinOrderByAggregateInput = {
    postcode?: SortOrder
    suburb?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lga_code?: SortOrder
  }

  export type PostcodeSumOrderByAggregateInput = {
    postcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lga_code?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    language_id?: SortOrder
    language?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    language_id?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    language_id?: SortOrder
    language?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    language_id?: SortOrder
    language?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    language_id?: SortOrder
  }

  export type LanguageScalarRelationFilter = {
    is?: LanguageWhereInput
    isNot?: LanguageWhereInput
  }

  export type LgaLanguageProficiencyCountOrderByAggregateInput = {
    lga_language_prof_id?: SortOrder
    lga_code?: SortOrder
    language_id?: SortOrder
    english_profiency_level?: SortOrder
    count?: SortOrder
  }

  export type LgaLanguageProficiencyAvgOrderByAggregateInput = {
    lga_language_prof_id?: SortOrder
    lga_code?: SortOrder
    language_id?: SortOrder
    count?: SortOrder
  }

  export type LgaLanguageProficiencyMaxOrderByAggregateInput = {
    lga_language_prof_id?: SortOrder
    lga_code?: SortOrder
    language_id?: SortOrder
    english_profiency_level?: SortOrder
    count?: SortOrder
  }

  export type LgaLanguageProficiencyMinOrderByAggregateInput = {
    lga_language_prof_id?: SortOrder
    lga_code?: SortOrder
    language_id?: SortOrder
    english_profiency_level?: SortOrder
    count?: SortOrder
  }

  export type LgaLanguageProficiencySumOrderByAggregateInput = {
    lga_language_prof_id?: SortOrder
    lga_code?: SortOrder
    language_id?: SortOrder
    count?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type LgaStatisticsCountOrderByAggregateInput = {
    lga_code?: SortOrder
    total_businesses?: SortOrder
    total_employed_over_15?: SortOrder
    born_overseas?: SortOrder
    pct_arrived_within_5_years?: SortOrder
    pct_proficient_english?: SortOrder
    percent_speaks_other_lang_at_home?: SortOrder
    median_age_years?: SortOrder
    pct_completed_year_12?: SortOrder
    pct_certificate?: SortOrder
    pct_bachelor_degree?: SortOrder
    pct_postgraduate?: SortOrder
    pct_managers?: SortOrder
    pct_professionals?: SortOrder
    pct_labourers?: SortOrder
  }

  export type LgaStatisticsAvgOrderByAggregateInput = {
    lga_code?: SortOrder
    total_businesses?: SortOrder
    total_employed_over_15?: SortOrder
    born_overseas?: SortOrder
    pct_arrived_within_5_years?: SortOrder
    pct_proficient_english?: SortOrder
    percent_speaks_other_lang_at_home?: SortOrder
    median_age_years?: SortOrder
    pct_completed_year_12?: SortOrder
    pct_certificate?: SortOrder
    pct_bachelor_degree?: SortOrder
    pct_postgraduate?: SortOrder
    pct_managers?: SortOrder
    pct_professionals?: SortOrder
    pct_labourers?: SortOrder
  }

  export type LgaStatisticsMaxOrderByAggregateInput = {
    lga_code?: SortOrder
    total_businesses?: SortOrder
    total_employed_over_15?: SortOrder
    born_overseas?: SortOrder
    pct_arrived_within_5_years?: SortOrder
    pct_proficient_english?: SortOrder
    percent_speaks_other_lang_at_home?: SortOrder
    median_age_years?: SortOrder
    pct_completed_year_12?: SortOrder
    pct_certificate?: SortOrder
    pct_bachelor_degree?: SortOrder
    pct_postgraduate?: SortOrder
    pct_managers?: SortOrder
    pct_professionals?: SortOrder
    pct_labourers?: SortOrder
  }

  export type LgaStatisticsMinOrderByAggregateInput = {
    lga_code?: SortOrder
    total_businesses?: SortOrder
    total_employed_over_15?: SortOrder
    born_overseas?: SortOrder
    pct_arrived_within_5_years?: SortOrder
    pct_proficient_english?: SortOrder
    percent_speaks_other_lang_at_home?: SortOrder
    median_age_years?: SortOrder
    pct_completed_year_12?: SortOrder
    pct_certificate?: SortOrder
    pct_bachelor_degree?: SortOrder
    pct_postgraduate?: SortOrder
    pct_managers?: SortOrder
    pct_professionals?: SortOrder
    pct_labourers?: SortOrder
  }

  export type LgaStatisticsSumOrderByAggregateInput = {
    lga_code?: SortOrder
    total_businesses?: SortOrder
    total_employed_over_15?: SortOrder
    born_overseas?: SortOrder
    pct_arrived_within_5_years?: SortOrder
    pct_proficient_english?: SortOrder
    percent_speaks_other_lang_at_home?: SortOrder
    median_age_years?: SortOrder
    pct_completed_year_12?: SortOrder
    pct_certificate?: SortOrder
    pct_bachelor_degree?: SortOrder
    pct_postgraduate?: SortOrder
    pct_managers?: SortOrder
    pct_professionals?: SortOrder
    pct_labourers?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EventCreateNestedManyWithoutVenueInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutVenueInput | EventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutVenueInput | EventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EventUpdateManyWithWhereWithoutVenueInput | EventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput> | EventCreateWithoutVenueInput[] | EventUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EventCreateOrConnectWithoutVenueInput | EventCreateOrConnectWithoutVenueInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutVenueInput | EventUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: EventCreateManyVenueInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutVenueInput | EventUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EventUpdateManyWithWhereWithoutVenueInput | EventUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCategoryInput | EventUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCategoryInput | EventUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCategoryInput | EventUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCategoryInput | EventUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCategoryInput | EventUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCategoryInput | EventUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutOrganizerInput | EventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutOrganizerInput | EventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: EventUpdateManyWithWhereWithoutOrganizerInput | EventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput> | EventCreateWithoutOrganizerInput[] | EventUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: EventCreateOrConnectWithoutOrganizerInput | EventCreateOrConnectWithoutOrganizerInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutOrganizerInput | EventUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: EventCreateManyOrganizerInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutOrganizerInput | EventUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: EventUpdateManyWithWhereWithoutOrganizerInput | EventUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventCreateNestedManyWithoutLogoInput = {
    create?: XOR<EventCreateWithoutLogoInput, EventUncheckedCreateWithoutLogoInput> | EventCreateWithoutLogoInput[] | EventUncheckedCreateWithoutLogoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLogoInput | EventCreateOrConnectWithoutLogoInput[]
    createMany?: EventCreateManyLogoInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutLogoInput = {
    create?: XOR<EventCreateWithoutLogoInput, EventUncheckedCreateWithoutLogoInput> | EventCreateWithoutLogoInput[] | EventUncheckedCreateWithoutLogoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLogoInput | EventCreateOrConnectWithoutLogoInput[]
    createMany?: EventCreateManyLogoInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EventUpdateManyWithoutLogoNestedInput = {
    create?: XOR<EventCreateWithoutLogoInput, EventUncheckedCreateWithoutLogoInput> | EventCreateWithoutLogoInput[] | EventUncheckedCreateWithoutLogoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLogoInput | EventCreateOrConnectWithoutLogoInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLogoInput | EventUpsertWithWhereUniqueWithoutLogoInput[]
    createMany?: EventCreateManyLogoInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLogoInput | EventUpdateWithWhereUniqueWithoutLogoInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLogoInput | EventUpdateManyWithWhereWithoutLogoInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutLogoNestedInput = {
    create?: XOR<EventCreateWithoutLogoInput, EventUncheckedCreateWithoutLogoInput> | EventCreateWithoutLogoInput[] | EventUncheckedCreateWithoutLogoInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLogoInput | EventCreateOrConnectWithoutLogoInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLogoInput | EventUpsertWithWhereUniqueWithoutLogoInput[]
    createMany?: EventCreateManyLogoInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLogoInput | EventUpdateWithWhereUniqueWithoutLogoInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLogoInput | EventUpdateManyWithWhereWithoutLogoInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutEventsInput = {
    create?: XOR<CategoryCreateWithoutEventsInput, CategoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEventsInput
    connect?: CategoryWhereUniqueInput
  }

  export type LogoCreateNestedOneWithoutEventsInput = {
    create?: XOR<LogoCreateWithoutEventsInput, LogoUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LogoCreateOrConnectWithoutEventsInput
    connect?: LogoWhereUniqueInput
  }

  export type OrganizerCreateNestedOneWithoutEventsInput = {
    create?: XOR<OrganizerCreateWithoutEventsInput, OrganizerUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrganizerCreateOrConnectWithoutEventsInput
    connect?: OrganizerWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutEventsInput = {
    create?: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutEventsInput
    connect?: VenueWhereUniqueInput
  }

  export type WebsiteCreateNestedManyWithoutEventInput = {
    create?: XOR<WebsiteCreateWithoutEventInput, WebsiteUncheckedCreateWithoutEventInput> | WebsiteCreateWithoutEventInput[] | WebsiteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutEventInput | WebsiteCreateOrConnectWithoutEventInput[]
    createMany?: WebsiteCreateManyEventInputEnvelope
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
  }

  export type WebsiteUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<WebsiteCreateWithoutEventInput, WebsiteUncheckedCreateWithoutEventInput> | WebsiteCreateWithoutEventInput[] | WebsiteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutEventInput | WebsiteCreateOrConnectWithoutEventInput[]
    createMany?: WebsiteCreateManyEventInputEnvelope
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CategoryUpdateOneWithoutEventsNestedInput = {
    create?: XOR<CategoryCreateWithoutEventsInput, CategoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEventsInput
    upsert?: CategoryUpsertWithoutEventsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutEventsInput, CategoryUpdateWithoutEventsInput>, CategoryUncheckedUpdateWithoutEventsInput>
  }

  export type LogoUpdateOneWithoutEventsNestedInput = {
    create?: XOR<LogoCreateWithoutEventsInput, LogoUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LogoCreateOrConnectWithoutEventsInput
    upsert?: LogoUpsertWithoutEventsInput
    disconnect?: LogoWhereInput | boolean
    delete?: LogoWhereInput | boolean
    connect?: LogoWhereUniqueInput
    update?: XOR<XOR<LogoUpdateToOneWithWhereWithoutEventsInput, LogoUpdateWithoutEventsInput>, LogoUncheckedUpdateWithoutEventsInput>
  }

  export type OrganizerUpdateOneWithoutEventsNestedInput = {
    create?: XOR<OrganizerCreateWithoutEventsInput, OrganizerUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrganizerCreateOrConnectWithoutEventsInput
    upsert?: OrganizerUpsertWithoutEventsInput
    disconnect?: OrganizerWhereInput | boolean
    delete?: OrganizerWhereInput | boolean
    connect?: OrganizerWhereUniqueInput
    update?: XOR<XOR<OrganizerUpdateToOneWithWhereWithoutEventsInput, OrganizerUpdateWithoutEventsInput>, OrganizerUncheckedUpdateWithoutEventsInput>
  }

  export type VenueUpdateOneWithoutEventsNestedInput = {
    create?: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutEventsInput
    upsert?: VenueUpsertWithoutEventsInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutEventsInput, VenueUpdateWithoutEventsInput>, VenueUncheckedUpdateWithoutEventsInput>
  }

  export type WebsiteUpdateManyWithoutEventNestedInput = {
    create?: XOR<WebsiteCreateWithoutEventInput, WebsiteUncheckedCreateWithoutEventInput> | WebsiteCreateWithoutEventInput[] | WebsiteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutEventInput | WebsiteCreateOrConnectWithoutEventInput[]
    upsert?: WebsiteUpsertWithWhereUniqueWithoutEventInput | WebsiteUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: WebsiteCreateManyEventInputEnvelope
    set?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    disconnect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    delete?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    update?: WebsiteUpdateWithWhereUniqueWithoutEventInput | WebsiteUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: WebsiteUpdateManyWithWhereWithoutEventInput | WebsiteUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type WebsiteUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<WebsiteCreateWithoutEventInput, WebsiteUncheckedCreateWithoutEventInput> | WebsiteCreateWithoutEventInput[] | WebsiteUncheckedCreateWithoutEventInput[]
    connectOrCreate?: WebsiteCreateOrConnectWithoutEventInput | WebsiteCreateOrConnectWithoutEventInput[]
    upsert?: WebsiteUpsertWithWhereUniqueWithoutEventInput | WebsiteUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: WebsiteCreateManyEventInputEnvelope
    set?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    disconnect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    delete?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    connect?: WebsiteWhereUniqueInput | WebsiteWhereUniqueInput[]
    update?: WebsiteUpdateWithWhereUniqueWithoutEventInput | WebsiteUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: WebsiteUpdateManyWithWhereWithoutEventInput | WebsiteUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutWebsitesInput = {
    create?: XOR<EventCreateWithoutWebsitesInput, EventUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: EventCreateOrConnectWithoutWebsitesInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutWebsitesNestedInput = {
    create?: XOR<EventCreateWithoutWebsitesInput, EventUncheckedCreateWithoutWebsitesInput>
    connectOrCreate?: EventCreateOrConnectWithoutWebsitesInput
    upsert?: EventUpsertWithoutWebsitesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutWebsitesInput, EventUpdateWithoutWebsitesInput>, EventUncheckedUpdateWithoutWebsitesInput>
  }

  export type CourseCreateNestedManyWithoutProviderInput = {
    create?: XOR<CourseCreateWithoutProviderInput, CourseUncheckedCreateWithoutProviderInput> | CourseCreateWithoutProviderInput[] | CourseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProviderInput | CourseCreateOrConnectWithoutProviderInput[]
    createMany?: CourseCreateManyProviderInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LocationCreateNestedManyWithoutProviderInput = {
    create?: XOR<LocationCreateWithoutProviderInput, LocationUncheckedCreateWithoutProviderInput> | LocationCreateWithoutProviderInput[] | LocationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutProviderInput | LocationCreateOrConnectWithoutProviderInput[]
    createMany?: LocationCreateManyProviderInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<CourseCreateWithoutProviderInput, CourseUncheckedCreateWithoutProviderInput> | CourseCreateWithoutProviderInput[] | CourseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProviderInput | CourseCreateOrConnectWithoutProviderInput[]
    createMany?: CourseCreateManyProviderInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<LocationCreateWithoutProviderInput, LocationUncheckedCreateWithoutProviderInput> | LocationCreateWithoutProviderInput[] | LocationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutProviderInput | LocationCreateOrConnectWithoutProviderInput[]
    createMany?: LocationCreateManyProviderInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type CourseUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CourseCreateWithoutProviderInput, CourseUncheckedCreateWithoutProviderInput> | CourseCreateWithoutProviderInput[] | CourseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProviderInput | CourseCreateOrConnectWithoutProviderInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutProviderInput | CourseUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CourseCreateManyProviderInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutProviderInput | CourseUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutProviderInput | CourseUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LocationUpdateManyWithoutProviderNestedInput = {
    create?: XOR<LocationCreateWithoutProviderInput, LocationUncheckedCreateWithoutProviderInput> | LocationCreateWithoutProviderInput[] | LocationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutProviderInput | LocationCreateOrConnectWithoutProviderInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutProviderInput | LocationUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: LocationCreateManyProviderInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutProviderInput | LocationUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutProviderInput | LocationUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CourseCreateWithoutProviderInput, CourseUncheckedCreateWithoutProviderInput> | CourseCreateWithoutProviderInput[] | CourseUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutProviderInput | CourseCreateOrConnectWithoutProviderInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutProviderInput | CourseUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CourseCreateManyProviderInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutProviderInput | CourseUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutProviderInput | CourseUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<LocationCreateWithoutProviderInput, LocationUncheckedCreateWithoutProviderInput> | LocationCreateWithoutProviderInput[] | LocationUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutProviderInput | LocationCreateOrConnectWithoutProviderInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutProviderInput | LocationUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: LocationCreateManyProviderInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutProviderInput | LocationUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutProviderInput | LocationUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type ProviderCreateNestedOneWithoutLocationsInput = {
    create?: XOR<ProviderCreateWithoutLocationsInput, ProviderUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutLocationsInput
    connect?: ProviderWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<ProviderCreateWithoutLocationsInput, ProviderUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutLocationsInput
    upsert?: ProviderUpsertWithoutLocationsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutLocationsInput, ProviderUpdateWithoutLocationsInput>, ProviderUncheckedUpdateWithoutLocationsInput>
  }

  export type ProviderCreateNestedOneWithoutCoursesInput = {
    create?: XOR<ProviderCreateWithoutCoursesInput, ProviderUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutCoursesInput
    connect?: ProviderWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<ProviderCreateWithoutCoursesInput, ProviderUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutCoursesInput
    upsert?: ProviderUpsertWithoutCoursesInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutCoursesInput, ProviderUpdateWithoutCoursesInput>, ProviderUncheckedUpdateWithoutCoursesInput>
  }

  export type CouncilInfoCreateNestedOneWithoutLgaInput = {
    create?: XOR<CouncilInfoCreateWithoutLgaInput, CouncilInfoUncheckedCreateWithoutLgaInput>
    connectOrCreate?: CouncilInfoCreateOrConnectWithoutLgaInput
    connect?: CouncilInfoWhereUniqueInput
  }

  export type LgaLanguageProficiencyCreateNestedManyWithoutLgaInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLgaInput, LgaLanguageProficiencyUncheckedCreateWithoutLgaInput> | LgaLanguageProficiencyCreateWithoutLgaInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLgaInput | LgaLanguageProficiencyCreateOrConnectWithoutLgaInput[]
    createMany?: LgaLanguageProficiencyCreateManyLgaInputEnvelope
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
  }

  export type LgaNationalityCreateNestedManyWithoutLgaInput = {
    create?: XOR<LgaNationalityCreateWithoutLgaInput, LgaNationalityUncheckedCreateWithoutLgaInput> | LgaNationalityCreateWithoutLgaInput[] | LgaNationalityUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutLgaInput | LgaNationalityCreateOrConnectWithoutLgaInput[]
    createMany?: LgaNationalityCreateManyLgaInputEnvelope
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
  }

  export type LgaStatisticsCreateNestedOneWithoutLgaInput = {
    create?: XOR<LgaStatisticsCreateWithoutLgaInput, LgaStatisticsUncheckedCreateWithoutLgaInput>
    connectOrCreate?: LgaStatisticsCreateOrConnectWithoutLgaInput
    connect?: LgaStatisticsWhereUniqueInput
  }

  export type PostcodeCreateNestedManyWithoutLgaInput = {
    create?: XOR<PostcodeCreateWithoutLgaInput, PostcodeUncheckedCreateWithoutLgaInput> | PostcodeCreateWithoutLgaInput[] | PostcodeUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: PostcodeCreateOrConnectWithoutLgaInput | PostcodeCreateOrConnectWithoutLgaInput[]
    createMany?: PostcodeCreateManyLgaInputEnvelope
    connect?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
  }

  export type CouncilInfoUncheckedCreateNestedOneWithoutLgaInput = {
    create?: XOR<CouncilInfoCreateWithoutLgaInput, CouncilInfoUncheckedCreateWithoutLgaInput>
    connectOrCreate?: CouncilInfoCreateOrConnectWithoutLgaInput
    connect?: CouncilInfoWhereUniqueInput
  }

  export type LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLgaInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLgaInput, LgaLanguageProficiencyUncheckedCreateWithoutLgaInput> | LgaLanguageProficiencyCreateWithoutLgaInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLgaInput | LgaLanguageProficiencyCreateOrConnectWithoutLgaInput[]
    createMany?: LgaLanguageProficiencyCreateManyLgaInputEnvelope
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
  }

  export type LgaNationalityUncheckedCreateNestedManyWithoutLgaInput = {
    create?: XOR<LgaNationalityCreateWithoutLgaInput, LgaNationalityUncheckedCreateWithoutLgaInput> | LgaNationalityCreateWithoutLgaInput[] | LgaNationalityUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutLgaInput | LgaNationalityCreateOrConnectWithoutLgaInput[]
    createMany?: LgaNationalityCreateManyLgaInputEnvelope
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
  }

  export type LgaStatisticsUncheckedCreateNestedOneWithoutLgaInput = {
    create?: XOR<LgaStatisticsCreateWithoutLgaInput, LgaStatisticsUncheckedCreateWithoutLgaInput>
    connectOrCreate?: LgaStatisticsCreateOrConnectWithoutLgaInput
    connect?: LgaStatisticsWhereUniqueInput
  }

  export type PostcodeUncheckedCreateNestedManyWithoutLgaInput = {
    create?: XOR<PostcodeCreateWithoutLgaInput, PostcodeUncheckedCreateWithoutLgaInput> | PostcodeCreateWithoutLgaInput[] | PostcodeUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: PostcodeCreateOrConnectWithoutLgaInput | PostcodeCreateOrConnectWithoutLgaInput[]
    createMany?: PostcodeCreateManyLgaInputEnvelope
    connect?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
  }

  export type CouncilInfoUpdateOneWithoutLgaNestedInput = {
    create?: XOR<CouncilInfoCreateWithoutLgaInput, CouncilInfoUncheckedCreateWithoutLgaInput>
    connectOrCreate?: CouncilInfoCreateOrConnectWithoutLgaInput
    upsert?: CouncilInfoUpsertWithoutLgaInput
    disconnect?: CouncilInfoWhereInput | boolean
    delete?: CouncilInfoWhereInput | boolean
    connect?: CouncilInfoWhereUniqueInput
    update?: XOR<XOR<CouncilInfoUpdateToOneWithWhereWithoutLgaInput, CouncilInfoUpdateWithoutLgaInput>, CouncilInfoUncheckedUpdateWithoutLgaInput>
  }

  export type LgaLanguageProficiencyUpdateManyWithoutLgaNestedInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLgaInput, LgaLanguageProficiencyUncheckedCreateWithoutLgaInput> | LgaLanguageProficiencyCreateWithoutLgaInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLgaInput | LgaLanguageProficiencyCreateOrConnectWithoutLgaInput[]
    upsert?: LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLgaInput | LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLgaInput[]
    createMany?: LgaLanguageProficiencyCreateManyLgaInputEnvelope
    set?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    disconnect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    delete?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    update?: LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLgaInput | LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLgaInput[]
    updateMany?: LgaLanguageProficiencyUpdateManyWithWhereWithoutLgaInput | LgaLanguageProficiencyUpdateManyWithWhereWithoutLgaInput[]
    deleteMany?: LgaLanguageProficiencyScalarWhereInput | LgaLanguageProficiencyScalarWhereInput[]
  }

  export type LgaNationalityUpdateManyWithoutLgaNestedInput = {
    create?: XOR<LgaNationalityCreateWithoutLgaInput, LgaNationalityUncheckedCreateWithoutLgaInput> | LgaNationalityCreateWithoutLgaInput[] | LgaNationalityUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutLgaInput | LgaNationalityCreateOrConnectWithoutLgaInput[]
    upsert?: LgaNationalityUpsertWithWhereUniqueWithoutLgaInput | LgaNationalityUpsertWithWhereUniqueWithoutLgaInput[]
    createMany?: LgaNationalityCreateManyLgaInputEnvelope
    set?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    disconnect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    delete?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    update?: LgaNationalityUpdateWithWhereUniqueWithoutLgaInput | LgaNationalityUpdateWithWhereUniqueWithoutLgaInput[]
    updateMany?: LgaNationalityUpdateManyWithWhereWithoutLgaInput | LgaNationalityUpdateManyWithWhereWithoutLgaInput[]
    deleteMany?: LgaNationalityScalarWhereInput | LgaNationalityScalarWhereInput[]
  }

  export type LgaStatisticsUpdateOneWithoutLgaNestedInput = {
    create?: XOR<LgaStatisticsCreateWithoutLgaInput, LgaStatisticsUncheckedCreateWithoutLgaInput>
    connectOrCreate?: LgaStatisticsCreateOrConnectWithoutLgaInput
    upsert?: LgaStatisticsUpsertWithoutLgaInput
    disconnect?: LgaStatisticsWhereInput | boolean
    delete?: LgaStatisticsWhereInput | boolean
    connect?: LgaStatisticsWhereUniqueInput
    update?: XOR<XOR<LgaStatisticsUpdateToOneWithWhereWithoutLgaInput, LgaStatisticsUpdateWithoutLgaInput>, LgaStatisticsUncheckedUpdateWithoutLgaInput>
  }

  export type PostcodeUpdateManyWithoutLgaNestedInput = {
    create?: XOR<PostcodeCreateWithoutLgaInput, PostcodeUncheckedCreateWithoutLgaInput> | PostcodeCreateWithoutLgaInput[] | PostcodeUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: PostcodeCreateOrConnectWithoutLgaInput | PostcodeCreateOrConnectWithoutLgaInput[]
    upsert?: PostcodeUpsertWithWhereUniqueWithoutLgaInput | PostcodeUpsertWithWhereUniqueWithoutLgaInput[]
    createMany?: PostcodeCreateManyLgaInputEnvelope
    set?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    disconnect?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    delete?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    connect?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    update?: PostcodeUpdateWithWhereUniqueWithoutLgaInput | PostcodeUpdateWithWhereUniqueWithoutLgaInput[]
    updateMany?: PostcodeUpdateManyWithWhereWithoutLgaInput | PostcodeUpdateManyWithWhereWithoutLgaInput[]
    deleteMany?: PostcodeScalarWhereInput | PostcodeScalarWhereInput[]
  }

  export type CouncilInfoUncheckedUpdateOneWithoutLgaNestedInput = {
    create?: XOR<CouncilInfoCreateWithoutLgaInput, CouncilInfoUncheckedCreateWithoutLgaInput>
    connectOrCreate?: CouncilInfoCreateOrConnectWithoutLgaInput
    upsert?: CouncilInfoUpsertWithoutLgaInput
    disconnect?: CouncilInfoWhereInput | boolean
    delete?: CouncilInfoWhereInput | boolean
    connect?: CouncilInfoWhereUniqueInput
    update?: XOR<XOR<CouncilInfoUpdateToOneWithWhereWithoutLgaInput, CouncilInfoUpdateWithoutLgaInput>, CouncilInfoUncheckedUpdateWithoutLgaInput>
  }

  export type LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaNestedInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLgaInput, LgaLanguageProficiencyUncheckedCreateWithoutLgaInput> | LgaLanguageProficiencyCreateWithoutLgaInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLgaInput | LgaLanguageProficiencyCreateOrConnectWithoutLgaInput[]
    upsert?: LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLgaInput | LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLgaInput[]
    createMany?: LgaLanguageProficiencyCreateManyLgaInputEnvelope
    set?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    disconnect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    delete?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    update?: LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLgaInput | LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLgaInput[]
    updateMany?: LgaLanguageProficiencyUpdateManyWithWhereWithoutLgaInput | LgaLanguageProficiencyUpdateManyWithWhereWithoutLgaInput[]
    deleteMany?: LgaLanguageProficiencyScalarWhereInput | LgaLanguageProficiencyScalarWhereInput[]
  }

  export type LgaNationalityUncheckedUpdateManyWithoutLgaNestedInput = {
    create?: XOR<LgaNationalityCreateWithoutLgaInput, LgaNationalityUncheckedCreateWithoutLgaInput> | LgaNationalityCreateWithoutLgaInput[] | LgaNationalityUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutLgaInput | LgaNationalityCreateOrConnectWithoutLgaInput[]
    upsert?: LgaNationalityUpsertWithWhereUniqueWithoutLgaInput | LgaNationalityUpsertWithWhereUniqueWithoutLgaInput[]
    createMany?: LgaNationalityCreateManyLgaInputEnvelope
    set?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    disconnect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    delete?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    update?: LgaNationalityUpdateWithWhereUniqueWithoutLgaInput | LgaNationalityUpdateWithWhereUniqueWithoutLgaInput[]
    updateMany?: LgaNationalityUpdateManyWithWhereWithoutLgaInput | LgaNationalityUpdateManyWithWhereWithoutLgaInput[]
    deleteMany?: LgaNationalityScalarWhereInput | LgaNationalityScalarWhereInput[]
  }

  export type LgaStatisticsUncheckedUpdateOneWithoutLgaNestedInput = {
    create?: XOR<LgaStatisticsCreateWithoutLgaInput, LgaStatisticsUncheckedCreateWithoutLgaInput>
    connectOrCreate?: LgaStatisticsCreateOrConnectWithoutLgaInput
    upsert?: LgaStatisticsUpsertWithoutLgaInput
    disconnect?: LgaStatisticsWhereInput | boolean
    delete?: LgaStatisticsWhereInput | boolean
    connect?: LgaStatisticsWhereUniqueInput
    update?: XOR<XOR<LgaStatisticsUpdateToOneWithWhereWithoutLgaInput, LgaStatisticsUpdateWithoutLgaInput>, LgaStatisticsUncheckedUpdateWithoutLgaInput>
  }

  export type PostcodeUncheckedUpdateManyWithoutLgaNestedInput = {
    create?: XOR<PostcodeCreateWithoutLgaInput, PostcodeUncheckedCreateWithoutLgaInput> | PostcodeCreateWithoutLgaInput[] | PostcodeUncheckedCreateWithoutLgaInput[]
    connectOrCreate?: PostcodeCreateOrConnectWithoutLgaInput | PostcodeCreateOrConnectWithoutLgaInput[]
    upsert?: PostcodeUpsertWithWhereUniqueWithoutLgaInput | PostcodeUpsertWithWhereUniqueWithoutLgaInput[]
    createMany?: PostcodeCreateManyLgaInputEnvelope
    set?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    disconnect?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    delete?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    connect?: PostcodeWhereUniqueInput | PostcodeWhereUniqueInput[]
    update?: PostcodeUpdateWithWhereUniqueWithoutLgaInput | PostcodeUpdateWithWhereUniqueWithoutLgaInput[]
    updateMany?: PostcodeUpdateManyWithWhereWithoutLgaInput | PostcodeUpdateManyWithWhereWithoutLgaInput[]
    deleteMany?: PostcodeScalarWhereInput | PostcodeScalarWhereInput[]
  }

  export type LgaNationalityCreateNestedManyWithoutNationalityInput = {
    create?: XOR<LgaNationalityCreateWithoutNationalityInput, LgaNationalityUncheckedCreateWithoutNationalityInput> | LgaNationalityCreateWithoutNationalityInput[] | LgaNationalityUncheckedCreateWithoutNationalityInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutNationalityInput | LgaNationalityCreateOrConnectWithoutNationalityInput[]
    createMany?: LgaNationalityCreateManyNationalityInputEnvelope
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
  }

  export type LgaNationalityUncheckedCreateNestedManyWithoutNationalityInput = {
    create?: XOR<LgaNationalityCreateWithoutNationalityInput, LgaNationalityUncheckedCreateWithoutNationalityInput> | LgaNationalityCreateWithoutNationalityInput[] | LgaNationalityUncheckedCreateWithoutNationalityInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutNationalityInput | LgaNationalityCreateOrConnectWithoutNationalityInput[]
    createMany?: LgaNationalityCreateManyNationalityInputEnvelope
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
  }

  export type LgaNationalityUpdateManyWithoutNationalityNestedInput = {
    create?: XOR<LgaNationalityCreateWithoutNationalityInput, LgaNationalityUncheckedCreateWithoutNationalityInput> | LgaNationalityCreateWithoutNationalityInput[] | LgaNationalityUncheckedCreateWithoutNationalityInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutNationalityInput | LgaNationalityCreateOrConnectWithoutNationalityInput[]
    upsert?: LgaNationalityUpsertWithWhereUniqueWithoutNationalityInput | LgaNationalityUpsertWithWhereUniqueWithoutNationalityInput[]
    createMany?: LgaNationalityCreateManyNationalityInputEnvelope
    set?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    disconnect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    delete?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    update?: LgaNationalityUpdateWithWhereUniqueWithoutNationalityInput | LgaNationalityUpdateWithWhereUniqueWithoutNationalityInput[]
    updateMany?: LgaNationalityUpdateManyWithWhereWithoutNationalityInput | LgaNationalityUpdateManyWithWhereWithoutNationalityInput[]
    deleteMany?: LgaNationalityScalarWhereInput | LgaNationalityScalarWhereInput[]
  }

  export type LgaNationalityUncheckedUpdateManyWithoutNationalityNestedInput = {
    create?: XOR<LgaNationalityCreateWithoutNationalityInput, LgaNationalityUncheckedCreateWithoutNationalityInput> | LgaNationalityCreateWithoutNationalityInput[] | LgaNationalityUncheckedCreateWithoutNationalityInput[]
    connectOrCreate?: LgaNationalityCreateOrConnectWithoutNationalityInput | LgaNationalityCreateOrConnectWithoutNationalityInput[]
    upsert?: LgaNationalityUpsertWithWhereUniqueWithoutNationalityInput | LgaNationalityUpsertWithWhereUniqueWithoutNationalityInput[]
    createMany?: LgaNationalityCreateManyNationalityInputEnvelope
    set?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    disconnect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    delete?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    connect?: LgaNationalityWhereUniqueInput | LgaNationalityWhereUniqueInput[]
    update?: LgaNationalityUpdateWithWhereUniqueWithoutNationalityInput | LgaNationalityUpdateWithWhereUniqueWithoutNationalityInput[]
    updateMany?: LgaNationalityUpdateManyWithWhereWithoutNationalityInput | LgaNationalityUpdateManyWithWhereWithoutNationalityInput[]
    deleteMany?: LgaNationalityScalarWhereInput | LgaNationalityScalarWhereInput[]
  }

  export type LgaCreateNestedOneWithoutLga_nationalitiesInput = {
    create?: XOR<LgaCreateWithoutLga_nationalitiesInput, LgaUncheckedCreateWithoutLga_nationalitiesInput>
    connectOrCreate?: LgaCreateOrConnectWithoutLga_nationalitiesInput
    connect?: LgaWhereUniqueInput
  }

  export type NationalityCreateNestedOneWithoutLga_nationalitiesInput = {
    create?: XOR<NationalityCreateWithoutLga_nationalitiesInput, NationalityUncheckedCreateWithoutLga_nationalitiesInput>
    connectOrCreate?: NationalityCreateOrConnectWithoutLga_nationalitiesInput
    connect?: NationalityWhereUniqueInput
  }

  export type LgaUpdateOneRequiredWithoutLga_nationalitiesNestedInput = {
    create?: XOR<LgaCreateWithoutLga_nationalitiesInput, LgaUncheckedCreateWithoutLga_nationalitiesInput>
    connectOrCreate?: LgaCreateOrConnectWithoutLga_nationalitiesInput
    upsert?: LgaUpsertWithoutLga_nationalitiesInput
    connect?: LgaWhereUniqueInput
    update?: XOR<XOR<LgaUpdateToOneWithWhereWithoutLga_nationalitiesInput, LgaUpdateWithoutLga_nationalitiesInput>, LgaUncheckedUpdateWithoutLga_nationalitiesInput>
  }

  export type NationalityUpdateOneRequiredWithoutLga_nationalitiesNestedInput = {
    create?: XOR<NationalityCreateWithoutLga_nationalitiesInput, NationalityUncheckedCreateWithoutLga_nationalitiesInput>
    connectOrCreate?: NationalityCreateOrConnectWithoutLga_nationalitiesInput
    upsert?: NationalityUpsertWithoutLga_nationalitiesInput
    connect?: NationalityWhereUniqueInput
    update?: XOR<XOR<NationalityUpdateToOneWithWhereWithoutLga_nationalitiesInput, NationalityUpdateWithoutLga_nationalitiesInput>, NationalityUncheckedUpdateWithoutLga_nationalitiesInput>
  }

  export type LgaCreateNestedOneWithoutCouncil_infoInput = {
    create?: XOR<LgaCreateWithoutCouncil_infoInput, LgaUncheckedCreateWithoutCouncil_infoInput>
    connectOrCreate?: LgaCreateOrConnectWithoutCouncil_infoInput
    connect?: LgaWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LgaUpdateOneRequiredWithoutCouncil_infoNestedInput = {
    create?: XOR<LgaCreateWithoutCouncil_infoInput, LgaUncheckedCreateWithoutCouncil_infoInput>
    connectOrCreate?: LgaCreateOrConnectWithoutCouncil_infoInput
    upsert?: LgaUpsertWithoutCouncil_infoInput
    connect?: LgaWhereUniqueInput
    update?: XOR<XOR<LgaUpdateToOneWithWhereWithoutCouncil_infoInput, LgaUpdateWithoutCouncil_infoInput>, LgaUncheckedUpdateWithoutCouncil_infoInput>
  }

  export type LgaCreateNestedOneWithoutPostcodesInput = {
    create?: XOR<LgaCreateWithoutPostcodesInput, LgaUncheckedCreateWithoutPostcodesInput>
    connectOrCreate?: LgaCreateOrConnectWithoutPostcodesInput
    connect?: LgaWhereUniqueInput
  }

  export type LgaUpdateOneRequiredWithoutPostcodesNestedInput = {
    create?: XOR<LgaCreateWithoutPostcodesInput, LgaUncheckedCreateWithoutPostcodesInput>
    connectOrCreate?: LgaCreateOrConnectWithoutPostcodesInput
    upsert?: LgaUpsertWithoutPostcodesInput
    connect?: LgaWhereUniqueInput
    update?: XOR<XOR<LgaUpdateToOneWithWhereWithoutPostcodesInput, LgaUpdateWithoutPostcodesInput>, LgaUncheckedUpdateWithoutPostcodesInput>
  }

  export type LgaLanguageProficiencyCreateNestedManyWithoutLanguageInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLanguageInput, LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput> | LgaLanguageProficiencyCreateWithoutLanguageInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput | LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput[]
    createMany?: LgaLanguageProficiencyCreateManyLanguageInputEnvelope
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
  }

  export type LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLanguageInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLanguageInput, LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput> | LgaLanguageProficiencyCreateWithoutLanguageInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput | LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput[]
    createMany?: LgaLanguageProficiencyCreateManyLanguageInputEnvelope
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
  }

  export type LgaLanguageProficiencyUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLanguageInput, LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput> | LgaLanguageProficiencyCreateWithoutLanguageInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput | LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput[]
    upsert?: LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLanguageInput | LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: LgaLanguageProficiencyCreateManyLanguageInputEnvelope
    set?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    disconnect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    delete?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    update?: LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLanguageInput | LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: LgaLanguageProficiencyUpdateManyWithWhereWithoutLanguageInput | LgaLanguageProficiencyUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: LgaLanguageProficiencyScalarWhereInput | LgaLanguageProficiencyScalarWhereInput[]
  }

  export type LgaLanguageProficiencyUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?: XOR<LgaLanguageProficiencyCreateWithoutLanguageInput, LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput> | LgaLanguageProficiencyCreateWithoutLanguageInput[] | LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput[]
    connectOrCreate?: LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput | LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput[]
    upsert?: LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLanguageInput | LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLanguageInput[]
    createMany?: LgaLanguageProficiencyCreateManyLanguageInputEnvelope
    set?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    disconnect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    delete?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    connect?: LgaLanguageProficiencyWhereUniqueInput | LgaLanguageProficiencyWhereUniqueInput[]
    update?: LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLanguageInput | LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLanguageInput[]
    updateMany?: LgaLanguageProficiencyUpdateManyWithWhereWithoutLanguageInput | LgaLanguageProficiencyUpdateManyWithWhereWithoutLanguageInput[]
    deleteMany?: LgaLanguageProficiencyScalarWhereInput | LgaLanguageProficiencyScalarWhereInput[]
  }

  export type LanguageCreateNestedOneWithoutProficienciesInput = {
    create?: XOR<LanguageCreateWithoutProficienciesInput, LanguageUncheckedCreateWithoutProficienciesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutProficienciesInput
    connect?: LanguageWhereUniqueInput
  }

  export type LgaCreateNestedOneWithoutLanguage_proficienciesInput = {
    create?: XOR<LgaCreateWithoutLanguage_proficienciesInput, LgaUncheckedCreateWithoutLanguage_proficienciesInput>
    connectOrCreate?: LgaCreateOrConnectWithoutLanguage_proficienciesInput
    connect?: LgaWhereUniqueInput
  }

  export type LanguageUpdateOneRequiredWithoutProficienciesNestedInput = {
    create?: XOR<LanguageCreateWithoutProficienciesInput, LanguageUncheckedCreateWithoutProficienciesInput>
    connectOrCreate?: LanguageCreateOrConnectWithoutProficienciesInput
    upsert?: LanguageUpsertWithoutProficienciesInput
    connect?: LanguageWhereUniqueInput
    update?: XOR<XOR<LanguageUpdateToOneWithWhereWithoutProficienciesInput, LanguageUpdateWithoutProficienciesInput>, LanguageUncheckedUpdateWithoutProficienciesInput>
  }

  export type LgaUpdateOneRequiredWithoutLanguage_proficienciesNestedInput = {
    create?: XOR<LgaCreateWithoutLanguage_proficienciesInput, LgaUncheckedCreateWithoutLanguage_proficienciesInput>
    connectOrCreate?: LgaCreateOrConnectWithoutLanguage_proficienciesInput
    upsert?: LgaUpsertWithoutLanguage_proficienciesInput
    connect?: LgaWhereUniqueInput
    update?: XOR<XOR<LgaUpdateToOneWithWhereWithoutLanguage_proficienciesInput, LgaUpdateWithoutLanguage_proficienciesInput>, LgaUncheckedUpdateWithoutLanguage_proficienciesInput>
  }

  export type LgaCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<LgaCreateWithoutStatisticsInput, LgaUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: LgaCreateOrConnectWithoutStatisticsInput
    connect?: LgaWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LgaUpdateOneRequiredWithoutStatisticsNestedInput = {
    create?: XOR<LgaCreateWithoutStatisticsInput, LgaUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: LgaCreateOrConnectWithoutStatisticsInput
    upsert?: LgaUpsertWithoutStatisticsInput
    connect?: LgaWhereUniqueInput
    update?: XOR<XOR<LgaUpdateToOneWithWhereWithoutStatisticsInput, LgaUpdateWithoutStatisticsInput>, LgaUncheckedUpdateWithoutStatisticsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EventCreateWithoutVenueInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    category?: CategoryCreateNestedOneWithoutEventsInput
    logo?: LogoCreateNestedOneWithoutEventsInput
    organizer?: OrganizerCreateNestedOneWithoutEventsInput
    websites?: WebsiteCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutVenueInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    organizer_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    websites?: WebsiteUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutVenueInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput>
  }

  export type EventCreateManyVenueInputEnvelope = {
    data: EventCreateManyVenueInput | EventCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutVenueInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutVenueInput, EventUncheckedUpdateWithoutVenueInput>
    create: XOR<EventCreateWithoutVenueInput, EventUncheckedCreateWithoutVenueInput>
  }

  export type EventUpdateWithWhereUniqueWithoutVenueInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutVenueInput, EventUncheckedUpdateWithoutVenueInput>
  }

  export type EventUpdateManyWithWhereWithoutVenueInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutVenueInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    event_id?: StringFilter<"Event"> | string
    event_name?: StringFilter<"Event"> | string
    event_description?: StringFilter<"Event"> | string
    start_datetime?: DateTimeFilter<"Event"> | Date | string
    end_datetime?: DateTimeFilter<"Event"> | Date | string
    event_summary?: StringFilter<"Event"> | string
    category_id?: StringNullableFilter<"Event"> | string | null
    organizer_id?: StringNullableFilter<"Event"> | string | null
    venue_id?: StringNullableFilter<"Event"> | string | null
    logo_id?: BigIntNullableFilter<"Event"> | bigint | number | null
    event_status?: StringFilter<"Event"> | string
    event_url?: StringNullableFilter<"Event"> | string | null
    is_free_event?: BoolFilter<"Event"> | boolean
    community_friendly?: BoolFilter<"Event"> | boolean
    predicted_community_friendly?: BoolFilter<"Event"> | boolean
  }

  export type EventCreateWithoutCategoryInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    logo?: LogoCreateNestedOneWithoutEventsInput
    organizer?: OrganizerCreateNestedOneWithoutEventsInput
    venue?: VenueCreateNestedOneWithoutEventsInput
    websites?: WebsiteCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCategoryInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    organizer_id?: string | null
    venue_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    websites?: WebsiteUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCategoryInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput>
  }

  export type EventCreateManyCategoryInputEnvelope = {
    data: EventCreateManyCategoryInput | EventCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCategoryInput, EventUncheckedUpdateWithoutCategoryInput>
    create: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCategoryInput, EventUncheckedUpdateWithoutCategoryInput>
  }

  export type EventUpdateManyWithWhereWithoutCategoryInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EventCreateWithoutOrganizerInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    category?: CategoryCreateNestedOneWithoutEventsInput
    logo?: LogoCreateNestedOneWithoutEventsInput
    venue?: VenueCreateNestedOneWithoutEventsInput
    websites?: WebsiteCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutOrganizerInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    venue_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    websites?: WebsiteUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutOrganizerInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput>
  }

  export type EventCreateManyOrganizerInputEnvelope = {
    data: EventCreateManyOrganizerInput | EventCreateManyOrganizerInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutOrganizerInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutOrganizerInput, EventUncheckedUpdateWithoutOrganizerInput>
    create: XOR<EventCreateWithoutOrganizerInput, EventUncheckedCreateWithoutOrganizerInput>
  }

  export type EventUpdateWithWhereUniqueWithoutOrganizerInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutOrganizerInput, EventUncheckedUpdateWithoutOrganizerInput>
  }

  export type EventUpdateManyWithWhereWithoutOrganizerInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutOrganizerInput>
  }

  export type EventCreateWithoutLogoInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    category?: CategoryCreateNestedOneWithoutEventsInput
    organizer?: OrganizerCreateNestedOneWithoutEventsInput
    venue?: VenueCreateNestedOneWithoutEventsInput
    websites?: WebsiteCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutLogoInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    organizer_id?: string | null
    venue_id?: string | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    websites?: WebsiteUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutLogoInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutLogoInput, EventUncheckedCreateWithoutLogoInput>
  }

  export type EventCreateManyLogoInputEnvelope = {
    data: EventCreateManyLogoInput | EventCreateManyLogoInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutLogoInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutLogoInput, EventUncheckedUpdateWithoutLogoInput>
    create: XOR<EventCreateWithoutLogoInput, EventUncheckedCreateWithoutLogoInput>
  }

  export type EventUpdateWithWhereUniqueWithoutLogoInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutLogoInput, EventUncheckedUpdateWithoutLogoInput>
  }

  export type EventUpdateManyWithWhereWithoutLogoInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutLogoInput>
  }

  export type CategoryCreateWithoutEventsInput = {
    category_id: string
    category_name: string
  }

  export type CategoryUncheckedCreateWithoutEventsInput = {
    category_id: string
    category_name: string
  }

  export type CategoryCreateOrConnectWithoutEventsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutEventsInput, CategoryUncheckedCreateWithoutEventsInput>
  }

  export type LogoCreateWithoutEventsInput = {
    logo_id: bigint | number
    logo_url: string
    logo_width: number
    logo_height: number
    logo_aspect_ratio: number
  }

  export type LogoUncheckedCreateWithoutEventsInput = {
    logo_id: bigint | number
    logo_url: string
    logo_width: number
    logo_height: number
    logo_aspect_ratio: number
  }

  export type LogoCreateOrConnectWithoutEventsInput = {
    where: LogoWhereUniqueInput
    create: XOR<LogoCreateWithoutEventsInput, LogoUncheckedCreateWithoutEventsInput>
  }

  export type OrganizerCreateWithoutEventsInput = {
    organizer_id: string
    organizer_name: string
    organizer_url: string
  }

  export type OrganizerUncheckedCreateWithoutEventsInput = {
    organizer_id: string
    organizer_name: string
    organizer_url: string
  }

  export type OrganizerCreateOrConnectWithoutEventsInput = {
    where: OrganizerWhereUniqueInput
    create: XOR<OrganizerCreateWithoutEventsInput, OrganizerUncheckedCreateWithoutEventsInput>
  }

  export type VenueCreateWithoutEventsInput = {
    venue_id: string
    venue_name: string
    venue_address: string
    venue_city: string
    venue_latitude: number
    venue_longitude: number
    venue_postcode: number
  }

  export type VenueUncheckedCreateWithoutEventsInput = {
    venue_id: string
    venue_name: string
    venue_address: string
    venue_city: string
    venue_latitude: number
    venue_longitude: number
    venue_postcode: number
  }

  export type VenueCreateOrConnectWithoutEventsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
  }

  export type WebsiteCreateWithoutEventInput = {
    event_url: string
  }

  export type WebsiteUncheckedCreateWithoutEventInput = {
    event_url: string
  }

  export type WebsiteCreateOrConnectWithoutEventInput = {
    where: WebsiteWhereUniqueInput
    create: XOR<WebsiteCreateWithoutEventInput, WebsiteUncheckedCreateWithoutEventInput>
  }

  export type WebsiteCreateManyEventInputEnvelope = {
    data: WebsiteCreateManyEventInput | WebsiteCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutEventsInput = {
    update: XOR<CategoryUpdateWithoutEventsInput, CategoryUncheckedUpdateWithoutEventsInput>
    create: XOR<CategoryCreateWithoutEventsInput, CategoryUncheckedCreateWithoutEventsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutEventsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutEventsInput, CategoryUncheckedUpdateWithoutEventsInput>
  }

  export type CategoryUpdateWithoutEventsInput = {
    category_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutEventsInput = {
    category_id?: StringFieldUpdateOperationsInput | string
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type LogoUpsertWithoutEventsInput = {
    update: XOR<LogoUpdateWithoutEventsInput, LogoUncheckedUpdateWithoutEventsInput>
    create: XOR<LogoCreateWithoutEventsInput, LogoUncheckedCreateWithoutEventsInput>
    where?: LogoWhereInput
  }

  export type LogoUpdateToOneWithWhereWithoutEventsInput = {
    where?: LogoWhereInput
    data: XOR<LogoUpdateWithoutEventsInput, LogoUncheckedUpdateWithoutEventsInput>
  }

  export type LogoUpdateWithoutEventsInput = {
    logo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    logo_url?: StringFieldUpdateOperationsInput | string
    logo_width?: IntFieldUpdateOperationsInput | number
    logo_height?: IntFieldUpdateOperationsInput | number
    logo_aspect_ratio?: FloatFieldUpdateOperationsInput | number
  }

  export type LogoUncheckedUpdateWithoutEventsInput = {
    logo_id?: BigIntFieldUpdateOperationsInput | bigint | number
    logo_url?: StringFieldUpdateOperationsInput | string
    logo_width?: IntFieldUpdateOperationsInput | number
    logo_height?: IntFieldUpdateOperationsInput | number
    logo_aspect_ratio?: FloatFieldUpdateOperationsInput | number
  }

  export type OrganizerUpsertWithoutEventsInput = {
    update: XOR<OrganizerUpdateWithoutEventsInput, OrganizerUncheckedUpdateWithoutEventsInput>
    create: XOR<OrganizerCreateWithoutEventsInput, OrganizerUncheckedCreateWithoutEventsInput>
    where?: OrganizerWhereInput
  }

  export type OrganizerUpdateToOneWithWhereWithoutEventsInput = {
    where?: OrganizerWhereInput
    data: XOR<OrganizerUpdateWithoutEventsInput, OrganizerUncheckedUpdateWithoutEventsInput>
  }

  export type OrganizerUpdateWithoutEventsInput = {
    organizer_id?: StringFieldUpdateOperationsInput | string
    organizer_name?: StringFieldUpdateOperationsInput | string
    organizer_url?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizerUncheckedUpdateWithoutEventsInput = {
    organizer_id?: StringFieldUpdateOperationsInput | string
    organizer_name?: StringFieldUpdateOperationsInput | string
    organizer_url?: StringFieldUpdateOperationsInput | string
  }

  export type VenueUpsertWithoutEventsInput = {
    update: XOR<VenueUpdateWithoutEventsInput, VenueUncheckedUpdateWithoutEventsInput>
    create: XOR<VenueCreateWithoutEventsInput, VenueUncheckedCreateWithoutEventsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutEventsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutEventsInput, VenueUncheckedUpdateWithoutEventsInput>
  }

  export type VenueUpdateWithoutEventsInput = {
    venue_id?: StringFieldUpdateOperationsInput | string
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    venue_city?: StringFieldUpdateOperationsInput | string
    venue_latitude?: FloatFieldUpdateOperationsInput | number
    venue_longitude?: FloatFieldUpdateOperationsInput | number
    venue_postcode?: IntFieldUpdateOperationsInput | number
  }

  export type VenueUncheckedUpdateWithoutEventsInput = {
    venue_id?: StringFieldUpdateOperationsInput | string
    venue_name?: StringFieldUpdateOperationsInput | string
    venue_address?: StringFieldUpdateOperationsInput | string
    venue_city?: StringFieldUpdateOperationsInput | string
    venue_latitude?: FloatFieldUpdateOperationsInput | number
    venue_longitude?: FloatFieldUpdateOperationsInput | number
    venue_postcode?: IntFieldUpdateOperationsInput | number
  }

  export type WebsiteUpsertWithWhereUniqueWithoutEventInput = {
    where: WebsiteWhereUniqueInput
    update: XOR<WebsiteUpdateWithoutEventInput, WebsiteUncheckedUpdateWithoutEventInput>
    create: XOR<WebsiteCreateWithoutEventInput, WebsiteUncheckedCreateWithoutEventInput>
  }

  export type WebsiteUpdateWithWhereUniqueWithoutEventInput = {
    where: WebsiteWhereUniqueInput
    data: XOR<WebsiteUpdateWithoutEventInput, WebsiteUncheckedUpdateWithoutEventInput>
  }

  export type WebsiteUpdateManyWithWhereWithoutEventInput = {
    where: WebsiteScalarWhereInput
    data: XOR<WebsiteUpdateManyMutationInput, WebsiteUncheckedUpdateManyWithoutEventInput>
  }

  export type WebsiteScalarWhereInput = {
    AND?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
    OR?: WebsiteScalarWhereInput[]
    NOT?: WebsiteScalarWhereInput | WebsiteScalarWhereInput[]
    event_url?: StringFilter<"Website"> | string
    event_id?: StringFilter<"Website"> | string
  }

  export type EventCreateWithoutWebsitesInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
    category?: CategoryCreateNestedOneWithoutEventsInput
    logo?: LogoCreateNestedOneWithoutEventsInput
    organizer?: OrganizerCreateNestedOneWithoutEventsInput
    venue?: VenueCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutWebsitesInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    organizer_id?: string | null
    venue_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
  }

  export type EventCreateOrConnectWithoutWebsitesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutWebsitesInput, EventUncheckedCreateWithoutWebsitesInput>
  }

  export type EventUpsertWithoutWebsitesInput = {
    update: XOR<EventUpdateWithoutWebsitesInput, EventUncheckedUpdateWithoutWebsitesInput>
    create: XOR<EventCreateWithoutWebsitesInput, EventUncheckedCreateWithoutWebsitesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutWebsitesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutWebsitesInput, EventUncheckedUpdateWithoutWebsitesInput>
  }

  export type EventUpdateWithoutWebsitesInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneWithoutEventsNestedInput
    logo?: LogoUpdateOneWithoutEventsNestedInput
    organizer?: OrganizerUpdateOneWithoutEventsNestedInput
    venue?: VenueUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutWebsitesInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCreateWithoutProviderInput = {
    course_id: number
    course_title: string
    course_code: string
    qualification_level: string
    course_type: string
    government_subsidised: boolean
    apprenticeship: boolean
    traineeship: boolean
    entry_requirements: string
    description: string
    is_english_course: boolean
  }

  export type CourseUncheckedCreateWithoutProviderInput = {
    course_id: number
    course_title: string
    course_code: string
    qualification_level: string
    course_type: string
    government_subsidised: boolean
    apprenticeship: boolean
    traineeship: boolean
    entry_requirements: string
    description: string
    is_english_course: boolean
  }

  export type CourseCreateOrConnectWithoutProviderInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutProviderInput, CourseUncheckedCreateWithoutProviderInput>
  }

  export type CourseCreateManyProviderInputEnvelope = {
    data: CourseCreateManyProviderInput | CourseCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutProviderInput = {
    geographic_id: number
    address_line_1: string
    suburb: string
    postcode: number
    latitude: number
    longitude: number
    full_address: string
    region_name: string
    local_government_authority: string
  }

  export type LocationUncheckedCreateWithoutProviderInput = {
    geographic_id: number
    address_line_1: string
    suburb: string
    postcode: number
    latitude: number
    longitude: number
    full_address: string
    region_name: string
    local_government_authority: string
  }

  export type LocationCreateOrConnectWithoutProviderInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProviderInput, LocationUncheckedCreateWithoutProviderInput>
  }

  export type LocationCreateManyProviderInputEnvelope = {
    data: LocationCreateManyProviderInput | LocationCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutProviderInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutProviderInput, CourseUncheckedUpdateWithoutProviderInput>
    create: XOR<CourseCreateWithoutProviderInput, CourseUncheckedCreateWithoutProviderInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutProviderInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutProviderInput, CourseUncheckedUpdateWithoutProviderInput>
  }

  export type CourseUpdateManyWithWhereWithoutProviderInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutProviderInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    course_id?: IntFilter<"Course"> | number
    provider_id?: IntFilter<"Course"> | number
    course_title?: StringFilter<"Course"> | string
    course_code?: StringFilter<"Course"> | string
    qualification_level?: StringFilter<"Course"> | string
    course_type?: StringFilter<"Course"> | string
    government_subsidised?: BoolFilter<"Course"> | boolean
    apprenticeship?: BoolFilter<"Course"> | boolean
    traineeship?: BoolFilter<"Course"> | boolean
    entry_requirements?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    is_english_course?: BoolFilter<"Course"> | boolean
  }

  export type LocationUpsertWithWhereUniqueWithoutProviderInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutProviderInput, LocationUncheckedUpdateWithoutProviderInput>
    create: XOR<LocationCreateWithoutProviderInput, LocationUncheckedCreateWithoutProviderInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutProviderInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutProviderInput, LocationUncheckedUpdateWithoutProviderInput>
  }

  export type LocationUpdateManyWithWhereWithoutProviderInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutProviderInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    geographic_id?: IntFilter<"Location"> | number
    provider_id?: IntFilter<"Location"> | number
    address_line_1?: StringFilter<"Location"> | string
    suburb?: StringFilter<"Location"> | string
    postcode?: IntFilter<"Location"> | number
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    full_address?: StringFilter<"Location"> | string
    region_name?: StringFilter<"Location"> | string
    local_government_authority?: StringFilter<"Location"> | string
  }

  export type ProviderCreateWithoutLocationsInput = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag?: string | null
    asqa_code: number
    url?: string | null
    email?: string | null
    courses?: CourseCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutLocationsInput = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag?: string | null
    asqa_code: number
    url?: string | null
    email?: string | null
    courses?: CourseUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutLocationsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutLocationsInput, ProviderUncheckedCreateWithoutLocationsInput>
  }

  export type ProviderUpsertWithoutLocationsInput = {
    update: XOR<ProviderUpdateWithoutLocationsInput, ProviderUncheckedUpdateWithoutLocationsInput>
    create: XOR<ProviderCreateWithoutLocationsInput, ProviderUncheckedCreateWithoutLocationsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutLocationsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutLocationsInput, ProviderUncheckedUpdateWithoutLocationsInput>
  }

  export type ProviderUpdateWithoutLocationsInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutLocationsInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    courses?: CourseUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateWithoutCoursesInput = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag?: string | null
    asqa_code: number
    url?: string | null
    email?: string | null
    locations?: LocationCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutCoursesInput = {
    provider_id: number
    provider_name: string
    site_name: string
    government_subsidised: string
    subsidy_tag?: string | null
    asqa_code: number
    url?: string | null
    email?: string | null
    locations?: LocationUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutCoursesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutCoursesInput, ProviderUncheckedCreateWithoutCoursesInput>
  }

  export type ProviderUpsertWithoutCoursesInput = {
    update: XOR<ProviderUpdateWithoutCoursesInput, ProviderUncheckedUpdateWithoutCoursesInput>
    create: XOR<ProviderCreateWithoutCoursesInput, ProviderUncheckedCreateWithoutCoursesInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutCoursesInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutCoursesInput, ProviderUncheckedUpdateWithoutCoursesInput>
  }

  export type ProviderUpdateWithoutCoursesInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutCoursesInput = {
    provider_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    site_name?: StringFieldUpdateOperationsInput | string
    government_subsidised?: StringFieldUpdateOperationsInput | string
    subsidy_tag?: NullableStringFieldUpdateOperationsInput | string | null
    asqa_code?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    locations?: LocationUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type CouncilInfoCreateWithoutLgaInput = {
    council_name?: string | null
    council_info?: string | null
    address?: string | null
    suburb?: string | null
    postcode?: number | null
    phone?: string | null
    email?: string | null
    website?: string | null
  }

  export type CouncilInfoUncheckedCreateWithoutLgaInput = {
    council_name?: string | null
    council_info?: string | null
    address?: string | null
    suburb?: string | null
    postcode?: number | null
    phone?: string | null
    email?: string | null
    website?: string | null
  }

  export type CouncilInfoCreateOrConnectWithoutLgaInput = {
    where: CouncilInfoWhereUniqueInput
    create: XOR<CouncilInfoCreateWithoutLgaInput, CouncilInfoUncheckedCreateWithoutLgaInput>
  }

  export type LgaLanguageProficiencyCreateWithoutLgaInput = {
    english_profiency_level: string
    count: number
    language: LanguageCreateNestedOneWithoutProficienciesInput
  }

  export type LgaLanguageProficiencyUncheckedCreateWithoutLgaInput = {
    lga_language_prof_id?: number
    language_id: number
    english_profiency_level: string
    count: number
  }

  export type LgaLanguageProficiencyCreateOrConnectWithoutLgaInput = {
    where: LgaLanguageProficiencyWhereUniqueInput
    create: XOR<LgaLanguageProficiencyCreateWithoutLgaInput, LgaLanguageProficiencyUncheckedCreateWithoutLgaInput>
  }

  export type LgaLanguageProficiencyCreateManyLgaInputEnvelope = {
    data: LgaLanguageProficiencyCreateManyLgaInput | LgaLanguageProficiencyCreateManyLgaInput[]
    skipDuplicates?: boolean
  }

  export type LgaNationalityCreateWithoutLgaInput = {
    count: number
    nationality: NationalityCreateNestedOneWithoutLga_nationalitiesInput
  }

  export type LgaNationalityUncheckedCreateWithoutLgaInput = {
    lga_nationality_id?: number
    nationality_id: number
    count: number
  }

  export type LgaNationalityCreateOrConnectWithoutLgaInput = {
    where: LgaNationalityWhereUniqueInput
    create: XOR<LgaNationalityCreateWithoutLgaInput, LgaNationalityUncheckedCreateWithoutLgaInput>
  }

  export type LgaNationalityCreateManyLgaInputEnvelope = {
    data: LgaNationalityCreateManyLgaInput | LgaNationalityCreateManyLgaInput[]
    skipDuplicates?: boolean
  }

  export type LgaStatisticsCreateWithoutLgaInput = {
    total_businesses?: number | null
    total_employed_over_15?: number | null
    born_overseas?: number | null
    pct_arrived_within_5_years?: number | null
    pct_proficient_english?: number | null
    percent_speaks_other_lang_at_home?: number | null
    median_age_years?: number | null
    pct_completed_year_12?: number | null
    pct_certificate?: number | null
    pct_bachelor_degree?: number | null
    pct_postgraduate?: number | null
    pct_managers?: number | null
    pct_professionals?: number | null
    pct_labourers?: number | null
  }

  export type LgaStatisticsUncheckedCreateWithoutLgaInput = {
    total_businesses?: number | null
    total_employed_over_15?: number | null
    born_overseas?: number | null
    pct_arrived_within_5_years?: number | null
    pct_proficient_english?: number | null
    percent_speaks_other_lang_at_home?: number | null
    median_age_years?: number | null
    pct_completed_year_12?: number | null
    pct_certificate?: number | null
    pct_bachelor_degree?: number | null
    pct_postgraduate?: number | null
    pct_managers?: number | null
    pct_professionals?: number | null
    pct_labourers?: number | null
  }

  export type LgaStatisticsCreateOrConnectWithoutLgaInput = {
    where: LgaStatisticsWhereUniqueInput
    create: XOR<LgaStatisticsCreateWithoutLgaInput, LgaStatisticsUncheckedCreateWithoutLgaInput>
  }

  export type PostcodeCreateWithoutLgaInput = {
    postcode: number
    suburb: string
    latitude: number
    longitude: number
  }

  export type PostcodeUncheckedCreateWithoutLgaInput = {
    postcode: number
    suburb: string
    latitude: number
    longitude: number
  }

  export type PostcodeCreateOrConnectWithoutLgaInput = {
    where: PostcodeWhereUniqueInput
    create: XOR<PostcodeCreateWithoutLgaInput, PostcodeUncheckedCreateWithoutLgaInput>
  }

  export type PostcodeCreateManyLgaInputEnvelope = {
    data: PostcodeCreateManyLgaInput | PostcodeCreateManyLgaInput[]
    skipDuplicates?: boolean
  }

  export type CouncilInfoUpsertWithoutLgaInput = {
    update: XOR<CouncilInfoUpdateWithoutLgaInput, CouncilInfoUncheckedUpdateWithoutLgaInput>
    create: XOR<CouncilInfoCreateWithoutLgaInput, CouncilInfoUncheckedCreateWithoutLgaInput>
    where?: CouncilInfoWhereInput
  }

  export type CouncilInfoUpdateToOneWithWhereWithoutLgaInput = {
    where?: CouncilInfoWhereInput
    data: XOR<CouncilInfoUpdateWithoutLgaInput, CouncilInfoUncheckedUpdateWithoutLgaInput>
  }

  export type CouncilInfoUpdateWithoutLgaInput = {
    council_name?: NullableStringFieldUpdateOperationsInput | string | null
    council_info?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    suburb?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouncilInfoUncheckedUpdateWithoutLgaInput = {
    council_name?: NullableStringFieldUpdateOperationsInput | string | null
    council_info?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    suburb?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLgaInput = {
    where: LgaLanguageProficiencyWhereUniqueInput
    update: XOR<LgaLanguageProficiencyUpdateWithoutLgaInput, LgaLanguageProficiencyUncheckedUpdateWithoutLgaInput>
    create: XOR<LgaLanguageProficiencyCreateWithoutLgaInput, LgaLanguageProficiencyUncheckedCreateWithoutLgaInput>
  }

  export type LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLgaInput = {
    where: LgaLanguageProficiencyWhereUniqueInput
    data: XOR<LgaLanguageProficiencyUpdateWithoutLgaInput, LgaLanguageProficiencyUncheckedUpdateWithoutLgaInput>
  }

  export type LgaLanguageProficiencyUpdateManyWithWhereWithoutLgaInput = {
    where: LgaLanguageProficiencyScalarWhereInput
    data: XOR<LgaLanguageProficiencyUpdateManyMutationInput, LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaInput>
  }

  export type LgaLanguageProficiencyScalarWhereInput = {
    AND?: LgaLanguageProficiencyScalarWhereInput | LgaLanguageProficiencyScalarWhereInput[]
    OR?: LgaLanguageProficiencyScalarWhereInput[]
    NOT?: LgaLanguageProficiencyScalarWhereInput | LgaLanguageProficiencyScalarWhereInput[]
    lga_language_prof_id?: IntFilter<"LgaLanguageProficiency"> | number
    lga_code?: IntFilter<"LgaLanguageProficiency"> | number
    language_id?: IntFilter<"LgaLanguageProficiency"> | number
    english_profiency_level?: StringFilter<"LgaLanguageProficiency"> | string
    count?: IntFilter<"LgaLanguageProficiency"> | number
  }

  export type LgaNationalityUpsertWithWhereUniqueWithoutLgaInput = {
    where: LgaNationalityWhereUniqueInput
    update: XOR<LgaNationalityUpdateWithoutLgaInput, LgaNationalityUncheckedUpdateWithoutLgaInput>
    create: XOR<LgaNationalityCreateWithoutLgaInput, LgaNationalityUncheckedCreateWithoutLgaInput>
  }

  export type LgaNationalityUpdateWithWhereUniqueWithoutLgaInput = {
    where: LgaNationalityWhereUniqueInput
    data: XOR<LgaNationalityUpdateWithoutLgaInput, LgaNationalityUncheckedUpdateWithoutLgaInput>
  }

  export type LgaNationalityUpdateManyWithWhereWithoutLgaInput = {
    where: LgaNationalityScalarWhereInput
    data: XOR<LgaNationalityUpdateManyMutationInput, LgaNationalityUncheckedUpdateManyWithoutLgaInput>
  }

  export type LgaNationalityScalarWhereInput = {
    AND?: LgaNationalityScalarWhereInput | LgaNationalityScalarWhereInput[]
    OR?: LgaNationalityScalarWhereInput[]
    NOT?: LgaNationalityScalarWhereInput | LgaNationalityScalarWhereInput[]
    lga_nationality_id?: IntFilter<"LgaNationality"> | number
    lga_code?: IntFilter<"LgaNationality"> | number
    nationality_id?: IntFilter<"LgaNationality"> | number
    count?: IntFilter<"LgaNationality"> | number
  }

  export type LgaStatisticsUpsertWithoutLgaInput = {
    update: XOR<LgaStatisticsUpdateWithoutLgaInput, LgaStatisticsUncheckedUpdateWithoutLgaInput>
    create: XOR<LgaStatisticsCreateWithoutLgaInput, LgaStatisticsUncheckedCreateWithoutLgaInput>
    where?: LgaStatisticsWhereInput
  }

  export type LgaStatisticsUpdateToOneWithWhereWithoutLgaInput = {
    where?: LgaStatisticsWhereInput
    data: XOR<LgaStatisticsUpdateWithoutLgaInput, LgaStatisticsUncheckedUpdateWithoutLgaInput>
  }

  export type LgaStatisticsUpdateWithoutLgaInput = {
    total_businesses?: NullableIntFieldUpdateOperationsInput | number | null
    total_employed_over_15?: NullableIntFieldUpdateOperationsInput | number | null
    born_overseas?: NullableIntFieldUpdateOperationsInput | number | null
    pct_arrived_within_5_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_proficient_english?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_speaks_other_lang_at_home?: NullableFloatFieldUpdateOperationsInput | number | null
    median_age_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_completed_year_12?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_certificate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_bachelor_degree?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_postgraduate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_managers?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_professionals?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_labourers?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LgaStatisticsUncheckedUpdateWithoutLgaInput = {
    total_businesses?: NullableIntFieldUpdateOperationsInput | number | null
    total_employed_over_15?: NullableIntFieldUpdateOperationsInput | number | null
    born_overseas?: NullableIntFieldUpdateOperationsInput | number | null
    pct_arrived_within_5_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_proficient_english?: NullableFloatFieldUpdateOperationsInput | number | null
    percent_speaks_other_lang_at_home?: NullableFloatFieldUpdateOperationsInput | number | null
    median_age_years?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_completed_year_12?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_certificate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_bachelor_degree?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_postgraduate?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_managers?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_professionals?: NullableFloatFieldUpdateOperationsInput | number | null
    pct_labourers?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PostcodeUpsertWithWhereUniqueWithoutLgaInput = {
    where: PostcodeWhereUniqueInput
    update: XOR<PostcodeUpdateWithoutLgaInput, PostcodeUncheckedUpdateWithoutLgaInput>
    create: XOR<PostcodeCreateWithoutLgaInput, PostcodeUncheckedCreateWithoutLgaInput>
  }

  export type PostcodeUpdateWithWhereUniqueWithoutLgaInput = {
    where: PostcodeWhereUniqueInput
    data: XOR<PostcodeUpdateWithoutLgaInput, PostcodeUncheckedUpdateWithoutLgaInput>
  }

  export type PostcodeUpdateManyWithWhereWithoutLgaInput = {
    where: PostcodeScalarWhereInput
    data: XOR<PostcodeUpdateManyMutationInput, PostcodeUncheckedUpdateManyWithoutLgaInput>
  }

  export type PostcodeScalarWhereInput = {
    AND?: PostcodeScalarWhereInput | PostcodeScalarWhereInput[]
    OR?: PostcodeScalarWhereInput[]
    NOT?: PostcodeScalarWhereInput | PostcodeScalarWhereInput[]
    postcode?: IntFilter<"Postcode"> | number
    suburb?: StringFilter<"Postcode"> | string
    latitude?: FloatFilter<"Postcode"> | number
    longitude?: FloatFilter<"Postcode"> | number
    lga_code?: IntFilter<"Postcode"> | number
  }

  export type LgaNationalityCreateWithoutNationalityInput = {
    count: number
    lga: LgaCreateNestedOneWithoutLga_nationalitiesInput
  }

  export type LgaNationalityUncheckedCreateWithoutNationalityInput = {
    lga_nationality_id?: number
    lga_code: number
    count: number
  }

  export type LgaNationalityCreateOrConnectWithoutNationalityInput = {
    where: LgaNationalityWhereUniqueInput
    create: XOR<LgaNationalityCreateWithoutNationalityInput, LgaNationalityUncheckedCreateWithoutNationalityInput>
  }

  export type LgaNationalityCreateManyNationalityInputEnvelope = {
    data: LgaNationalityCreateManyNationalityInput | LgaNationalityCreateManyNationalityInput[]
    skipDuplicates?: boolean
  }

  export type LgaNationalityUpsertWithWhereUniqueWithoutNationalityInput = {
    where: LgaNationalityWhereUniqueInput
    update: XOR<LgaNationalityUpdateWithoutNationalityInput, LgaNationalityUncheckedUpdateWithoutNationalityInput>
    create: XOR<LgaNationalityCreateWithoutNationalityInput, LgaNationalityUncheckedCreateWithoutNationalityInput>
  }

  export type LgaNationalityUpdateWithWhereUniqueWithoutNationalityInput = {
    where: LgaNationalityWhereUniqueInput
    data: XOR<LgaNationalityUpdateWithoutNationalityInput, LgaNationalityUncheckedUpdateWithoutNationalityInput>
  }

  export type LgaNationalityUpdateManyWithWhereWithoutNationalityInput = {
    where: LgaNationalityScalarWhereInput
    data: XOR<LgaNationalityUpdateManyMutationInput, LgaNationalityUncheckedUpdateManyWithoutNationalityInput>
  }

  export type LgaCreateWithoutLga_nationalitiesInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeCreateNestedManyWithoutLgaInput
  }

  export type LgaUncheckedCreateWithoutLga_nationalitiesInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoUncheckedCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsUncheckedCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeUncheckedCreateNestedManyWithoutLgaInput
  }

  export type LgaCreateOrConnectWithoutLga_nationalitiesInput = {
    where: LgaWhereUniqueInput
    create: XOR<LgaCreateWithoutLga_nationalitiesInput, LgaUncheckedCreateWithoutLga_nationalitiesInput>
  }

  export type NationalityCreateWithoutLga_nationalitiesInput = {
    nationality: string
  }

  export type NationalityUncheckedCreateWithoutLga_nationalitiesInput = {
    nationality_id?: number
    nationality: string
  }

  export type NationalityCreateOrConnectWithoutLga_nationalitiesInput = {
    where: NationalityWhereUniqueInput
    create: XOR<NationalityCreateWithoutLga_nationalitiesInput, NationalityUncheckedCreateWithoutLga_nationalitiesInput>
  }

  export type LgaUpsertWithoutLga_nationalitiesInput = {
    update: XOR<LgaUpdateWithoutLga_nationalitiesInput, LgaUncheckedUpdateWithoutLga_nationalitiesInput>
    create: XOR<LgaCreateWithoutLga_nationalitiesInput, LgaUncheckedCreateWithoutLga_nationalitiesInput>
    where?: LgaWhereInput
  }

  export type LgaUpdateToOneWithWhereWithoutLga_nationalitiesInput = {
    where?: LgaWhereInput
    data: XOR<LgaUpdateWithoutLga_nationalitiesInput, LgaUncheckedUpdateWithoutLga_nationalitiesInput>
  }

  export type LgaUpdateWithoutLga_nationalitiesInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUpdateManyWithoutLgaNestedInput
  }

  export type LgaUncheckedUpdateWithoutLga_nationalitiesInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUncheckedUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUncheckedUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUncheckedUpdateManyWithoutLgaNestedInput
  }

  export type NationalityUpsertWithoutLga_nationalitiesInput = {
    update: XOR<NationalityUpdateWithoutLga_nationalitiesInput, NationalityUncheckedUpdateWithoutLga_nationalitiesInput>
    create: XOR<NationalityCreateWithoutLga_nationalitiesInput, NationalityUncheckedCreateWithoutLga_nationalitiesInput>
    where?: NationalityWhereInput
  }

  export type NationalityUpdateToOneWithWhereWithoutLga_nationalitiesInput = {
    where?: NationalityWhereInput
    data: XOR<NationalityUpdateWithoutLga_nationalitiesInput, NationalityUncheckedUpdateWithoutLga_nationalitiesInput>
  }

  export type NationalityUpdateWithoutLga_nationalitiesInput = {
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type NationalityUncheckedUpdateWithoutLga_nationalitiesInput = {
    nationality_id?: IntFieldUpdateOperationsInput | number
    nationality?: StringFieldUpdateOperationsInput | string
  }

  export type LgaCreateWithoutCouncil_infoInput = {
    lga_code: number
    lga_name: string
    language_proficiencies?: LgaLanguageProficiencyCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeCreateNestedManyWithoutLgaInput
  }

  export type LgaUncheckedCreateWithoutCouncil_infoInput = {
    lga_code: number
    lga_name: string
    language_proficiencies?: LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityUncheckedCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsUncheckedCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeUncheckedCreateNestedManyWithoutLgaInput
  }

  export type LgaCreateOrConnectWithoutCouncil_infoInput = {
    where: LgaWhereUniqueInput
    create: XOR<LgaCreateWithoutCouncil_infoInput, LgaUncheckedCreateWithoutCouncil_infoInput>
  }

  export type LgaUpsertWithoutCouncil_infoInput = {
    update: XOR<LgaUpdateWithoutCouncil_infoInput, LgaUncheckedUpdateWithoutCouncil_infoInput>
    create: XOR<LgaCreateWithoutCouncil_infoInput, LgaUncheckedCreateWithoutCouncil_infoInput>
    where?: LgaWhereInput
  }

  export type LgaUpdateToOneWithWhereWithoutCouncil_infoInput = {
    where?: LgaWhereInput
    data: XOR<LgaUpdateWithoutCouncil_infoInput, LgaUncheckedUpdateWithoutCouncil_infoInput>
  }

  export type LgaUpdateWithoutCouncil_infoInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    language_proficiencies?: LgaLanguageProficiencyUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUpdateManyWithoutLgaNestedInput
  }

  export type LgaUncheckedUpdateWithoutCouncil_infoInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    language_proficiencies?: LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUncheckedUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUncheckedUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUncheckedUpdateManyWithoutLgaNestedInput
  }

  export type LgaCreateWithoutPostcodesInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsCreateNestedOneWithoutLgaInput
  }

  export type LgaUncheckedCreateWithoutPostcodesInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoUncheckedCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityUncheckedCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsUncheckedCreateNestedOneWithoutLgaInput
  }

  export type LgaCreateOrConnectWithoutPostcodesInput = {
    where: LgaWhereUniqueInput
    create: XOR<LgaCreateWithoutPostcodesInput, LgaUncheckedCreateWithoutPostcodesInput>
  }

  export type LgaUpsertWithoutPostcodesInput = {
    update: XOR<LgaUpdateWithoutPostcodesInput, LgaUncheckedUpdateWithoutPostcodesInput>
    create: XOR<LgaCreateWithoutPostcodesInput, LgaUncheckedCreateWithoutPostcodesInput>
    where?: LgaWhereInput
  }

  export type LgaUpdateToOneWithWhereWithoutPostcodesInput = {
    where?: LgaWhereInput
    data: XOR<LgaUpdateWithoutPostcodesInput, LgaUncheckedUpdateWithoutPostcodesInput>
  }

  export type LgaUpdateWithoutPostcodesInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUpdateOneWithoutLgaNestedInput
  }

  export type LgaUncheckedUpdateWithoutPostcodesInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUncheckedUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUncheckedUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUncheckedUpdateOneWithoutLgaNestedInput
  }

  export type LgaLanguageProficiencyCreateWithoutLanguageInput = {
    english_profiency_level: string
    count: number
    lga: LgaCreateNestedOneWithoutLanguage_proficienciesInput
  }

  export type LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput = {
    lga_language_prof_id?: number
    lga_code: number
    english_profiency_level: string
    count: number
  }

  export type LgaLanguageProficiencyCreateOrConnectWithoutLanguageInput = {
    where: LgaLanguageProficiencyWhereUniqueInput
    create: XOR<LgaLanguageProficiencyCreateWithoutLanguageInput, LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput>
  }

  export type LgaLanguageProficiencyCreateManyLanguageInputEnvelope = {
    data: LgaLanguageProficiencyCreateManyLanguageInput | LgaLanguageProficiencyCreateManyLanguageInput[]
    skipDuplicates?: boolean
  }

  export type LgaLanguageProficiencyUpsertWithWhereUniqueWithoutLanguageInput = {
    where: LgaLanguageProficiencyWhereUniqueInput
    update: XOR<LgaLanguageProficiencyUpdateWithoutLanguageInput, LgaLanguageProficiencyUncheckedUpdateWithoutLanguageInput>
    create: XOR<LgaLanguageProficiencyCreateWithoutLanguageInput, LgaLanguageProficiencyUncheckedCreateWithoutLanguageInput>
  }

  export type LgaLanguageProficiencyUpdateWithWhereUniqueWithoutLanguageInput = {
    where: LgaLanguageProficiencyWhereUniqueInput
    data: XOR<LgaLanguageProficiencyUpdateWithoutLanguageInput, LgaLanguageProficiencyUncheckedUpdateWithoutLanguageInput>
  }

  export type LgaLanguageProficiencyUpdateManyWithWhereWithoutLanguageInput = {
    where: LgaLanguageProficiencyScalarWhereInput
    data: XOR<LgaLanguageProficiencyUpdateManyMutationInput, LgaLanguageProficiencyUncheckedUpdateManyWithoutLanguageInput>
  }

  export type LanguageCreateWithoutProficienciesInput = {
    language?: string | null
  }

  export type LanguageUncheckedCreateWithoutProficienciesInput = {
    language_id?: number
    language?: string | null
  }

  export type LanguageCreateOrConnectWithoutProficienciesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutProficienciesInput, LanguageUncheckedCreateWithoutProficienciesInput>
  }

  export type LgaCreateWithoutLanguage_proficienciesInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoCreateNestedOneWithoutLgaInput
    lga_nationalities?: LgaNationalityCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeCreateNestedManyWithoutLgaInput
  }

  export type LgaUncheckedCreateWithoutLanguage_proficienciesInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoUncheckedCreateNestedOneWithoutLgaInput
    lga_nationalities?: LgaNationalityUncheckedCreateNestedManyWithoutLgaInput
    statistics?: LgaStatisticsUncheckedCreateNestedOneWithoutLgaInput
    postcodes?: PostcodeUncheckedCreateNestedManyWithoutLgaInput
  }

  export type LgaCreateOrConnectWithoutLanguage_proficienciesInput = {
    where: LgaWhereUniqueInput
    create: XOR<LgaCreateWithoutLanguage_proficienciesInput, LgaUncheckedCreateWithoutLanguage_proficienciesInput>
  }

  export type LanguageUpsertWithoutProficienciesInput = {
    update: XOR<LanguageUpdateWithoutProficienciesInput, LanguageUncheckedUpdateWithoutProficienciesInput>
    create: XOR<LanguageCreateWithoutProficienciesInput, LanguageUncheckedCreateWithoutProficienciesInput>
    where?: LanguageWhereInput
  }

  export type LanguageUpdateToOneWithWhereWithoutProficienciesInput = {
    where?: LanguageWhereInput
    data: XOR<LanguageUpdateWithoutProficienciesInput, LanguageUncheckedUpdateWithoutProficienciesInput>
  }

  export type LanguageUpdateWithoutProficienciesInput = {
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LanguageUncheckedUpdateWithoutProficienciesInput = {
    language_id?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LgaUpsertWithoutLanguage_proficienciesInput = {
    update: XOR<LgaUpdateWithoutLanguage_proficienciesInput, LgaUncheckedUpdateWithoutLanguage_proficienciesInput>
    create: XOR<LgaCreateWithoutLanguage_proficienciesInput, LgaUncheckedCreateWithoutLanguage_proficienciesInput>
    where?: LgaWhereInput
  }

  export type LgaUpdateToOneWithWhereWithoutLanguage_proficienciesInput = {
    where?: LgaWhereInput
    data: XOR<LgaUpdateWithoutLanguage_proficienciesInput, LgaUncheckedUpdateWithoutLanguage_proficienciesInput>
  }

  export type LgaUpdateWithoutLanguage_proficienciesInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUpdateOneWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUpdateManyWithoutLgaNestedInput
  }

  export type LgaUncheckedUpdateWithoutLanguage_proficienciesInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUncheckedUpdateOneWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUncheckedUpdateManyWithoutLgaNestedInput
    statistics?: LgaStatisticsUncheckedUpdateOneWithoutLgaNestedInput
    postcodes?: PostcodeUncheckedUpdateManyWithoutLgaNestedInput
  }

  export type LgaCreateWithoutStatisticsInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityCreateNestedManyWithoutLgaInput
    postcodes?: PostcodeCreateNestedManyWithoutLgaInput
  }

  export type LgaUncheckedCreateWithoutStatisticsInput = {
    lga_code: number
    lga_name: string
    council_info?: CouncilInfoUncheckedCreateNestedOneWithoutLgaInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedCreateNestedManyWithoutLgaInput
    lga_nationalities?: LgaNationalityUncheckedCreateNestedManyWithoutLgaInput
    postcodes?: PostcodeUncheckedCreateNestedManyWithoutLgaInput
  }

  export type LgaCreateOrConnectWithoutStatisticsInput = {
    where: LgaWhereUniqueInput
    create: XOR<LgaCreateWithoutStatisticsInput, LgaUncheckedCreateWithoutStatisticsInput>
  }

  export type LgaUpsertWithoutStatisticsInput = {
    update: XOR<LgaUpdateWithoutStatisticsInput, LgaUncheckedUpdateWithoutStatisticsInput>
    create: XOR<LgaCreateWithoutStatisticsInput, LgaUncheckedCreateWithoutStatisticsInput>
    where?: LgaWhereInput
  }

  export type LgaUpdateToOneWithWhereWithoutStatisticsInput = {
    where?: LgaWhereInput
    data: XOR<LgaUpdateWithoutStatisticsInput, LgaUncheckedUpdateWithoutStatisticsInput>
  }

  export type LgaUpdateWithoutStatisticsInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUpdateManyWithoutLgaNestedInput
    postcodes?: PostcodeUpdateManyWithoutLgaNestedInput
  }

  export type LgaUncheckedUpdateWithoutStatisticsInput = {
    lga_code?: IntFieldUpdateOperationsInput | number
    lga_name?: StringFieldUpdateOperationsInput | string
    council_info?: CouncilInfoUncheckedUpdateOneWithoutLgaNestedInput
    language_proficiencies?: LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaNestedInput
    lga_nationalities?: LgaNationalityUncheckedUpdateManyWithoutLgaNestedInput
    postcodes?: PostcodeUncheckedUpdateManyWithoutLgaNestedInput
  }

  export type EventCreateManyVenueInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    organizer_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
  }

  export type EventUpdateWithoutVenueInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneWithoutEventsNestedInput
    logo?: LogoUpdateOneWithoutEventsNestedInput
    organizer?: OrganizerUpdateOneWithoutEventsNestedInput
    websites?: WebsiteUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutVenueInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    websites?: WebsiteUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutVenueInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCreateManyCategoryInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    organizer_id?: string | null
    venue_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
  }

  export type EventUpdateWithoutCategoryInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    logo?: LogoUpdateOneWithoutEventsNestedInput
    organizer?: OrganizerUpdateOneWithoutEventsNestedInput
    venue?: VenueUpdateOneWithoutEventsNestedInput
    websites?: WebsiteUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCategoryInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    websites?: WebsiteUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCategoryInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCreateManyOrganizerInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    venue_id?: string | null
    logo_id?: bigint | number | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
  }

  export type EventUpdateWithoutOrganizerInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneWithoutEventsNestedInput
    logo?: LogoUpdateOneWithoutEventsNestedInput
    venue?: VenueUpdateOneWithoutEventsNestedInput
    websites?: WebsiteUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutOrganizerInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    websites?: WebsiteUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutOrganizerInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    logo_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCreateManyLogoInput = {
    event_id: string
    event_name: string
    event_description: string
    start_datetime: Date | string
    end_datetime: Date | string
    event_summary: string
    category_id?: string | null
    organizer_id?: string | null
    venue_id?: string | null
    event_status: string
    event_url?: string | null
    is_free_event: boolean
    community_friendly: boolean
    predicted_community_friendly: boolean
  }

  export type EventUpdateWithoutLogoInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneWithoutEventsNestedInput
    organizer?: OrganizerUpdateOneWithoutEventsNestedInput
    venue?: VenueUpdateOneWithoutEventsNestedInput
    websites?: WebsiteUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutLogoInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
    websites?: WebsiteUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutLogoInput = {
    event_id?: StringFieldUpdateOperationsInput | string
    event_name?: StringFieldUpdateOperationsInput | string
    event_description?: StringFieldUpdateOperationsInput | string
    start_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    end_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    event_summary?: StringFieldUpdateOperationsInput | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    organizer_id?: NullableStringFieldUpdateOperationsInput | string | null
    venue_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_status?: StringFieldUpdateOperationsInput | string
    event_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_free_event?: BoolFieldUpdateOperationsInput | boolean
    community_friendly?: BoolFieldUpdateOperationsInput | boolean
    predicted_community_friendly?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WebsiteCreateManyEventInput = {
    event_url: string
  }

  export type WebsiteUpdateWithoutEventInput = {
    event_url?: StringFieldUpdateOperationsInput | string
  }

  export type WebsiteUncheckedUpdateWithoutEventInput = {
    event_url?: StringFieldUpdateOperationsInput | string
  }

  export type WebsiteUncheckedUpdateManyWithoutEventInput = {
    event_url?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateManyProviderInput = {
    course_id: number
    course_title: string
    course_code: string
    qualification_level: string
    course_type: string
    government_subsidised: boolean
    apprenticeship: boolean
    traineeship: boolean
    entry_requirements: string
    description: string
    is_english_course: boolean
  }

  export type LocationCreateManyProviderInput = {
    geographic_id: number
    address_line_1: string
    suburb: string
    postcode: number
    latitude: number
    longitude: number
    full_address: string
    region_name: string
    local_government_authority: string
  }

  export type CourseUpdateWithoutProviderInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_title?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    qualification_level?: StringFieldUpdateOperationsInput | string
    course_type?: StringFieldUpdateOperationsInput | string
    government_subsidised?: BoolFieldUpdateOperationsInput | boolean
    apprenticeship?: BoolFieldUpdateOperationsInput | boolean
    traineeship?: BoolFieldUpdateOperationsInput | boolean
    entry_requirements?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_english_course?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUncheckedUpdateWithoutProviderInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_title?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    qualification_level?: StringFieldUpdateOperationsInput | string
    course_type?: StringFieldUpdateOperationsInput | string
    government_subsidised?: BoolFieldUpdateOperationsInput | boolean
    apprenticeship?: BoolFieldUpdateOperationsInput | boolean
    traineeship?: BoolFieldUpdateOperationsInput | boolean
    entry_requirements?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_english_course?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseUncheckedUpdateManyWithoutProviderInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_title?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    qualification_level?: StringFieldUpdateOperationsInput | string
    course_type?: StringFieldUpdateOperationsInput | string
    government_subsidised?: BoolFieldUpdateOperationsInput | boolean
    apprenticeship?: BoolFieldUpdateOperationsInput | boolean
    traineeship?: BoolFieldUpdateOperationsInput | boolean
    entry_requirements?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    is_english_course?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationUpdateWithoutProviderInput = {
    geographic_id?: IntFieldUpdateOperationsInput | number
    address_line_1?: StringFieldUpdateOperationsInput | string
    suburb?: StringFieldUpdateOperationsInput | string
    postcode?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    full_address?: StringFieldUpdateOperationsInput | string
    region_name?: StringFieldUpdateOperationsInput | string
    local_government_authority?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateWithoutProviderInput = {
    geographic_id?: IntFieldUpdateOperationsInput | number
    address_line_1?: StringFieldUpdateOperationsInput | string
    suburb?: StringFieldUpdateOperationsInput | string
    postcode?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    full_address?: StringFieldUpdateOperationsInput | string
    region_name?: StringFieldUpdateOperationsInput | string
    local_government_authority?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyWithoutProviderInput = {
    geographic_id?: IntFieldUpdateOperationsInput | number
    address_line_1?: StringFieldUpdateOperationsInput | string
    suburb?: StringFieldUpdateOperationsInput | string
    postcode?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    full_address?: StringFieldUpdateOperationsInput | string
    region_name?: StringFieldUpdateOperationsInput | string
    local_government_authority?: StringFieldUpdateOperationsInput | string
  }

  export type LgaLanguageProficiencyCreateManyLgaInput = {
    lga_language_prof_id?: number
    language_id: number
    english_profiency_level: string
    count: number
  }

  export type LgaNationalityCreateManyLgaInput = {
    lga_nationality_id?: number
    nationality_id: number
    count: number
  }

  export type PostcodeCreateManyLgaInput = {
    postcode: number
    suburb: string
    latitude: number
    longitude: number
  }

  export type LgaLanguageProficiencyUpdateWithoutLgaInput = {
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    language?: LanguageUpdateOneRequiredWithoutProficienciesNestedInput
  }

  export type LgaLanguageProficiencyUncheckedUpdateWithoutLgaInput = {
    lga_language_prof_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaLanguageProficiencyUncheckedUpdateManyWithoutLgaInput = {
    lga_language_prof_id?: IntFieldUpdateOperationsInput | number
    language_id?: IntFieldUpdateOperationsInput | number
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaNationalityUpdateWithoutLgaInput = {
    count?: IntFieldUpdateOperationsInput | number
    nationality?: NationalityUpdateOneRequiredWithoutLga_nationalitiesNestedInput
  }

  export type LgaNationalityUncheckedUpdateWithoutLgaInput = {
    lga_nationality_id?: IntFieldUpdateOperationsInput | number
    nationality_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaNationalityUncheckedUpdateManyWithoutLgaInput = {
    lga_nationality_id?: IntFieldUpdateOperationsInput | number
    nationality_id?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type PostcodeUpdateWithoutLgaInput = {
    postcode?: IntFieldUpdateOperationsInput | number
    suburb?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PostcodeUncheckedUpdateWithoutLgaInput = {
    postcode?: IntFieldUpdateOperationsInput | number
    suburb?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PostcodeUncheckedUpdateManyWithoutLgaInput = {
    postcode?: IntFieldUpdateOperationsInput | number
    suburb?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type LgaNationalityCreateManyNationalityInput = {
    lga_nationality_id?: number
    lga_code: number
    count: number
  }

  export type LgaNationalityUpdateWithoutNationalityInput = {
    count?: IntFieldUpdateOperationsInput | number
    lga?: LgaUpdateOneRequiredWithoutLga_nationalitiesNestedInput
  }

  export type LgaNationalityUncheckedUpdateWithoutNationalityInput = {
    lga_nationality_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaNationalityUncheckedUpdateManyWithoutNationalityInput = {
    lga_nationality_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaLanguageProficiencyCreateManyLanguageInput = {
    lga_language_prof_id?: number
    lga_code: number
    english_profiency_level: string
    count: number
  }

  export type LgaLanguageProficiencyUpdateWithoutLanguageInput = {
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    lga?: LgaUpdateOneRequiredWithoutLanguage_proficienciesNestedInput
  }

  export type LgaLanguageProficiencyUncheckedUpdateWithoutLanguageInput = {
    lga_language_prof_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }

  export type LgaLanguageProficiencyUncheckedUpdateManyWithoutLanguageInput = {
    lga_language_prof_id?: IntFieldUpdateOperationsInput | number
    lga_code?: IntFieldUpdateOperationsInput | number
    english_profiency_level?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}